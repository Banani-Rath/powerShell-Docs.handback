<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">14a5473339913a93f4731578790c72f08ddac71f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Foreach.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e9374a96bbcc07aa9b5019b6f8d991fab190adf0</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29cff617b56a2c9d858ed6fd0fed891cd36e58fe</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About ForEach</source>
          <target state="translated">ForEach에 대 한</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Foreach</source>
          <target state="translated">about_Foreach</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">간단한 설명</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes a language command you can use to traverse all the items in a collection of items.</source>
          <target state="translated">항목의 컬렉션에 있는 모든 항목을 이동 하 여 언어 명령에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">자세한 설명</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Foreach statement (also known as a Foreach loop) is a language construct for stepping through (iterating) a series of values in a collection of items.</source>
          <target state="translated">Foreach 문 (Foreach 루프 라고도 함)는는 언어 구문 (반복)를 단계별로 실행 하는 것에 대 한 일련의 항목 컬렉션의 값입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The simplest and most typical type of collection to traverse is an array.</source>
          <target state="translated">간단 하 고 가장 일반적인 통과 하는 컬렉션의 배열입니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Within a Foreach loop, it is common to run one or more commands against each item in an array.</source>
          <target state="translated">이 Foreach 루프 내에서 하나 이상의 명령을 실행 하는 배열에서 각 항목에 대해 일반적입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Syntax The following shows the ForEach syntax:</source>
          <target state="translated">다음 구문에는 ForEach 구문을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>foreach ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>){<ph id="ph3">&lt;statement list&gt;</ph>}</source>
          <target state="translated">foreach ($<ph id="ph1">&lt;item&gt;</ph> $에서<ph id="ph2">&lt;collection&gt;</ph>) {<ph id="ph3">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Simplified syntax Starting in Windows PowerShell 3.0, syntax with language keywords such as Where and ForEach was simplified.</source>
          <target state="translated">간단한 구문을 구문 위치와 같은 언어 키워드와 함께 Windows PowerShell 3.0 부터는 ForEach 간소화 되었습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Comparison operators that work on the members of a collection are treated as parameters.</source>
          <target state="translated">컬렉션의 멤버에서 작동 하는 비교 연산자는 매개 변수로 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can use a method on the members of a collection without containing it in a script block or adding the automatic variable "$_.".</source>
          <target state="translated">스크립트 블록에 포함 된 또는 "$_." 자동 변수를 추가 하지 않고 컬렉션의 구성원에 대 한 메서드를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the following two examples:</source>
          <target state="translated">다음 두 가지 예제를 고려해 야 합니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>dir cert:\ -Recurse | foreach GetKeyAlgorithm dir cert:\ -Recurse | foreach {$_.GetKeyAlgorithm()}</source>
          <target state="translated">dir cert: \ \-Recurse | foreach GetKeyAlgorithm dir cert: \ \-Recurse | foreach {$_입니다. GetKeyAlgorithm()}</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Although both commands work, the first returns results without using a script block or the $_.</source>
          <target state="translated">두 명령을 사용 하기는 하지만 첫 번째 스크립트 블록 또는 $_를 사용 하지 않고 결과 반환 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>automatic variable.</source>
          <target state="translated">자동 변수입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The method GetKeyAlgorithm is treated as a parameter of ForEach.</source>
          <target state="translated">GetKeyAlgorithm 메서드 ForEach의 매개 변수로 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The first command returns the same results, but without errors, because the simplified syntax does not attempt to return results for items for which the specified argument did not apply.</source>
          <target state="translated">첫 번째 명령은 동일한 결과 반환 하지만 오류 없이 지정된 된 인수 적용 되지 않은 항목에 대 한 결과 반환 하는 간단한 구문을 시도 하지 않기 때문입니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Get-Process property Description is passed as a parameter argument of the ForEach statement.</source>
          <target state="translated">이 예제에서는 Get-process 속성 설명 변수로 전달 됩니다 ForEach 문의 매개 변수 인수.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The results are the descriptions of active processes.</source>
          <target state="translated">결과 활성 프로세스의 설명입니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Get-Process | ForEach Description</source>
          <target state="translated">Get-process | ForEach 설명</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The Foreach statement outside a command pipeline The part of the Foreach statement enclosed in parenthesis represents a variable and a collection to iterate.</source>
          <target state="translated">괄호로 묶인 Foreach 문의 일부가 명령 파이프라인 외부에서 Foreach 문을 변수 및 반복 하는 컬렉션을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows PowerShell creates the variable ($<ph id="ph1">&lt;item&gt;</ph>) automatically when the Foreach loop runs.</source>
          <target state="translated">Windows PowerShell 변수를 만듭니다 ($<ph id="ph1">&lt;item&gt;</ph>) Foreach 루프가 실행 될 때 자동으로 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Prior to each iteration through the loop, the variable is set to a value in the collection.</source>
          <target state="translated">각 루프 반복 하기 전에 변수 컬렉션에 있는 값으로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The block following a Foreach statement {<ph id="ph1">&lt;statement list&gt;</ph>} contains a set of commands to execute against each item in a collection.</source>
          <target state="translated">Foreach 문 뒤에 나오는 블록 {<ph id="ph1">&lt;statement list&gt;</ph>} 컬렉션의 각 항목에 대해 실행할 명령 집합을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Examples For example, the Foreach loop in the following example displays the values in the $letterArray array.</source>
          <target state="translated">예제 예를 들어, 다음 예에서 Foreach 루프 $letterArray 배열에 값을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>$letterArray = "a","b","c","d" foreach ($letter in $letterArray) { Write-Host $letter }</source>
          <target state="translated">$letterArray = "a", "b", "c", "d" foreach ($letterArray에서 $letter) {Write-host $letter}</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In this example, the $letterArray array is created and initialized with the string values "a", "b", "c", and "d".</source>
          <target state="translated">이 예제에서는 $letterArray 배열이 만들어지고 초기화 문자열 값을 가진 "a", "b", "c" 및 "d"입니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The first time the Foreach statement runs, it sets the $letter variable equal to the first item in $letterArray ("a").</source>
          <target state="translated">처음 Foreach 문은 실행 설정 $letter 변수 첫 번째 항목 같지 $letterArray ("a")에 합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Then, it uses the Write-Host cmdlet to display the letter a.</source>
          <target state="translated">그런 다음 사용 하 여 Write-host cmdlet의 문자를 표시 하는 합니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The next time through the loop, $letter is set to "b", and so on.</source>
          <target state="translated">다음에 루프를 $letter "b"로 설정 됩니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>After the Foreach loop displays the letter d, Windows PowerShell exits the loop.</source>
          <target state="translated">Foreach 루프 문자 d를 표시 한 후 Windows PowerShell 루프를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement must appear on a single line to run it as a command at the Windows PowerShell command prompt.</source>
          <target state="translated">전체 Foreach 문은 Windows PowerShell 명령 프롬프트에서 명령으로 실행 하는 한 줄에 나타나야 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement does not have to appear on a single line if you place the command in a .ps1 script file instead.</source>
          <target state="translated">전체 Foreach 문은 대신.ps1 스크립트 파일에 명령의 배치 하는 경우에 한 줄에 표시 하지 않아도 됩니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Foreach statements can also be used together with cmdlets that return a collection of items.</source>
          <target state="translated">Foreach 문과 항목의 컬렉션을 반환 하는 cmdlet을 함께 사용할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement steps through the list of items that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">다음 예제에서 Get-childitem cmdlet에서 반환 되는 항목의 목록에서 Foreach 문 단계입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { Write-Host $file }</source>
          <target state="translated">foreach (Get-childitem에 $file) {Write-host $file}</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can refine the example by using an If statement to limit the results that are returned.</source>
          <target state="translated">If를 사용 하 여 예제를 구체화할 수 반환 되는 결과 제한 하는 문입니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement performs the same looping operation as the previous example, but it adds an If statement to limit the results to files that are greater than 100 kilobytes (KB):</source>
          <target state="translated">다음 예제에서는 Foreach 문은 앞의 예제와 동일한 반복 작업을 수행 하지만 추가 If 문을 100 킬로바이트 (KB) 보다 큰 파일에 결과 제한 하려면:</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file } }</source>
          <target state="translated">foreach (Get-childitem에 $file) {경우 (100 KB $file.length-gt) {Write-host $file}}</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach loop uses a property of the $file variable to perform a comparison operation ($file.length -gt 100KB).</source>
          <target state="translated">이 예제에서는 Foreach 루프 ($file.length-gt 100KB) 비교 작업을 수행 하려면 $file 변수의 속성을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The $file variable contains all the properties in the object that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">$File 변수는 Get-childitem cmdlet에서 반환 되는 개체의 모든 속성을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Therefore, you can return more than just a file name.</source>
          <target state="translated">따라서 단순히 파일 이름을 반환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In the next example, Windows PowerShell returns the length and the last access time inside the statement list:</source>
          <target state="translated">다음 예제에서는 Windows PowerShell에는 길이 및 마지막 액세스 시간 문 목록 내 반환합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file Write-Host $file.length Write-Host $file.lastaccesstime } }</source>
          <target state="translated">foreach (Get-childitem에 $file) {경우 (100 KB $file.length-gt) {Write-host $file Write-host $file.length Write-host $file.lastaccesstime}}</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In this example, you are not limited to running a single command in a statement list.</source>
          <target state="translated">이 예제에서는 제한 되지는 않습니다 문 목록의 단일 명령을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can also use a variable outside a Foreach loop and increment the variable inside the loop.</source>
          <target state="translated">Foreach 루프 외부에서 변수를 사용 하 고 루프 내에서 변수를 증가 시킬 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following example counts files over 100 KB in size:</source>
          <target state="translated">다음 예제 파일 크기가 100KB 넘는 계산 합니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>$i = 0 foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file "file size:" ($file.length / 1024).ToString("F0") KB $i = $i + 1 } }</source>
          <target state="translated">$i 0 foreach (Get-childitem에 $file) = {경우 (100 KB $file.length-gt) {Write-host $file "파일 크기:" ($file.length / 1024)입니다. KB $i ToString("F0") $i + 1 =}}</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>if ($i -ne 0) { Write-Host Write-Host $i " file(s) over 100 KB in the current directory."}</source>
          <target state="translated">경우 (0 $i-ne) {쓰기-쓰기 호스트 $i "파일과 넘는 100KB 현재 디렉터리에 있습니다."}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>else { Write-Host "No files greater than 100 KB in the current directory."</source>
          <target state="translated">else {Write-host "파일이 현재 디렉터리에 100 KB 보다 큰."</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the preceding example, the $i variable is set to 0 outside the loop, and the variable is incremented inside the loop for each file that is found that is larger than 100 KB.</source>
          <target state="translated">앞의 예에서 $i 변수에 외부 루프는 0으로 설정 되 고 100 KB 보다 큰 발견 된 각 파일에 대 한 루프 내에서 변수 값이 증가 합니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When the loop exits, an If statement evaluates the value of $i to display a count of all the files over 100 KB.</source>
          <target state="translated">루프가 종료 되 면, If 문을 $i 모든 파일 이상 100 KB의 수를 표시 하려면 값을 계산 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Or, it displays a message stating that no files over 100 KB were found.</source>
          <target state="translated">또는 100 KB 개 파일이 없습니다 되었다는 메시지가 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The previous example also demonstrates how to format the file length results:</source>
          <target state="translated">앞의 예제에는 파일 길이 결과 형식을 지정 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>($file.length / 1024).ToString("F0")</source>
          <target state="translated">($file.length / 1024)입니다. ToString("F0")</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The value is divided by 1,024 to show the results in kilobytes rather than bytes, and the resulting value is then formatted using the fixed-point format specifier to remove any decimal values from the result.</source>
          <target state="translated">값 (바이트) 보다는 (킬로바이트)의 결과 표시 하려면 1024로 나눕니다 않으며 결과 값은 다음 고정 소수점 형식 지정자를 사용 하 여 10 진수 값을 결과에서 제거 됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The 0 makes the format specifier show no decimal places.</source>
          <target state="translated">0 소수 자리를 표시 하는 형식 지정자를 만듭니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The Foreach Statement Inside a Command Pipeline When Foreach appears in a command pipeline, Windows PowerShell uses the foreach alias, which calls the ForEach-Object command.</source>
          <target state="translated">Windows PowerShell Foreach-object 명령을 호출 하는 foreach 별칭을 사용 하 여 오른쪽 Foreach 문 내에 명령 파이프라인 때 Foreach 명령 파이프라인에 나타납니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When you use the foreach alias in a command pipeline, you do not include the ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>) syntax as you do with the Foreach statement.</source>
          <target state="translated">포함 하지 않으면 명령 파이프라인에 foreach 별칭을 사용 하는 경우는 ($<ph id="ph1">&lt;item&gt;</ph> $에서<ph id="ph2">&lt;collection&gt;</ph>) 구문으로 Foreach 문을 사용 하 여 수행 합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is because the prior command in the pipeline provides this information.</source>
          <target state="translated">이 정보를 제공 하는 파이프라인의 이전 명령 때문입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline is as follows:</source>
          <target state="translated">명령 파이프라인에 사용 하는 경우 foreach 별칭의 구문은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>| foreach {&lt;command_block&gt;}</source>
          <target state="translated">| foreach {&lt; command_block &gt;}</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, the Foreach loop in the following command displays processes whose working set (memory usage) is greater than 20 megabytes (MB).</source>
          <target state="translated">예를 들어 다음 명령에는 Foreach 루프는 해당 작업 집합 (메모리 사용)은 20 메가바이트 (MB) 보다 큰 프로세스를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The Get-Process command gets all of the processes on the computer.</source>
          <target state="translated">Get-Process 명령은 컴퓨터의 모든 프로세스를 가져옵니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The Foreach alias performs the commands in the script block on each process in sequence.</source>
          <target state="translated">Foreach는 별칭 시퀀스의 각 프로세스에 스크립트 블록의 명령을 수행합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The IF statement selects processes with a working set (WS) greater than 20 megabytes.</source>
          <target state="translated">IF 문은 20mb 보다 큰 작업 집합 (WS)를 사용 하 여 프로세스를 선택합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Write-Host cmdlet writes the name of the process followed by a colon.</source>
          <target state="translated">Write-host cmdlet에는 콜론으로 프로세스의 이름을 기록 합니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It divides the working set value, which is stored in bytes by 1 megabyte to get the working set value in megabytes.</source>
          <target state="translated">메가바이트의 작업 집합 값을 가져오려면 1 메가바이트 함으로써 바이트에 저장 되는 작업 집합 값을 분할 합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Then it converts the result from a double to a string.</source>
          <target state="translated">그런 다음 문자열을 double에서 결과 변환합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It displays the value as a fixed point number with zero decimals (F0), a space separator (" "), and then "MB".</source>
          <target state="translated">공백 구분 기호 0 자릿수 (F0) 하는 고정된 소수점 숫자 값을 표시 (""), 한 다음 "MB"입니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Write-Host "Processes with working sets greater than 20 MB."</source>
          <target state="translated">쓰기-호스트 "프로세스" 작업 집합이 20MB 보다 큰 사용 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Get-Process | foreach { if ($_.WS -gt 20MB) { Write-Host $.name ": " ($.WS/1MB).ToString("F0") MB -Separator ""} }</source>
          <target state="translated">Get-process | foreach {경우 ($_입니다. 20 MB WS-gt) {Write-host $.name ":" ($입니다. WS/1MB). ToString("F0") MB-구분 기호 ""}}</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks.</source>
          <target state="translated">또한 별칭 foreach 시작 명령 블록을 중간 명령 블록 및 최종 명령 블록을 지원합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.</source>
          <target state="translated">시작과 끝 명령 블록을 한 번 실행 하 고 중간 명령 블록이 실행 될 때마다 Foreach 루프 컬렉션이 나 배열의 단계별로 실행 합니다.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline with a beginning, middle, and ending set of command blocks is as follows:</source>
          <target state="translated">시작, 중간 및 끝 일련의 명령 블록 함께 명령 파이프라인에서 사용 하는 경우 foreach 별칭의 구문은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>| foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>}{<ph id="ph2">&lt;middle
command_block&gt;</ph>}{<ph id="ph3">&lt;ending command_block&gt;</ph>}</source>
          <target state="translated">| foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>} {<ph id="ph2">&lt;middle
command_block&gt;</ph>} {<ph id="ph3">&lt;ending command_block&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of the beginning, middle, and end command blocks.</source>
          <target state="translated">다음 예제에서는 시작, 중간 및 최종 명령 블록의 사용법을 보여줍니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach { $fileCount = $directoryCount = 0}{ if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}{ "$directoryCount directories and $fileCount files"}</source>
          <target state="translated">Get-childitem | foreach {$fileCount $directoryCount = = 0} {경우 ($_입니다. PsIsContainer) {$directoryCount + +} else {$fileCount + +}} {"$directoryCount 디렉터리와 $fileCount 파일"을 (를)</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The beginning block creates and initializes two variables to 0:</source>
          <target state="translated">시작 블록을 만들고 두 개의 변수를 0으로 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>{$fileCount = $directoryCount = 0}</source>
          <target state="translated">{$fileCount $directoryCount = = 0을 (를)</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The middle block evaluates whether each item returned by Get-ChildItem is a directory or a file:</source>
          <target state="translated">중간 블록 Get-childitem에서 반환 된 각 항목은 디렉터리 또는 파일 있는지 여부를 평가 합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>{if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}</source>
          <target state="translated">{경우 ($_입니다. PsIsContainer) {$directoryCount + +} else {$fileCount + +}}</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If the item that is returned is a directory, the $directoryCount variable is incremented by 1.</source>
          <target state="translated">반환 되는 항목의 디렉터리 이면 $directoryCount 변수가 1 씩 증가 합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If the item is not a directory, the $fileCount variable is incremented by 1.</source>
          <target state="translated">디렉터리는 항목이 없는 경우 $fileCount 변수를 1 씩 증가 합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The ending block runs after the middle block completes its looping operation and then returns the results of the operation:</source>
          <target state="translated">끝 블록 실행 중간 블록 반복 작업을 완료 하 고 다음 작업의 결과 반환 됩니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>{"$directoryCount directories and $fileCount files"}</source>
          <target state="translated">{"$directoryCount 파일과 디렉터리 $fileCount"}</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By using the beginning, middle, and ending command block structure and the pipeline operator, you can rewrite the earlier example to find any files that are greater than 100 KB, as follows:</source>
          <target state="translated">시작, 중간 및 마지막 명령 블록 구조와 파이프라인 연산자를 사용 하 여 앞의 예제는 다음과 같이 100 KB 보다 큰 모든 파일을 찾을 수를 다시 작성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach{ $i = 0}{ if ($_.length -gt 100KB) { Write-Host $.name "file size:" ($.length / 1024).ToString("F0") KB $i++ } }{ if ($i -ne 0) { Write-Host Write-Host "$i file(s) over 100 KB in the current directory."</source>
          <target state="translated">Get-childitem | foreach {$i = 0} {경우 ($_.length-gt 100KB) {Write-host $.name "파일 크기:" ($.length / 1024)입니다. ToString("F0") KB $i + +}} {경우 $i-ne (0) {쓰기-쓰기 호스트 "$i 파일 넘는 100KB 현재 디렉터리에."</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>} else { Write-Host "No files greater than 100 KB in the current directory."}</source>
          <target state="translated">} else {Write-host "파일이 현재 디렉터리에 100 KB 보다 큰."}</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example, a function which returns the functions that are used in scripts and script modules, demonstrates how to use the MoveNext method (which works similarly to "skip X" on a For loop) and the Current property of the $foreach variable inside of a foreach script block, even if there are unusually- or inconsistently-spaced function definitions that span multiple lines to declare the function name.</source>
          <target state="translated">다음 예제에서는 스크립트 및 스크립트 모듈에 사용 되는 함수를 반환 하는 함수 함수 이름을 선언 하는 여러 줄에 걸쳐 있는 예외적으로 또는 했었습니다 간격이 함수 정의 경우에의 MoveNext 메서드 (표시 하지 않으려면 "X" For 루프에서 유사 하 게 작동) 및 $foreach 변수는 foreach 스크립트 블록 내에서 현재 속성 사용 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The example also works if there are comments in the functions used in a script or script module.</source>
          <target state="translated">예제에서는 경우에 스크립트 또는 스크립트 모듈에 사용 되는 함수에는 주석이 있습니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>function Get-FunctionPosition { [CmdletBinding()] [OutputType('FunctionPosition')] param( [Parameter(Position=0, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String[]] $Path</source>
          <target state="translated">함수 가져오기 FunctionPosition {param [CmdletBinding()] [OutputType('FunctionPosition')] ([매개 변수 (위치 = 0, 필수, ValueFromPipeline, ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String []] $Path</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">)</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>process { try { $filesToProcess = if ($_ -is [System.IO.FileSystemInfo]) {</source>
          <target state="translated">프로세스 {시도 {$filesToProcess = ($_-[System.IO.FileSystemInfo]은) {</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>} else { Get-Item -Path $Path } foreach ($item in $filesToProcess) { if ($item.PSIsContainer -or $item.Extension -notin @('.ps1','.psm1')) { continue } $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile($item.FullName,([REF]$tokens),([REF]$errors)) if ($errors) { Write-Warning "File '$($item.FullName)' has $($errors.Count) parser errors."</source>
          <target state="translated">} else {Get-item-Path $Path} foreach ($filesToProcess에서 $item) {경우 ($item. PSIsContainer-또는 $item 합니다. 확장-notin @('.ps1','.psm1')) {계속} $tokens $errors = $null $ast = = [System.Management.Automation.Language.Parser]::ParseFile ($item 합니다. FullName,([REF]$tokens),([REF]$errors)) 경우 ($errors) {Write-warning "파일 ' $($item. FullName)'가 $($errors. 개수) 파서 오류입니다. "</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>} :tokenLoop foreach ($token in $tokens) { if ($token.Kind -ne 'Function') { continue } $position = $token.Extent.StartLineNumber do { if (-not $foreach.MoveNext()) { break tokenLoop } $token = $foreach.Current } until ($token.Kind -in @('Generic','Identifier')) $functionPosition = [pscustomobject]@{ Name = $token.Text LineNumber = $position Path = $item.FullName } Add-Member -InputObject $functionPosition -TypeName FunctionPosition -PassThru } } } catch { throw } } }</source>
          <target state="translated">}: tokenLoop foreach ($tokens에서 $token) {경우 ($token 합니다. Kind-ne 'Function') {계속} $position $token =. Extent.StartLineNumber 수행 {경우 (-$foreach 없습니다. {나누기 tokenLoop} MoveNext()) $token $foreach =. 현재}까지 ($token 합니다. Kind-@('Generic','Identifier')) $functionPosition에서에서 [pscustomobject] = @{이름 $token =. 텍스트 줄 번호 = $position 경로 $item =. FullName} Add-member-InputObject $functionPosition-TypeName FunctionPosition-PassThru}}} catch {throw}}}</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables about_If Foreach-Object</source>
          <target state="translated">about_Automatic_Variables about_If Foreach-object</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>