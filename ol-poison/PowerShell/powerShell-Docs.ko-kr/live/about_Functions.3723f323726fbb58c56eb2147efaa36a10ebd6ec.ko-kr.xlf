<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">65e2ae1ed5b110ac2ee9dc80bd6ba9ace2448566</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_Functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1a16b1532bfd0813e901ca3395f5289314aebaf4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cde7cb1dca8bcc02b87d8648daa30265095a6c75</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Functions</source>
          <target state="translated">about_Functions</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Functions</source>
          <target state="translated">함수에 대 한</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Functions</source>
          <target state="translated">about_Functions</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Functions</source>
          <target state="translated">about_Functions</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">간단한 설명</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how to create and use functions in Windows PowerShell.</source>
          <target state="translated">만들고 Windows PowerShell에서 함수를 사용 하는 방법에 설명 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">자세한 설명</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A function is a list of Windows PowerShell statements that has a name that you assign.</source>
          <target state="translated">함수에 할당 하는 이름이 지정 된 Windows PowerShell 문 목록입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When you run a function, you type the function name.</source>
          <target state="translated">함수를 실행 하는 경우에 함수 이름을 입력 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The statements in the list run as if you had typed them at the command prompt.</source>
          <target state="translated">명령 프롬프트에서 입력 한 것 처럼 실행 하는 목록에는 문입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Functions can be as simple as:</source>
          <target state="translated">함수는 간단 하 게 될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>function Get-PowerShellProcess {Get-Process PowerShell}</source>
          <target state="translated">Get-PowerShellProcess {Get-process PowerShell} 함수</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>or as complex as a cmdlet or an application program.</source>
          <target state="translated">또는 cmdlet 또는 응용 프로그램 처럼 복잡할 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Like cmdlets, functions can have parameters.</source>
          <target state="translated">Cmdlet 처럼 함수 매개 변수를 가질 수 있습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The parameters can be named, positional, switch, or dynamic parameters.</source>
          <target state="translated">매개 변수는 명명 된, 위치, 스위치 또는 동적 매개 변수 수 있습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Function parameters can be read from the command line or from the pipeline.</source>
          <target state="translated">함수 매개 변수는 파이프라인 또는 명령줄에서 읽을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Functions can return values that can be displayed, assigned to variables, or passed to other functions or cmdlets.</source>
          <target state="translated">함수는 다른 함수 또는 cmdlet을 표시, 변수에 할당 되거나 전달할 수 있는 값을 반환할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The function's statement list can contain different types of statement lists with the keywords Begin, Process, and End.</source>
          <target state="translated">함수의 문 목록 문 목록 시작, 프로세스 및 최종 키워드와 함께 다양 한 유형의 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>These statement lists handle input from the pipeline differently.</source>
          <target state="translated">이러한 문 목록 파이프라인에서 입력을 다르게 처리 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A filter is a special kind of function that uses the Filter keyword.</source>
          <target state="translated">필터는 필터 키워드를 사용 하는 함수의 특별 한 종류입니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Functions can also act like cmdlets.</source>
          <target state="translated">함수는 cmdlet 처럼도 작동할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can create a function that works just like a cmdlet without using C# programming.</source>
          <target state="translated">C# 프로그래밍을 사용 하지 않고 cmdlet 처럼 작동 하는 함수를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see about_Functions_Advanced (http://go.microsoft.com/fwlink/?LinkID=144511).</source>
          <target state="translated">자세한 내용은 about_Functions_Advanced (http://go.microsoft.com/fwlink/?LinkID=144511)을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Syntax The following is the syntax for a function:</source>
          <target state="translated">다음 구문은 함수를 포함 하는 구문은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>function [&lt;scope:&gt;]<ph id="ph1">&lt;name&gt;</ph> [([type]$parameter1[,[type]$parameter2])] { param([type]$parameter1 [,[type]$parameter2])</source>
          <target state="translated">함수 [&lt; 범위: &gt;]<ph id="ph1">&lt;name&gt;</ph> [([type]$parameter1[,[type]$parameter2])] {param ([유형] $parameter1 [, [유형] 매개 변수 2$])</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>dynamicparam {<ph id="ph1">&lt;statement list&gt;</ph>}</source>
          <target state="translated">dynamicparam {<ph id="ph1">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>begin {<ph id="ph1">&lt;statement list&gt;</ph>} process {<ph id="ph2">&lt;statement list&gt;</ph>} end {<ph id="ph3">&lt;statement list&gt;</ph>} }</source>
          <target state="translated">시작 {<ph id="ph1">&lt;statement list&gt;</ph>} 프로세스 {<ph id="ph2">&lt;statement list&gt;</ph>} 끝 {<ph id="ph3">&lt;statement list&gt;</ph>}}</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A function includes the following items:</source>
          <target state="translated">함수는 다음 항목을 포함 합니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A Function keyword</source>
          <target state="translated">Function 키워드</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A scope (optional)</source>
          <target state="translated">(선택 사항) 범위</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A name that you select</source>
          <target state="translated">선택 하는 이름</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Any number of named parameters (optional)</source>
          <target state="translated">임의 개수의 명명 된 매개 변수 (선택 사항)</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>One or more Windows PowerShell commands enclosed in braces ({})</source>
          <target state="translated">하나 이상의 Windows PowerShell 명령을 중괄호 ({})</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information about the Dynamicparam keyword and dynamic parameters in functions, see about_Functions_Advanced_Parameters.</source>
          <target state="translated">Dynamicparam 키워드와 함수에서 동적 매개 변수 하는 방법에 대 한 자세한 내용은 about_Functions_Advanced_Parameters를 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Simple Functions Functions do not have to be complicated to be useful.</source>
          <target state="translated">간단한 함수 함수 유용할 복잡 하 게 할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The simplest functions have the following format:</source>
          <target state="translated">가장 간단한 함수에는 다음 형식을 갖습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>function &lt;function-name&gt; {statements}</source>
          <target state="translated">&lt; 함수-이름 &gt; {문} 함수</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For example, the following function starts Windows PowerShell with the Run as Administrator option.</source>
          <target state="translated">예를 들어, 다음 함수 관리자 옵션으로 실행 된 Windows PowerShell을 시작 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>function Start-PSAdmin {Start-Process PowerShell -Verb RunAs}</source>
          <target state="translated">함수 시작 PSAdmin {Start-process PowerShell-Verb RunAs}</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>To use the function, type: Start-PSAdmin</source>
          <target state="translated">함수를 사용 하려면 다음을 입력 합니다: 시작 PSAdmin</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To add statements to the function, use a semi-colon (;) to separate the statements, or type each statement on a separate line.</source>
          <target state="translated">문을 함수를 추가 하려면 명령문을 구분 하려면 세미콜론 (;)를 사용 하거나 각 문을 별도 줄에 입력 합니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For example, the following function finds all .jpg files in the current user's directories that were changed after the start date.</source>
          <target state="translated">예를 들어, 다음 함수는 시작 날짜 이후 변경 된 현재 사용자의 디렉터리에서 모든.jpg 파일을 찾습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>function Get-NewPix { $start = Get-Date -Month 1 -Day 1 -Year 2010 $allpix = Get-ChildItem -Path $env:UserProfile<ph id="ph1">\*</ph>.jpg -Recurse $allpix | where {$_.LastWriteTime -gt $Start} }</source>
          <target state="translated">Get NewPix 함수 {$start = Get-date-월-1 일-1 년 2010 $allpix Get-childitem =-$env 경로: UserProfile<ph id="ph1">\*</ph>.jpg-$allpix Recurse | 여기서 {$_입니다. LastWriteTime-gt $Start}}</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can create a toolbox of useful small functions.</source>
          <target state="translated">도구 상자 유용한 작은 함수를 만들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Add these functions to your Windows PowerShell profile, as described in about_Profiles and later in this topic.</source>
          <target state="translated">About_Profiles에이 항목의 뒷부분에 설명 된 대로 Windows PowerShell 프로필에 이러한 기능을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Function Names You can assign any name to a function, but functions that you share with others should follow the naming rules that have been established for all Windows PowerShell commands.</source>
          <target state="translated">함수 이름을 할당할 수 임의의 이름을 함수에 있지만 함수가 다른 사용자와 공유 하는 모든 Windows PowerShell 명령에 대해 설정 된 명명 규칙을 따라야 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Functions names should consist of a verb-noun pair in which the verb identifies the action that the function performs and the noun identifies the item on which the cmdlet performs its action.</source>
          <target state="translated">함수 이름은 함수가 수행 하는 동작을 식별 하는 동사와 명사 cmdlet에 해당 작업을 수행 하는 항목을 식별 하는 동사-명사 쌍 구성 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Functions should use the standard verbs that have been approved for all Windows PowerShell commands.</source>
          <target state="translated">함수는 모든 Windows PowerShell 명령의 승인 된 표준 동사를 사용 해야 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>These verbs help us to keep our command names simple, consistent, and easy for users to understand.</source>
          <target state="translated">이러한 동사 단순 하 고 일관성 있는 사용자가 이해 하기 쉬운 우리의 명령 이름을 유지 하는 데 활용 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information about the standard Windows PowerShell verbs, see "Cmdlet Verbs" on MSDN at http://go.microsoft.com/fwlink/?LinkID=160773.</source>
          <target state="translated">표준 Windows PowerShell 동사에 대 한 자세한 내용은 MSDN의 "Cmdlet 동사"을 http://go.microsoft.com/fwlink/?LinkID=160773에서 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Functions with Parameters You can use parameters with functions, including named parameters, positional parameters, switch parameters, and dynamic parameters.</source>
          <target state="translated">명명 된 매개 변수, 위치 매개 변수, 스위치 매개 변수 및 동적 매개 변수를 포함 하 여 함수를 사용 하 여 매개 변수를 사용 하는 함수 매개 변수를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For more information about dynamic parameters in functions, see about_Functions_Advanced_Parameters (http://go.microsoft.com/fwlink/?LinkID=135173).</source>
          <target state="translated">함수에서 동적 매개 변수에 대 한 자세한 내용은 about_Functions_Advanced_Parameters (http://go.microsoft.com/fwlink/?LinkID=135173)을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Named Parameters You can define any number of named parameters.</source>
          <target state="translated">명명 된 매개 변수 수를 정의할 수 명명 된 매개 변수가 있습니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can include a default value for named parameters, as described later in this topic.</source>
          <target state="translated">이 항목의 뒷부분에 설명 된 대로 명명 된 매개 변수에 대 한 기본값을 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can define parameters inside the braces using the Param keyword, as shown in the following sample syntax:</source>
          <target state="translated">다음 구문 예제와 같이 Param 키워드를 사용 하 고 중괄호 안에 매개 변수를 정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>function <ph id="ph1">&lt;name&gt;</ph> { param ([type]$parameter1[,[type]$parameter2]) <ph id="ph2">&lt;statement list&gt;</ph> }</source>
          <target state="translated">함수 <ph id="ph1">&lt;name&gt;</ph> {param ([type]$parameter1[,[type]$parameter2]) <ph id="ph2">&lt;statement list&gt;</ph> }</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can also define parameters outside the braces without the Param keyword, as shown in the following sample syntax:</source>
          <target state="translated">또한 다음 샘플 구문에 나와 있는 것 처럼 Param 키워드 없이 괄호 밖에 매개 변수를 정의할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>function <ph id="ph1">&lt;name&gt;</ph> [([type]$parameter1[,[type]$parameter2])] { <ph id="ph2">&lt;statement list&gt;</ph> }</source>
          <target state="translated">함수 <ph id="ph1">&lt;name&gt;</ph> [([type]$parameter1[,[type]$parameter2])] { <ph id="ph2">&lt;statement list&gt;</ph> }</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>There is no difference between these two methods.</source>
          <target state="translated">이 두 메서드 간의 차이가 없습니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Use the method that you prefer.</source>
          <target state="translated">선호 하는 메서드를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>When you run the function, the value you supply for a parameter is assigned to a variable that contains the parameter name.</source>
          <target state="translated">함수를 실행할 때 매개 변수에 대해 제공 하는 값 매개 변수 이름을 포함 하는 변수에 할당 됩니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The value of that variable can be used in the function.</source>
          <target state="translated">함수에서 해당 변수의 값을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following example is a function called Get-SmallFiles.</source>
          <target state="translated">다음 예제에는 Get SmallFiles를 호출 하는 함수입니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This function has a $size parameter.</source>
          <target state="translated">이 함수는 $size 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The function displays all the files that are smaller than the value of the $size parameter, and it excludes directories:</source>
          <target state="translated">함수 $size 매개 변수의 값 보다 작은 모든 파일을 표시 하 고 디렉터리를 제외 합니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>function Get-SmallFiles { param ($size) Get-ChildItem c:\ | where {$.Length -lt $Size -and !$.PSIsContainer} }</source>
          <target state="translated">함수 가져오기 SmallFiles {param ($size) Get-childitem c:\ | 여기서 {$입니다. Length-lt $Size-및! $입니다. PSIsContainer}}</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the function, you can use the $size variable, which is the name defined for the parameter.</source>
          <target state="translated">함수에서이 매개 변수 이름을 $size 변수를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>To use this function, type the following command:</source>
          <target state="translated">이 함수를 사용 하려면 다음 명령을 입력 합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; function Get-SmallFiles –Size 50</source>
          <target state="translated">C:\PS &gt; Get SmallFiles 함수 – 크기 50</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>You can also enter a value for a named parameter without the parameter name.</source>
          <target state="translated">또한 명명된 된 매개 변수 없이 매개 변수 이름에 대 한 값을 입력할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For example, the following command gives the same result as a command that names the Size parameter:</source>
          <target state="translated">예를 들어 다음 명령은 크기 매개 변수 이름을 지정 하는 명령으로 동일한 결과 제공 합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; function Get-SmallFiles 50</source>
          <target state="translated">C:\PS &gt; Get SmallFiles 50 함수</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>To define a default value for a parameter, type an equal sign and the value after the parameter name, as shown in the following variation of the Get-SmallFiles example:</source>
          <target state="translated">매개 변수에 대해 기본값을 정의 하려면 뒤에 입력에 등호와 값 매개 변수 이름에는 다음 변형 Get SmallFiles 예제에에서 표시 된 대로:</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>function Get-SmallFiles ($size = 100) { Get-ChildItem c:\ | where {$.Length -lt $Size -and !$.PSIsContainer} }</source>
          <target state="translated">Get SmallFiles 함수 ($size = 100) {Get-childitem c:\ | 여기서 {$입니다. Length-lt $Size-및! $입니다. PSIsContainer}}</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If you type "Get-SmallFiles" without a value, the function assigns 100 to $size.</source>
          <target state="translated">값이 없는 "Get-SmallFiles"를 입력 하는 경우 함수는 $size에 100을 할당 합니다.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If you provide a value, the function uses that value.</source>
          <target state="translated">값을 제공 하는 경우 함수는 해당 값을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a brief help string that describes the default value of your parameter, by adding the PSDefaultValue attribute to the description of your parameter, and specifying the Help property of PSDefaultValue.</source>
          <target state="translated">필요에 따라 프로그램 매개 변수 설명을 PSDefaultValue 특성을 추가 하 고 PSDefaultValue의 도움말 속성을 지정 하 여 매개 변수의 기본값을 설명 하는 간략 한 도움말 문자열을 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>To provide a help string that describes the default value (100) of the Size parameter in the Get-SmallFiles function, add the PSDefaultValue attribute as shown in the following example.</source>
          <target state="translated">Get SmallFiles 함수에서 매개 변수 크기의 기본값 (100)을 설명 하는 도움말 문자열을 제공 하려면 다음 예와에서 같이 PSDefaultValue 특성을 추가 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>function Get-SmallFiles { param ( [PSDefaultValue(Help = '100')] $size = 100</source>
          <target state="translated">함수 가져오기 SmallFiles {param ([PSDefaultValue (도움말 = '100')] $size = 100</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information about the PSDefaultValue attribute class, see PSDefaultValue Attribute Members on MSDN.</source>
          <target state="translated">PSDefaultValue 특성 클래스에 대 한 자세한 내용은 MSDN에서 PSDefaultValue 특성 멤버를 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>(http://msdn.microsoft.com/library/windows/desktop/system.management.automation.psdefaultvalueattribute_members(v=vs.85).aspx</source>
          <target state="translated">(http://msdn.microsoft.com/library/windows/desktop/system.management.automation.psdefaultvalueattribute_members (v=vs.85).aspx</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Positional Parameters A positional parameter is a parameter without a parameter name.</source>
          <target state="translated">위치 매개 변수는 위치 매개 변수는 매개 변수 이름 사용 하지 않고 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Windows PowerShell uses the parameter value order to associate each parameter value with a parameter in the function.</source>
          <target state="translated">Windows PowerShell 함수에서 매개 변수와 각 매개 변수 값을 연결 하는 매개 변수 값 순서를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When you use positional parameters, type one or more values after the function name.</source>
          <target state="translated">위치 매개 변수를 사용 하면 함수 이름 뒤 하나 이상의 값을 입력 합니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Positional parameter values are assigned to the $args array variable.</source>
          <target state="translated">위치 매개 변수 값은 $args 배열 변수에 할당 됩니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The value that follows the function name is assigned to the first position in the $args array, $args[0].</source>
          <target state="translated">함수 이름 뒤에 오는 값 [0] $args $args 배열에서 첫 번째 위치에 할당 됩니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The following Get-Extension function adds the .txt file name extension to a file name that you supply:</source>
          <target state="translated">사용자가 제공 하는 파일 이름에.txt 파일 이름 확장명을 추가 하는 다음 Get 확장 함수:</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>function Get-Extension { $name = $args[0] + ".txt" $name }</source>
          <target state="translated">함수 가져오기 확장 {$name = [0] $args + ".txt" $name}</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Get-Extension myTextFile myTextFile.txt</source>
          <target state="translated">C:\PS &gt; myTextFile myTextFile.txt Get-확장</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Switch Parameters A switch is a parameter that does not require a value.</source>
          <target state="translated">스위치 매개 변수는 스위치는 값이 필요 하지 않는 하는 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Instead, you type the function name followed by the name of the switch parameter.</source>
          <target state="translated">대신, 스위치 매개 변수 이름과 함수 이름을 입력 합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>To define a switch parameter, specify the type [switch] before the parameter name, as shown in the following example:</source>
          <target state="translated">스위치 매개 변수를 정의 하려면 다음 예제와 같이 매개 변수 이름 앞 유형 [switch]를 지정 합니다.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>function Switch-Item { param ([switch]$on) if ($on) { "Switch on" } else { "Switch off" } }</source>
          <target state="translated">스위치 항목을 작동 {param (에서 [switch] $) 하는 경우 ($) {"켜기"} else {"해제"}}</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>When you type the On switch parameter after the function name, the function displays "Switch on".</source>
          <target state="translated">함수 이름 뒤에 스위치 매개 변수를 입력할 때 함수 표시 "켜기"입니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Without the switch parameter, it displays "Switch off".</source>
          <target state="translated">스위치 매개 변수 없이 "해제"를 표시합니다.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Switch-Item -on Switch on</source>
          <target state="translated">C:\PS &gt; 스위치-항목-에 스위치</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Switch-Item Switch off</source>
          <target state="translated">C:\PS &gt; 스위치를 off 스위치 항목</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can also assign a Boolean value to a switch when you run the function, as shown in the following example:</source>
          <target state="translated">할당할 수 있습니다도 부울 값을 스위치에는 함수를 실행 하는 경우 다음 예와에서 같이:</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Switch-Item -on:$true Switch on</source>
          <target state="translated">C:\PS &gt; 스위치-항목-에: $true 스위치에</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Switch-Item -on:$false Switch off</source>
          <target state="translated">C:\PS &gt; 스위치-항목-에: $false 해제</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Using Splatting to Represent Command Parameters You can use splatting to represent the parameters of a command.</source>
          <target state="translated">스 플랫을 나타내는 명령 매개 변수를 사용 하 여 명령의 매개 변수를 나타내는 스 플랫을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This feature is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">이 기능은 Windows PowerShell 3.0에서 도입 되었습니다.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Use this technique in functions that call commands in the session.</source>
          <target state="translated">세션에서 명령을 호출 하는 함수에서이 기법을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>You do not need to declare or enumerate the command parameters, or change the function when command parameters change.</source>
          <target state="translated">선언 하거나 명령 매개 변수를 열거 해야 또는 명령 매개 변수 변경 될 때 함수를 변경 하지 않는 합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following sample function calls the Get-Command cmdlet.</source>
          <target state="translated">다음 예제 함수는 Get-command cmdlet을 호출합니다.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The command uses @Args to represent the parameters of Get-Command.</source>
          <target state="translated">이 명령은 @Args를 사용 하 여 Get 명령의 매개 변수를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>function Get-MyCommand { Get-Command @Args }</source>
          <target state="translated">Get-MyCommand {Get-command @Args} 함수</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You can use all of the parameters of Get-Command when you call the Get-MyCommand function.</source>
          <target state="translated">Get MyCommand 함수를 호출할 때 모든 Get 명령의 매개 변수를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The parameters and parameter values are passed to the command using @Args.</source>
          <target state="translated">매개 변수 및 매개 변수 값은 @Args를 사용 하 여 명령에 전달 됩니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>PS C:&gt;Get-MyCommand -Name Get-ChildItem CommandType     Name                ModuleName</source>
          <target state="translated">PS c: &gt; Get MyCommand-Get-childitem CommandType 이름 ModuleName 이름 지정</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Cmdlet          Get-ChildItem       Microsoft.PowerShell.Management</source>
          <target state="translated">Get-childitem Cmdlet Microsoft.PowerShell.Management</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The @Args feature uses the $Args automatic parameter, which represents undeclared cmdlet parameters and values from remaining arguments.</source>
          <target state="translated">@Args 기능 $Args 자동 매개 변수를 사용, 나머지 인수에서 선언 되지 않은 cmdlet 매개 변수 및 값을 나타냅니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For more information about splatting, see about_Splatting (http://go.microsoft.com/fwlink/?LinkId=262720).</source>
          <target state="translated">스 플랫에 대 한 자세한 내용은 about_Splatting (http://go.microsoft.com/fwlink/?LinkId=262720)을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Piping Objects to Functions Any function can take input from the pipeline.</source>
          <target state="translated">함수에 파이핑 개체 모든 함수는 파이프라인의에서 입력을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>You can control how a function processes input from the pipeline using Begin, Process, and End keywords.</source>
          <target state="translated">함수 시작, 프로세스 및 최종 키워드를 사용 하 여 파이프라인의 입력을 처리 하는 방법을 제어할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following sample syntax shows the three keywords:</source>
          <target state="translated">다음 예제 구문 키워드 세 개를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>function <ph id="ph1">&lt;name&gt;</ph> { begin {<ph id="ph2">&lt;statement list&gt;</ph>} process {<ph id="ph3">&lt;statement list&gt;</ph>} end {<ph id="ph4">&lt;statement list&gt;</ph>} }</source>
          <target state="translated">함수 <ph id="ph1">&lt;name&gt;</ph> {시작 {<ph id="ph2">&lt;statement list&gt;</ph>} 프로세스 {<ph id="ph3">&lt;statement list&gt;</ph>} 끝 {<ph id="ph4">&lt;statement list&gt;</ph>}}</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The Begin statement list runs one time only, at the beginning of the function.</source>
          <target state="translated">Begin 문 목록 함수의 시작 부분에 한 번만 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The Process statement list runs one time for each object in the pipeline.</source>
          <target state="translated">프로세스 문 목록 파이프라인의 각 개체에 대해 한 번씩을 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>While the Process block is running, each pipeline object is assigned to the $_ automatic variable, one pipeline object at a time.</source>
          <target state="translated">Process 블록 실행 되는 동안에 각 파이프라인 개체는 $_ automatic 변수를 한 번에 하나의 파이프라인 개체에 할당 됩니다.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>After the function receives all the objects in the pipeline, the End statement list runs one time.</source>
          <target state="translated">End 문 목록 파이프라인의 모든 개체를 수신 하는 함수를 한 번을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>If no Begin, Process, or End keywords are used, all the statements are treated like an End statement list.</source>
          <target state="translated">없는 시작, 프로세스 또는 End 키워드를 사용 하는 모든 문은 End 문 목록 처럼 취급 됩니다.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The following function uses the Process keyword.</source>
          <target state="translated">다음 함수는 Process 키워드를 사용합니다.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The function displays examples from the pipeline:</source>
          <target state="translated">함수는 파이프라인에서 예를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>function Get-Pipeline { process {"The value is: $_"} }</source>
          <target state="translated">Get 파이프라인 함수 {프로세스 {"값은: $_"}}</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>To demonstrate this function, enter an list of numbers separated by commas, as shown in the following example:</source>
          <target state="translated">이 함수를 보여 주기 위해 다음 예와에서 같이 목록을 쉼표로 구분 하 여 숫자를 입력 합니다.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; 1,2,4 | Get-Pipeline The value is: 1 The value is: 2 The value is: 4</source>
          <target state="translated">C:\PS &gt; 1,2,4 | 값은 get-파이프라인: 값이 1: 값이 2: 4</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>When you use a function in a pipeline, the objects piped to the function are assigned to the $input automatic variable.</source>
          <target state="translated">함수를 사용 하 여 파이프라인의 함수에 파이프 하는 개체 $input 자동 변수에 할당 됩니다.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The function runs statements with the Begin keyword before any objects come from the pipeline.</source>
          <target state="translated">함수는 파이프라인에서 모든 개체를 제공 하기 전에 Begin 키워드로 문을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The function runs statements with the End keyword after all the objects have been received from the pipeline.</source>
          <target state="translated">함수는 모든 개체를 파이프라인에서 받은 후 최종 키워드와 함께 문을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The following example shows the $input automatic variable with Begin and End keywords.</source>
          <target state="translated">다음 예제에서는 Begin 및 End 키워드로 $input 자동 변수를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>function Get-PipelineBeginEnd { begin {"Begin: The input is $input"} end {"End:   The input is $input" } }</source>
          <target state="translated">Get PipelineBeginEnd 함수 {시작 {"Begin: 입력이 $input"} 끝 {"끝: 입력이 $input"}}</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If this function is run by using the pipeline, it displays the following results:</source>
          <target state="translated">이 함수는 파이프라인을 사용 하 여을 실행 하는 경우에 다음과 같은 결과가 표시 됩니다.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; 1,2,4 | Get-PipelineBeginEnd Begin: The input is End:   The input is 1 2 4</source>
          <target state="translated">C:\PS &gt; 1,2,4 | Get PipelineBeginEnd 시작: 입력이 끝: 입력이 1 2 4</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>When the Begin statement runs, the function does not have the input from the pipeline.</source>
          <target state="translated">Begin 문은 실행 되 면 함수는 파이프라인의 입력 없는 경우</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The End statement runs after the function has the values.</source>
          <target state="translated">End 문 함수에 값 후 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>If the function has a Process keyword, the function reads the data in $input.</source>
          <target state="translated">함수에 있는 경우 프로세스 키워드, 함수 $input에 데이터를 읽습니다.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The following example has a Process statement list:</source>
          <target state="translated">다음 예제에서는 프로세스 문 목록을 있습니다.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>function Get-PipelineInput { process {"Processing:  $_ " } end {"End:   The input is: $input" } }</source>
          <target state="translated">Get PipelineInput 함수 {프로세스 {"처리: $_"을 (를) 최종 {"끝: 입력이: $input"}}</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>In this example, each object that is piped to the function is sent to the Process statement list.</source>
          <target state="translated">이 예제에서는 함수에 파이프 하는 각 개체는 프로세스 문 목록으로 전송 됩니다.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The Process statements run on each object, one object at a time.</source>
          <target state="translated">프로세스 문을 실행 하 고 각 개체에 대해 한 번에 하나의 개체입니다.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The $input automatic variable is empty when the function reaches the End keyword.</source>
          <target state="translated">함수는 End 키워드에 이르면 $input 자동 변수가 비어 있습니다.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; 1,2,4 | Get-PipelineInput Processing:  1 Processing:  2 Processing:  4 End:   The input is:</source>
          <target state="translated">C:\PS &gt; 1,2,4 | Get PipelineInput 처리: 1, 처리: 2 처리: 4 끝: 입력이 있습니다.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Filters A filter is a type of function that runs on each object in the pipeline.</source>
          <target state="translated">필터는 필터에는 파이프라인의 각 개체에서 실행 되는 함수의 형식입니다.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>A filter resembles a function with all its statements in a Process block.</source>
          <target state="translated">필터는 Process 블록에는 모든 문 사용 하는 함수와 유사합니다.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The syntax of a filter is as follows:</source>
          <target state="translated">필터 구문은 다음과 같습니다.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>filter [&lt;scope:&gt;]<ph id="ph1">&lt;name&gt;</ph> {<ph id="ph2">&lt;statement list&gt;</ph>}</source>
          <target state="translated">필터 [&lt; 범위: &gt;]<ph id="ph1">&lt;name&gt;</ph> {<ph id="ph2">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The following filter takes log entries from the pipeline and then displays either the whole entry or only the message portion of the entry:</source>
          <target state="translated">다음과 같은 필터는 로그 항목을 파이프라인에서 사용 하 고 전체 항목 또는 항목의 메시지 부분에만 표시 합니다.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>filter Get-ErrorLog ([switch]$message) { if ($message) { out-host -inputobject $<bpt id="p1">_</bpt>.Message } else { $<ept id="p1">_</ept> } }</source>
          <target state="translated">([switch] $message) Get-오류 로그를 필터링 {경우 ($message) {-inputobject $ out-host<bpt id="p1">_</bpt>합니다. 메시지} else {$<ept id="p1">_</ept> }}</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Function Scope A function exists in the scope in which it was created.</source>
          <target state="translated">함수 범위는 함수를 만든 범위에 존재 합니다.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>If a function is part of a script, the function is available to statements within that script.</source>
          <target state="translated">함수 스크립트의 일부 이면 기능은 문에 해당 스크립트 내에서 사용할 수입니다.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>By default, a function in a script is not available at the command prompt.</source>
          <target state="translated">기본적으로 스크립트의 함수를 사용할 수 없는 경우 명령 프롬프트에서</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>You can specify the scope of a function.</source>
          <target state="translated">함수 범위를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For example, the function is added to the global scope in the following example:</source>
          <target state="translated">예를 들어 함수에서 다음 예제에서는 전역 범위에 추가 됩니다.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>function global:Get-DependentSvs { Get-Service | where {$_.DependentServices} }</source>
          <target state="translated">전역 함수: Get DependentSvs {Get-service | 여기서 {$_입니다. DependentServices}}</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>When a function is in the global scope, you can use the function in scripts, in functions, and at the command line.</source>
          <target state="translated">전역 범위에 함수를 스크립트, 함수에서 및 명령줄에서의 함수를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Functions normally create a scope.</source>
          <target state="translated">함수는 일반적으로 범위를 만듭니다.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The items created in a function, such as variables, exist only in the function scope.</source>
          <target state="translated">변수와 같은 함수에서 만든 항목 함수 범위에만 존재 합니다.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For more information about scope in Windows PowerShell, see about_Scopes (http://go.microsoft.com/fwlink/?LinkID=113260).</source>
          <target state="translated">Windows PowerShell의 범위에 대 한 자세한 내용은 about_Scopes (http://go.microsoft.com/fwlink/?LinkID=113260)을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Finding and Managing Functions Using the Function: Drive All the functions and filters in Windows PowerShell are automatically stored in the Function: drive.</source>
          <target state="translated">찾기 및 함수를 사용 하 여 기능 관리: 드라이브 모든 함수 및 Windows PowerShell의 필터 함수에서 자동으로 저장 됩니다: 드라이브입니다.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This drive is exposed by the Windows PowerShell Function provider.</source>
          <target state="translated">이 드라이브는 Windows PowerShell 함수 공급자에 의해 노출 됩니다.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>When referring to the Function: drive, type a colon after Function, just as you would do when referencing the C or D drive of a computer.</source>
          <target state="translated">함수를 참조할 때: 드라이브를 컴퓨터의 C 또는 D 드라이브를 참조할 때 수행 하는 것 처럼 함수를 다음 콜론을 입력 합니다.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The following command displays all the functions in the current session of Windows PowerShell:</source>
          <target state="translated">다음 명령은 Windows PowerShell의 현재 세션의 모든 기능을 표시합니다.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Get-ChildItem function:</source>
          <target state="translated">Get-childitem 함수:</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The commands in the function are stored as a script block in the definition property of the function.</source>
          <target state="translated">함수에 명령은 함수의 정의 속성에 스크립트 블록으로 저장 됩니다.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>For example, to display the commands in the Help function that comes with Windows PowerShell, type:</source>
          <target state="translated">예를 들어 명령을 Windows PowerShell과 함께 제공 되는 도움말 함수에서를 표시 하려면 다음을 입력 합니다.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>(Get-ChildItem function:help).Definition</source>
          <target state="translated">(Get-childitem 함수: 도움말)입니다. 정의</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>For more information about the Function: drive, see the help topic for the Function provider.</source>
          <target state="translated">함수에 대 한 자세한 내용은: 드라이브 함수 공급자에 대 한 도움말 항목을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Type "Get-Help Function" or view it in the TechNet Library at http://go.microsoft.com/fwlink/?LinkID=113436.</source>
          <target state="translated">"Get-help 함수"를 입력 하거나 http://go.microsoft.com/fwlink/?LinkID=113436는 TechNet 라이브러리에서 확인 합니다.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Reusing Functions in New Sessions When you type a function at the Windows PowerShell command prompt, the function becomes part of the current session.</source>
          <target state="translated">Windows PowerShell 명령 프롬프트에서 함수를 입력 하는 새 세션에서 함수를 다시 사용, 함수는 현재 세션의 일부가 됩니다.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>It is available until the session ends.</source>
          <target state="translated">세션이 종료 될 때까지입니다.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>To use your function in all Windows PowerShell sessions, add the function to your Windows PowerShell profile.</source>
          <target state="translated">모든 Windows PowerShell 세션에서 함수를 사용 하려면 Windows PowerShell 프로필에 함수를 추가 합니다.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>For more information about profiles, see about_Profiles (http://go.microsoft.com/fwlink/?LinkID=113729).</source>
          <target state="translated">프로필에 대 한 자세한 내용은 about_Profiles (http://go.microsoft.com/fwlink/?LinkID=113729)를 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>You can also save your function in a Windows PowerShell script file.</source>
          <target state="translated">또한 Windows PowerShell 스크립트 파일에서 함수를 저장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Type your function in a text file, and then save the file with the .ps1 file name extension.</source>
          <target state="translated">텍스트 파일에서 함수를 입력 하 고.ps1 파일 이름 확장명으로 파일을 저장 합니다.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Writing Help for Functions The Get-Help cmdlet gets help for functions, as well as for cmdlets, providers, and scripts.</source>
          <target state="translated">함수는 Get-help cmdlet에 대 한 도움말을 작성 cmdlet, 공급자 및 스크립트 뿐만 아니라 함수에 대 한 도움말을 가져옵니다.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>To get help for a function, type Get-Help followed by the function name.</source>
          <target state="translated">함수에 대 한 도움말을 보려면 Get-help 뒤에 함수 이름을 입력 합니다.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For example, to get help for the Get-MyDisks function, type:</source>
          <target state="translated">예를 들어 Get MyDisks 함수에 대 한 도움말을 보려면 다음을 입력 합니다.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Get-Help Get-MyDisks</source>
          <target state="translated">Get-help Get MyDisks</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>You can write help for a function by using either of the two following methods:</source>
          <target state="translated">다음 두 가지 방법 중 하나를 사용 하 여 함수에 대 한 도움말을 작성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>--  Comment-Based Help  for Functions</source>
          <target state="translated">-함수에 대 한 설명 기반 도움말</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Create a help topic by using special keywords in the comments.</source>
          <target state="translated">설명에 특수 한 키워드를 사용 하 여 도움말 항목을 만듭니다.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>To create comment-based help for a function, the comments must be placed at the beginning or end of the function body or on the lines preceding the function keyword.</source>
          <target state="translated">함수에 대 한 설명 기반 도움말을 만들려면 주석 또는 function 키워드 앞에 오는 줄에서 또는 함수 본문의 끝 부분에 배치 되어야 합니다.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>For more information about comment-based help, see about_Comment_Based_Help.</source>
          <target state="translated">설명 기반 도움말에 대 한 자세한 내용은 about_Comment_Based_Help를 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>--  XML-Based Help  for Functions</source>
          <target state="translated">-함수에 대 한 도움말 XML 기반</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Create an XML-based help topic, such as the type that is typically created for cmdlets.</source>
          <target state="translated">XML 기반 도움말 항목, 일반적으로 cmdlet에 대해 만들어지는 형식 등을 만듭니다.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>XML-based help is required if you are localizing help topics into multiple languages.</source>
          <target state="translated">XML 기반 도움말은 도움말 항목을 여러 언어로 지역화 하는 경우에 필요 합니다.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>To associate the function with the XML-based help topic, use the .ExternalHelp comment-based help keyword.</source>
          <target state="translated">함수는 XML 기반 도움말 항목을 연결 하려면 사용 하 여는 합니다. ExternalHelp 설명 기반 도움말 키워드입니다.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Without this keyword, Get-Help cannot find the function help topic and calls to Get-Help for the function return only auto-generated help.</source>
          <target state="translated">이 키워드를 사용 하지 Get-help 함수 도움말 항목을 찾을 수 없습니다 및 함수에 대 한 Get-help 호출만 자동으로 생성 된 도움말을 반환 합니다.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>For more information about the ExternalHelp keyword, see about_Comment_Based_Help.</source>
          <target state="translated">ExternalHelp 키워드에 대 한 자세한 내용은 about_Comment_Based_Help를 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>For more information about XML-based help, see "How to Write Cmdlet Help" in MSDN.</source>
          <target state="translated">XML 기반 도움말에 대 한 자세한 내용은 "어떻게 Cmdlet 도움말 작성" msdn에서을 참조 하십시오.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables about_Comment_Based_Help about_Functions_Advanced about_Functions_Advanced_Methods about_Functions_Advanced_Parameters about_Functions_CmdletBindingAttribute about_Functions_OutputTypeAttribute about_Parameters about_Profiles about_Scopes about_Script_Blocks Function (provider)</source>
          <target state="translated">about_Automatic_Variables about_Comment_Based_Help about_Functions_Advanced about_Functions_Advanced_Methods about_Functions_Advanced_Parameters about_Functions_CmdletBindingAttribute about_Functions_OutputTypeAttribute about_Parameters about_Profiles about_Scopes about_Script_Blocks 함수 (공급자)</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>