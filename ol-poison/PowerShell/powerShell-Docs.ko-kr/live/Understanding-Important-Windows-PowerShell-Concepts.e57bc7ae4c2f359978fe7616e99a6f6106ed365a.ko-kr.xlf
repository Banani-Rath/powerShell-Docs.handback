<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-56a7a5e" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">db5f410c8f84949c969f21ed59ac48a4e31e91fd</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\fundamental\Understanding-Important-Windows-PowerShell-Concepts.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9899b997eb3f0fab1c30143868cbd8d7890b0ce5</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Understanding Important Windows PowerShell Concepts</source>
          <target state="translated">중요한 Windows PowerShell 개념 이해</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Understanding Important Windows PowerShell Concepts</source>
          <target state="translated">중요한 Windows PowerShell 개념 이해</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell design integrates concepts from many different environments.</source>
          <target state="translated">Windows PowerShell 디자인은 다양한 환경의 개념을 통합합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Several of them are familiar to people with experience in specific shells or programming environments, but very few people will know about all of them.</source>
          <target state="translated">그 중에서 여러 개념은 특정 셸 또는 프로그래밍 환경의 경험자에게 익숙하지만 모든 개념을 알고 있는 사용자는 거의 없습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Looking at some of these concepts provides a useful overview of the shell.</source>
          <target state="translated">이러한 개념 중 일부를 살펴보면 셸에 대한 전반적인 유용한 정보를 얻을 수 있습니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Commands Are Not Text<ph id="ph1">\-</ph>Based</source>
          <target state="translated">텍스트를 기반으로 하지 않는 명령</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Unlike traditional command<ph id="ph1">\-</ph>line interface commands, Windows PowerShell cmdlets are designed to deal with objects <ph id="ph2">\-</ph> structured information that is more than just a string of characters appearing on the screen.</source>
          <target state="translated">이전의 명령줄 인터페이스 명령과 달리 Windows PowerShell cmdlet은 단순히 화면에 표시되는 문자열이 아니라 개체, 즉 구조화된 정보를 처리하도록 설계되었습니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Command output always carries along extra information that you can use if you need it.</source>
          <target state="translated">명령 출력에는 필요할 때 사용할 수 있는 추가 정보가 항상 포함됩니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>We will discuss this topic in depth in this document.</source>
          <target state="translated">이 문서에서는 이 항목에 대해 자세히 설명합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If you have used text<ph id="ph1">\-</ph>processing tools to process command<ph id="ph2">\-</ph>line data in the past, you will find that they behave differently if you try to use them in Windows PowerShell.</source>
          <target state="translated">Windows PowerShell에서는 텍스트 처리 도구가 이전의 명령줄 인터페이스에서와 다른 방식으로 명령줄 데이터를 처리하기 때문에</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In most cases, you do not need text<ph id="ph1">\-</ph>processing tools to extract specific information.</source>
          <target state="translated">대부분의 경우 텍스트 처리 도구를 사용하여 특정 정보를 추출할 필요가 없습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can access portions of the data directly by using standard Windows PowerShell object manipulation commands.</source>
          <target state="translated">표준 Windows PowerShell 개체 조작 명령을 사용하면 데이터의 일부에 직접 액세스할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The Command Family Is Extensible</source>
          <target state="translated">확장 가능한 명령 패밀리</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Interfaces such as Cmd.exe do not provide a way for you to directly extend the built<ph id="ph1">\-</ph>in command set.</source>
          <target state="translated">Cmd.exe와 같은 인터페이스에서는 기본 제공 명령 집합을 직접 확장할 수 없습니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can create external command<ph id="ph1">\-</ph>line tools that run in Cmd.exe, but these external tools do not have services, such as Help integration, and Cmd.exe does not automatically know that they are valid commands.</source>
          <target state="translated">Cmd.exe에서 실행되는 외부 명령줄 도구를 만들 수는 있지만 이러한 외부 도구에는 도움말 통합 같은 서비스가 없기 때문에 Cmd.exe는 이러한 외부 도구가 유효한 명령인지 자동으로 인식하지 못합니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The native binary commands in Windows PowerShell, known as <bpt id="p1">*</bpt>cmdlets<ept id="p1">*</ept> (pronounced command<ph id="ph1">\-</ph>lets), can be augmented by cmdlets that you create and that you add to Windows PowerShell by using snap<ph id="ph2">\-</ph>ins.</source>
          <target state="translated"><bpt id="p1">*</bpt>cmdlet<ept id="p1">*</ept>(커맨드렛으로 읽음)이라고 하는 Windows PowerShell의 기본 이진 명령은 cmdlet을 만든 다음 스냅인을 사용하여 cmdlet을 Windows PowerShell에 추가함으로써 확장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Windows PowerShell <bpt id="p1">*</bpt>snap<ph id="ph1">\-</ph>ins<ept id="p1">*</ept> are compiled, just like binary tools in any other interface.</source>
          <target state="translated">Windows PowerShell <bpt id="p1">*</bpt>스냅인<ept id="p1">*</ept>은 다른 모든 인터페이스의 이진 도구처럼 컴파일됩니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You can use them to add Windows PowerShell providers to the shell, as well as new cmdlets.</source>
          <target state="translated">Windows PowerShell 스냅인을 사용하면 셸에 새 cmdlet뿐 아니라 Windows PowerShell 공급자도 추가할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Because of the special nature of the Windows PowerShell internal commands, we will refer to them as <bpt id="p1">*</bpt>cmdlets<ept id="p1">*</ept>.</source>
          <target state="translated">이 설명서에서는 Windows PowerShell 내부 명령도 특성상 <bpt id="p1">*</bpt>cmdlet<ept id="p1">*</ept>이라고 합니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Windows PowerShell can run commands other than cmdlets.</source>
          <target state="translated">Windows PowerShell에서는 cmdlet 이외의 명령을 실행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>We will not be discussing them in detail in the Windows PowerShell User's Guide, but they are useful to know about as categories of command types.</source>
          <target state="translated">이 Windows PowerShell 사용자 가이드에서 자세히 설명하지 않지만 이러한 명령은 명령 유형을 범주로 구분하는 데 유용합니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Windows PowerShell supports scripts that are analogous to UNIX shell scripts and Cmd.exe batch files, but have a .ps1 file name extension.</source>
          <target state="translated">Windows PowerShell은 UNIX 셸 스크립트 및 Cmd.exe 배치 파일과 유사하지만 파일 이름 확장명이 .ps1인 스크립트를 지원합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Windows PowerShell also allows you to create internal functions that can be used directly in the interface or in scripts.</source>
          <target state="translated">또한 Windows PowerShell에서는 인터페이스나 스크립트에서 직접 사용할 수 있는 내부 함수를 만들 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Windows PowerShell Handles Console Input and Display</source>
          <target state="translated">Windows Powershell은 콘솔 입력 및 표시 처리합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>When you type a command, Windows PowerShell always processes the command<ph id="ph1">\-</ph>line input directly.</source>
          <target state="translated">사용자가 명령을 입력하면 Windows PowerShell은 항상 이 명령줄 입력을 직접 처리합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows PowerShell also formats the output that you see on the screen.</source>
          <target state="translated">또한 Windows PowerShell은 화면에 표시되는 출력의 형식을 지정합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This is significant because it reduces the work required of each cmdlet and ensures that you can always do things the same way regardless of which cmdlet you are using.</source>
          <target state="translated">이 기능은 각 cmdlet에 대해 수행해야 하는 작업을 줄여주고 사용 중인 cmdlet에 관계없이 항상 동일한 방식으로 작업을 수행할 수 있도록 해 주기 때문에 중요합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>One example of how this simplifies life for both tool developers and users is command<ph id="ph1">\-</ph>line Help.</source>
          <target state="translated">이 기능을 통해 도구 개발자와 도구 사용자의 작업을 단순화하는 방법의 예로 명령줄 도움말을 들 수 있습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Traditional command<ph id="ph1">\-</ph>line tools have their own schemes for requesting and displaying Help.</source>
          <target state="translated">이전의 명령줄 도구는 도움말을 요청하고 표시하는 자체 구성을 갖습니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Some command<ph id="ph1">\-</ph>line tools use <bpt id="p1">**</bpt><ph id="ph2">\/</ph>?<ept id="p1">**</ept></source>
          <target state="translated">일부 명령줄 도구는 <bpt id="p1">**</bpt><ph id="ph2">\/</ph>?<ept id="p1">**</ept>를 사용하여</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>to trigger the Help display; others use <bpt id="p1">**</bpt><ph id="ph1">\-</ph>?<ept id="p1">**</ept>, <bpt id="p2">**</bpt><ph id="ph2">\/</ph>H<ept id="p2">**</ept>, or even <bpt id="p3">**</bpt><ph id="ph3">\/\/</ph><ept id="p3">**</ept>.</source>
          <target state="translated">도움말 표시를 트리거하고, 일부 명령줄 도구는 <bpt id="p1">**</bpt><ph id="ph1">\-</ph>?<ept id="p1">**</ept> 또는 <bpt id="p2">**</bpt><ph id="ph2">\/</ph>H<ept id="p2">**</ept>뿐 아니라 심지어 <bpt id="p3">**</bpt><ph id="ph3">\/\/</ph><ept id="p3">**</ept>를 사용하여 도움말 표시를 트리거합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Some will display Help in a GUI window, rather than in the console display.</source>
          <target state="translated">또한 일부 명령줄 도구는 콘솔 화면 대신 GUI 창에 도움말을 표시합니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Some complex tools, such as application updaters, unpack internal files before displaying their Help.</source>
          <target state="translated">응용 프로그램 업데이트 프로그램과 같이 일부 복잡한 도구는 도움말을 표시하기 전에 내부 파일의 압축을 풉니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you use the wrong parameter, the tool might ignore what you typed and begin performing a task automatically.</source>
          <target state="translated">사용자가 잘못된 매개 변수를 사용할 경우 이러한 도구는 사용자의 입력 내용을 무시하고 자동으로 작업을 시작할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>When you enter a command in Windows PowerShell, everything you enter is automatically parsed and pre<ph id="ph1">\-</ph>processed by Windows PowerShell.</source>
          <target state="translated">Windows PowerShell에서 명령을 입력하면 Windows PowerShell은 자동으로 이러한 명령을 구문 분석하고 전처리합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If you use the <bpt id="p1">**</bpt><ph id="ph1">\-</ph>?<ept id="p1">**</ept></source>
          <target state="translated">Windows PowerShell cmdlet에서 <bpt id="p1">**</bpt><ph id="ph1">\-</ph>?<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>parameter with a Windows PowerShell cmdlet, it always means "show me Help for this command".</source>
          <target state="translated">매개 변수를 사용하는 경우 이는 항상 "해당 명령에 대한 도움말을 표시"하라는 의미입니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Cmdlet developers do not have to parse the command; they only need to provide the Help text.</source>
          <target state="translated">Cmdlet 개발자는 명령을 구문 분석할 필요 없이 도움말 텍스트만 제공하면 됩니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It is important to understand that the Help features of Windows PowerShell are available even when you run traditional command<ph id="ph1">\-</ph>line tools in Windows PowerShell.</source>
          <target state="translated">Windows PowerShell에서 이전의 명령줄 도구를 사용하는 경우에도 Windows PowerShell의 도움말 기능은 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Windows PowerShell processes the parameters and passes the results to the external tools.</source>
          <target state="translated">Windows PowerShell은 매개 변수를 처리하고 그 결과를 외부 도구에 전달합니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you run an graphic application in Windows PowerShell, the window for the application opens.</source>
          <target state="translated">Windows PowerShell에서 그래픽 응용 프로그램을 실행하면 해당 응용 프로그램의 창이 열립니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Windows PowerShell intervenes only when processing the command<ph id="ph1">\-</ph>line input you supply or the application output returned to the console window; it does not affect how the application works internally.</source>
          <target state="translated">Windows PowerShell은 사용자가 제공하는 명령줄 입력이나 콘솔 창에 반환되는 응용 프로그램 출력을 처리할 때만 개입하고 응용 프로그램이 자체적으로 작업을 수행하는 방식에는 영향을 주지 않습니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Windows PowerShell Uses Some C<ph id="ph1">\#</ph> Syntax</source>
          <target state="translated">일부 C<ph id="ph1">\#</ph> 구문을 사용하는 Windows PowerShell</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Windows PowerShell has syntax features and keywords that are very similar to those used in the C<ph id="ph1">\#</ph> programming language, because Windows PowerShell is based on the .NET Framework.</source>
          <target state="translated">Windows PowerShell은 .NET Framework를 기반으로 하기 때문에 Windows PowerShell에는 C<ph id="ph1">\#</ph> 프로그래밍 언어에서 사용하는 것과 매우 유사한 구문 기능과 키워드가 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Learning Windows PowerShell will make it much easier to learn C<ph id="ph1">\#</ph>, if you are interested in the language.</source>
          <target state="translated">C<ph id="ph1">\#</ph>에 관심이 있을 경우 Windows PowerShell에 대해 알면 C#을 익히기가 훨씬 더 쉬워집니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If you are not a C<ph id="ph1">\#</ph> programmer, this similarity is not important.</source>
          <target state="translated">C<ph id="ph1">\#</ph> 프로그래머가 아닐 경우 이러한 유사함은 별로 도움이 되지 않지만</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>However, if you are already familiar with C<ph id="ph1">\#</ph>, the similarities can make learning Windows PowerShell much easier.</source>
          <target state="translated">C<ph id="ph1">\#</ph>에 대해 잘 알고 있을 경우 이러한 유사함을 통해 Windows PowerShell을 훨씬 더 쉽게 익힐 수 있습니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>