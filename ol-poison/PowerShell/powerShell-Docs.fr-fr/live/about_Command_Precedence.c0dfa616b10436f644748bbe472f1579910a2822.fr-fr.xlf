<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e64799232a97a2ccc413eedab8847a68fc45f805</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Command_Precedence.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a73f57efd0a2d7eb74d3017f761cf8de22d9dbed</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff216515ee10fbdc6f1053f80852fa01f0958004</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">applet de commande PowerShell</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Command Precedence</source>
          <target state="translated">Sur la priorité des commandes</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIPTION COURTE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how Windows PowerShell determines which command to run.</source>
          <target state="translated">Décrit la façon dont Windows PowerShell détermine la commande à exécuter.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIPTION DÉTAILLÉE</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic explains how Windows PowerShell determines which command to run, especially when a session contains more than one command with the same name.</source>
          <target state="translated">Cette rubrique explique comment Windows PowerShell détermine la commande à exécuter, en particulier lorsqu’une session contient plusieurs commandes portant le même nom.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It also explains how to run commands that do not run by default, and it explains how to avoid command-name conflicts in your session.</source>
          <target state="translated">Il explique également comment exécuter des commandes qui ne s’exécutent pas par défaut, et elle explique comment éviter les conflits de nom de la commande dans votre session.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>COMMAND PRECEDENCE</source>
          <target state="translated">PRIORITÉ DES COMMANDES</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When a session includes commands that have the same name, Windows PowerShell uses the following rules to decide which command to run.</source>
          <target state="translated">Lorsqu’une session comprend des commandes qui ont le même nom, Windows PowerShell utilise les règles suivantes pour décider de la commande à exécuter.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>These rules become very important when you add commands to your session from modules, snap-ins, and other sessions.</source>
          <target state="translated">Ces règles sont très importants lorsque vous ajoutez des commandes à votre session des sessions de composants et d’autres modules.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>-- If you specify the path to a command, Windows PowerShell runs the command at the location specified by the path.</source>
          <target state="translated">--Si vous spécifiez le chemin d’accès à une commande, Windows PowerShell exécute la commande à l’emplacement spécifié par le chemin d’accès.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the following command runs the FindDocs.ps1 script in the C:\TechDocs directory:</source>
          <target state="translated">Par exemple, la commande suivante exécute le script FindDocs.ps1 dans le répertoire C:\TechDocs :</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>C:\TechDocs\FindDocs.ps1</source>
          <target state="translated">C:\TechDocs\FindDocs.ps1</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>As a security feature, Windows PowerShell does not run executable (native) commands, including Windows PowerShell scripts, unless the command is located in a path that is listed in the Path environment variable ($env:path) or unless you specify the path to the script file.</source>
          <target state="translated">Comme une fonctionnalité de sécurité, Windows PowerShell n’exécute pas les commandes exécutables (natifs), y compris les scripts Windows PowerShell, sauf si la commande se trouve dans un chemin d’accès qui est répertorié dans la variable d’environnement Path ($env : chemin d’accès), sauf si vous spécifiez le chemin d’accès au fichier de script.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>To run a script that is in the current directory, specify the full path, or type a dot (.) to represent the current directory.</source>
          <target state="translated">Pour exécuter un script qui se trouve dans le répertoire actif, spécifiez le chemin d’accès complet, ou tapez un point (.) pour représenter le répertoire en cours.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example, to run the FindDocs.ps1 file in the current directory, type:</source>
          <target state="translated">Par exemple, pour exécuter le fichier FindDocs.ps1 dans le répertoire en cours, tapez :</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>.\FindDocs.ps1</source>
          <target state="translated">.\FindDocs.ps1</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>-- If you do not specify a path, Windows PowerShell uses the following precedence order when it runs commands:</source>
          <target state="translated">--Si vous ne spécifiez pas un chemin d’accès, Windows PowerShell utilise l’ordre de priorité suivant lorsqu’il exécute des commandes :</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Cmdlet</source>
          <target state="translated">Applet de commande</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Native Windows commands</source>
          <target state="translated">Commandes Windows natives</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Therefore, if you type "help", Windows PowerShell first looks for an alias named "help", then a function named "Help", and finally a cmdlet named "Help".</source>
          <target state="translated">Par conséquent, si vous tapez « help », Windows PowerShell recherche d’abord un alias nommé « help », puis une fonction nommée « Help », et enfin une applet de commande nommé « Help ».</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It runs the first "help" item that it finds.</source>
          <target state="translated">Il exécute le premier élément « help » qu’il trouve.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, if you have a Get-Map function in the session and you import a cmdlet named Get-Map.</source>
          <target state="translated">Par exemple, si vous avez une fonction Get-carte dans la session et que vous importez une applet de commande nommée Get-carte.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>By default, when you type "Get-Map", Windows PowerShell runs the Get-Map function.</source>
          <target state="translated">Par défaut, lorsque vous tapez « Get-carte », Windows PowerShell exécute la fonction Get-carte.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-- When the session contains items of the same type that have the same name, such as two cmdlets with the same name, Windows PowerShell runs the item that was added to the session most recently.</source>
          <target state="translated">--Lorsque la session contient des éléments du même type ayant le même nom, par exemple deux applets de commande avec le même nom, Windows PowerShell s’exécute à l’élément qui a été ajouté à la session la plus récente.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, if you have a cmdlet named Get-Date and you import another cmdlet named Get-Date, by default, Windows PowerShell runs the most-recently imported cmdlet when you type "Get-Date".</source>
          <target state="translated">Par exemple, si vous disposez d’une applet de commande nommée Get-Date et que vous importez une autre applet de commande nommée Get-Date, par défaut, Windows PowerShell exécute l’applet de commande plus récemment importé lorsque vous tapez « Get-Date ».</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>HIDDEN and REPLACED ITEMS As a result of these rules, items can be replaced or hidden by items with the same name.</source>
          <target state="translated">ÉLÉMENTS MASQUÉ et REMPLACÉ suite à ces règles, les éléments peuvent être remplacés ou masqués par les éléments portant le même nom.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>--  Items are "hidden" or "shadowed" if you can still access the original item, such as by qualifying the item name with a module or snap-in name.</source>
          <target state="translated">--Éléments sont « masquées » ou « masqués » si vous pouvez toujours accéder l’élément d’origine, par exemple en qualifiant le nom de l’élément avec un module ou un nom de composant.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, if you import a function that has the same name as a cmdlet in the session, the cmdlet is hidden (but not replaced) because it was imported from a snap-in or module.</source>
          <target state="translated">Par exemple, si vous importez une fonction qui a le même nom qu’une applet de commande dans la session, l’applet de commande est masquée (mais pas remplacé), car il a été importé à partir d’un module ou un composant logiciel enfichable.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>--  Items are "replaced" or "overwritten" if you can no longer access the original item.</source>
          <target state="translated">--Éléments sont « remplacés » ou « remplacés » si vous ne pouvez plus accéder l’élément d’origine.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, if you import a variable that has the same name as a a variable in the session, the original variable is replaced and is no longer accessible.</source>
          <target state="translated">Par exemple, si vous importez une variable qui a le même nom qu’une variable dans la session, la variable d’origine est remplacée et n’est plus accessible.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You cannot qualify a variable with a module name.</source>
          <target state="translated">Vous ne pouvez pas qualifier une variable avec un nom de module.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Also, if you type a function at the command line and then import a function with the same name, the original function is replaced and is no longer accessible.</source>
          <target state="translated">En outre, si vous tapez une fonction à la ligne de commande et l’importer une fonction portant le même nom, la fonction d’origine est remplacée et n’est plus accessible.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>FINDING HIDDEN COMMANDS</source>
          <target state="translated">COMMANDES DE RECHERCHE MASQUÉE</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The All parameter of the Get-Command cmdlet gets all commands with the specified name, even if they are hidden or replaced.</source>
          <target state="translated">Le paramètre All de l’applet de commande Get-Command Obtient toutes les commandes portant le nom spécifié, même s’ils sont masqués ou remplacés.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, by default, Get-Command gets only the commands that run when you type the command name.</source>
          <target state="translated">À compter de Windows PowerShell 3.0, par défaut, Get-Command obtient uniquement les commandes qui s’exécutent lorsque vous tapez le nom de la commande.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In the following examples, the session includes a Get-Date function and a Get-Date cmdlet.</source>
          <target state="translated">Dans les exemples suivants, la session inclut une fonction Get-Date et une applet de commande Get-Date.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following command gets the Get-Date command that runs when you type "Get-Date".</source>
          <target state="translated">La commande suivante obtient la commande Get-Date qui s’exécute lorsque vous tapez « Get-Date ».</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-Command Get-Date</source>
          <target state="translated">C: &gt; Get-Command Get-Date</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>CommandType     Name                                               ModuleName</source>
          <target state="translated">Nom du module CommandType nom</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Function        get-date</source>
          <target state="translated">Fonction get-date</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following command uses the All parameter to get all Get-Date commands.</source>
          <target state="translated">La commande suivante utilise le paramètre All pour obtenir toutes les commandes Get-Date.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-Command Get-Date -All</source>
          <target state="translated">C: &gt; Get-Command Get-Date-tous</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>CommandType     Name                                               ModuleName</source>
          <target state="translated">Nom du module CommandType nom</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Function        get-date Cmdlet          Get-Date                                           Microsoft.PowerShell.Utility</source>
          <target state="translated">Fonction get-date applet de commande Get-Date Microsoft.PowerShell.Utility</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>RUNNING HIDDEN COMMANDS</source>
          <target state="translated">COMMANDES MASQUÉES EN COURS D’EXÉCUTION</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can run particular commands by specifying item properties that distinguish the command from other commands that might have the same name.</source>
          <target state="translated">Vous pouvez exécuter des commandes particuliers en spécifiant les propriétés de l’élément qui le distinguent de la commande à partir d’autres commandes qui peuvent avoir le même nom.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can use this method to run any command, but it is especially useful for running hidden commands.</source>
          <target state="translated">Vous pouvez utiliser cette méthode pour exécuter des commandes, mais il est particulièrement utile pour exécuter des commandes masquées.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Use this method as a best practice when writing scripts that you intend to distribute because you cannot predict which commands might be present in the session in which the script runs.</source>
          <target state="translated">Utilisez cette méthode comme une meilleure pratique lors de l’écriture de scripts que vous souhaitez distribuer, car vous ne pouvez pas prédire les commandes qui peuvent être présentes dans la session dans laquelle le script s’exécute.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>QUALIFIED NAMES</source>
          <target state="translated">NOMS QUALIFIÉS</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can run commands that have been imported from a Windows PowerShell snap-in or module or from another session by qualifying the command name with the name of the module or snap-in in which it originated.</source>
          <target state="translated">Vous pouvez exécuter des commandes qui ont été importés à partir d’un composant logiciel enfichable Windows PowerShell ou un module ou d’une autre session en qualifiant le nom de commande avec le nom du module ou enfichable d'où elle provient.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can qualify commands, but you cannot qualify variables or aliases.</source>
          <target state="translated">Vous pouvez qualifier les commandes, mais vous ne pouvez pas qualifier variables ou des alias.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For example, if the Get-Date cmdlet from the Microsoft.PowerShell.Utility snap-in is hidden by an alias, function, or cmdlet with the same name, you can run it by using the snap-in-qualified name of the cmdlet:</source>
          <target state="translated">Par exemple, si l’applet de commande Get-Date à partir du composant logiciel enfichable Microsoft.PowerShell.Utility est masqué par un alias, une fonction ou une applet de commande avec le même nom, vous pouvez l’exécuter à l’aide du composant logiciel enfichable-nom qualifié de l’applet de commande :</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Microsoft.PowerShell.Utility\Get-Date</source>
          <target state="translated">Microsoft.PowerShell.Utility\Get-Date</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To run a New-Map command that was added by the MapFunctions module, use its module-qualified name:</source>
          <target state="translated">Pour exécuter une commande New-carte qui a été ajoutée par le module MapFunctions, utilisez son nom qualifié par un module :</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>MapFunctions\New-Map</source>
          <target state="translated">Mappage de MapFunctions\New</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To find the snap-in or module from which a command was imported, use the ModuleName property of commands.</source>
          <target state="translated">Pour trouver le composant logiciel enfichable ou un module à partir de laquelle une commande a été importée, utilisez la propriété nom du module de commandes.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>(Get-Command &lt;command-name&gt;).ModuleName</source>
          <target state="translated">(Get-Command &lt; nom de la commande &gt;). Nom du module</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, to find the source of the Get-Date cmdlet, type:</source>
          <target state="translated">Par exemple, pour rechercher la source de l’applet de commande Get-Date, tapez :</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>PS C:&gt;(Get-Command Get-Date).ModuleName Microsoft.PowerShell.Utility</source>
          <target state="translated">C: &gt; (Get-Command Get-Date). Nom du module Microsoft.PowerShell.Utility</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>CALL OPERATOR</source>
          <target state="translated">OPÉRATEUR D’APPEL</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can also use the Call operator (&amp;) to run any command that you can get by using a Get-ChildItem (the alias is "dir"), Get-Command, or Get-Module command.</source>
          <target state="translated">Vous pouvez également utiliser l’opérateur d’appel (&amp;) pour exécuter des commandes que vous pouvez obtenir en utilisant un Get-ChildItem (l’alias est « dir »), Get-Command ou Get-Module commande.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>To run a command, enclose the Get-Command command in parentheses, and use the Call operator (&amp;) to run the command.</source>
          <target state="translated">Pour exécuter une commande, la commande Get-Command mettre entre parenthèses et utiliser l’opérateur d’appel (&amp;) pour exécuter la commande.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>&amp;(Get-Command ...)</source>
          <target state="translated">&amp; (get-Command...)</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>or -</source>
          <target state="translated">ou -</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>&amp;(dir ... )</source>
          <target state="translated">&amp;(dir...)</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For example, if you have a function named Map that is hidden by an alias named Map, use the following command to run the function.</source>
          <target state="translated">Par exemple, si vous avez une fonction nommée carte est masqué par un mappage d’alias nommé, utilisez la commande suivante pour exécuter la fonction.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>&amp;(Get-Command -Name Map -Type function)</source>
          <target state="translated">&amp; (get-Command - nom de mappage-fonction de Type)</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>or -</source>
          <target state="translated">ou -</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>&amp;(dir function:\map)</source>
          <target state="translated">&amp; (fonction dir : \map)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can also save your hidden command in a variable to make it easier to run.</source>
          <target state="translated">Vous pouvez également enregistrer votre commande masquée dans une variable pour le rendre plus facile à exécuter.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For example, the following command saves the Map function in the $myMap variable and then uses the Call operator to run it.</source>
          <target state="translated">Par exemple, la commande suivante enregistre la fonction de mappage dans la variable $myMap et utilise ensuite l’opérateur d’appel pour l’exécuter.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>$myMap = (Get-Command -Name map -Type function)</source>
          <target state="translated">$myMap = (get-Command - nom map - fonction de Type)</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>&amp;($myMap)</source>
          <target state="translated">&amp;($myMap)</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If a command originated in a module, you can use the following format to run it.</source>
          <target state="translated">Si une commande est créée dans un module, vous pouvez utiliser le format suivant pour l’exécuter.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>&amp; &lt;PSModuleInfo-object&gt;</source>
          <target state="translated">&amp; &lt; objet PSModuleInfo &gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For example, to run the Add-File cmdlet in the FileCommands module, use the following command sequence.</source>
          <target state="translated">Par exemple, pour exécuter l’applet de commande Add-File dans le module FileCommands, utilisez la séquence de commandes.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>$FileCommands = get-module -name FileCommands</source>
          <target state="translated">$FileCommands = get-module-name FileCommands</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>&amp; $FileCommands Add-File</source>
          <target state="translated">&amp; Ajouter $FileCommands-fichier</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>REPLACED ITEMS</source>
          <target state="translated">LES ÉLÉMENTS REMPLACÉS</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Items that have not been imported from a module or snap-in, such as functions, variables, and aliases that you create in your session or that you add by using a profile can be replaced by commands that have the same name.</source>
          <target state="translated">Les éléments qui n’ont pas été importés à partir d’un module ou un logiciel enfichable, telles que les fonctions, variables et les alias que vous créez dans votre session ou que vous ajoutez à l’aide d’un profil peuvent être remplacés par les commandes qui ont le même nom.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If they are replaced, you cannot access them.</source>
          <target state="translated">Si elles sont remplacées, vous ne pouvez pas y accéder.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Variables and aliases are always replaced even if they have been imported from a module or snap-in because you cannot use a call operator or a qualified name to run them.</source>
          <target state="translated">Variables et les alias sont remplacés toujours même si elles ont été importées à partir d’un module enfichable ou car vous ne pouvez pas utiliser un opérateur d’appel ou un nom qualifié pour les exécuter.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, if you type a Get-Map function in your session, and you import a function called Get-Map, the original function is replaced.</source>
          <target state="translated">Par exemple, si vous tapez une fonction Get-carte dans votre session et que vous importez une fonction appelée Get-carte, la fonction d’origine est remplacée.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You cannot retrieve it in the current session.</source>
          <target state="translated">Vous ne pouvez pas récupérer dans la session active.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>AVOIDING NAME CONFLICTS</source>
          <target state="translated">PRÉVENTION DES CONFLITS DE NOM</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The best way to manage command name conflicts is to prevent them.</source>
          <target state="translated">La meilleure façon de gérer les conflits de nom de commande consiste à les empêcher.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When you name your commands, use a name that is very specific or is likely to be unique.</source>
          <target state="translated">Lorsque vous nommez vos commandes, utilisez un nom qui est très spécifique, ou est susceptible d’être unique.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For example, add your initials or company name acronym to the nouns in your commands.</source>
          <target state="translated">Par exemple, ajouter vos initiales ou un acronyme de nom de société pour les noms de vos commandes.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Also, when you import commands into your session from a Windows PowerShell module or from another session, use the Prefix parameter of the Import-Module or Import-PSSession cmdlet to add a prefix to the nouns in the names of commands.</source>
          <target state="translated">En outre, lorsque vous importez des commandes dans votre session à partir d’un module Windows PowerShell ou d’une autre session, utilisez le paramètre de préfixe de la cmdlet Import-Module ou Import-PSSession pour ajouter un préfixe pour les noms dans les noms de commandes.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, the following command avoids any conflict with the Get-Date and Set-Date cmdlets that come with Windows PowerShell when you import the DateFunctions module.</source>
          <target state="translated">Par exemple, la commande suivante permet d’éviter tout conflit avec les applets de commande Get-Date et Set-Date qui sont fournis avec Windows PowerShell lorsque vous importez le module DateFunctions.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Import-Module -Name DateFunctions -Prefix ZZ</source>
          <target state="translated">Import-Module-Name DateFunctions-préfixe ZZ</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For more information, see Import-Module and Import-PSSession.</source>
          <target state="translated">Pour plus d’informations, consultez Import-Module et Import-PSSession.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">VOIR AUSSI</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>about_Path_Syntax about_Aliases about_Functions Alias (provider) Function (provider) Get-Command Import-Module Import-PSSession</source>
          <target state="translated">about_Path_Syntax about_Aliases about_Functions Alias (fournisseur) (fournisseur) Get-Command Import-Module Import-PSSession (fonction)</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>