<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">51548e7963935b35c8796be7947fd23a4fa53440</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Splatting.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9f9533fc32907f82b0f1522a1b487753fa3b067e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ae441651a33a38fb6adb54d944f2fdf31e5766d7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">applet de commande PowerShell</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Splatting</source>
          <target state="translated">À propos de l’opérateur de Splatting</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIPTION COURTE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how to use splatting to pass parameters to commands in Windows PowerShell.</source>
          <target state="translated">Décrit comment utiliser l’opérateur de splatting pour passer des paramètres aux commandes dans Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIPTION DÉTAILLÉE</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>[This topic was contributed by Rohn Edwards of Gulfport, Mississippi, a system administrator and the winner of the Advanced Division of the 2012 Scripting Games.</source>
          <target state="translated">[Cette rubrique a été fournie par Rohn Edwards de Gulfport, Mississippi, un administrateur système et le vainqueur de la catégorie Avancé des jeux de script 2012.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Revised for Windows PowerShell 3.0.]</source>
          <target state="translated">Mis à jour pour Windows PowerShell 3.0.]</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Splatting is a method of passing a collection of parameter values to a command as unit.</source>
          <target state="translated">Opérateur de splatting est une méthode de passage d’une collection de valeurs de paramètre à une commande en tant qu’unité.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Windows PowerShell associates each value in the collection with a command parameter.</source>
          <target state="translated">Windows PowerShell associe chaque valeur dans la collection à un paramètre de commande.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Splatted parameter values are stored in named splatting variables, which look like standard variables, but begin with an At symbol (@) instead of a dollar sign ($).</source>
          <target state="translated">Splatted les valeurs de paramètre sont stockés dans des variables nommées opérateur de splatting, qui ressemblent à des variables standard, mais commencent par un symbole At (@) au lieu d’un signe dollar ($).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The At symbol tells Windows PowerShell that you are passing a collection of values, instead of a single value.</source>
          <target state="translated">Le symbole At indique à Windows PowerShell que vous passez une collection de valeurs, plutôt qu’une valeur unique.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Splatting makes your commands shorter and easier to read.</source>
          <target state="translated">Opérateur de splatting rend vos commandes plus courtes et plus faciles à lire.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can re-use the splatting values in different command calls and use splatting to pass parameter values from the $PSBoundParameters automatic variable to other scripts and functions.</source>
          <target state="translated">Vous pouvez réutiliser les valeurs de l’opérateur de splatting dans les appels de commande et utiliser un opérateur de splatting pour passer des valeurs de paramètre à partir de la variable automatique $PSBoundParameters à d’autres scripts et les fonctions.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, you can also use splatting to represent all parameters of a command.</source>
          <target state="translated">À compter de Windows PowerShell 3.0, vous pouvez également utiliser opérateur de splatting pour représenter tous les paramètres d’une commande.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">SYNTAXE</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To provide parameter values for positional parameters, in which parameter names are not required, use the array syntax.</source>
          <target state="translated">Pour fournir des valeurs de paramètre pour les paramètres positionnels, dans le paramètre auquel les noms ne sont pas nécessaires, utilisez la syntaxe de tableau.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To provide parameter name and value pairs, use the hash table syntax.</source>
          <target state="translated">Pour fournir des paires nom / valeur de paramètre, utilisez la syntaxe de table de hachage.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The splatted value can appear anywhere in the parameter list.</source>
          <target state="translated">La valeur splatted peut apparaître n’importe où dans la liste de paramètres.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>When splatting, you do not need to use a hash table or an array to pass all parameters.</source>
          <target state="translated">Lorsque l’opérateur de splatting, il est inutile d’utiliser une table de hachage ou un tableau pour transmettre tous les paramètres.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You may pass some parameters by using splatting and pass others by position or by parameter name.</source>
          <target state="translated">Vous pouvez passer des paramètres en utilisant l’opérateur de splatting et d’autres passer par position ou par nom de paramètre.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Also, you can splat multiple objects in a single command just so you pass no more than one value for each parameter.</source>
          <target state="translated">Vous pouvez également splat plusieurs objets dans une seule commande juste pour que vous transmettez pas plus d’une valeur pour chaque paramètre.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH HASH TABLES</source>
          <target state="translated">OPÉRATEUR DE SPLATTING AVEC DES TABLES DE HACHAGE</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use a hash table to splat parameter name and value pairs.</source>
          <target state="translated">Utilisez une table de hachage de paires nom / valeur du paramètre splat.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can use this format for all parameter types, including positional and named parameters and switch parameters.</source>
          <target state="translated">Vous pouvez utiliser ce format pour tous les types de paramètre, y compris les paramètres nommés et positionnels et passer des paramètres.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">Les exemples suivants comparent deux commandes Copy-Item qui copie le fichier Test.txt dans le fichier Test2.txt dans le même répertoire.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are included.</source>
          <target state="translated">Le premier exemple utilise le format classique avec le paramètre nom est inclus.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Copy-Item -Path "test.txt" -Destination "test2.txt" -WhatIf</source>
          <target state="translated">Copy-Item - chemin d’accès « test.txt »-« test2.txt » - WhatIf de Destination</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The second example uses hash table splatting.</source>
          <target state="translated">Le deuxième exemple utilise l’opérateur de splatting table hachage.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter-name and parameter-value pairs and stores it in the $HashArguments variable.</source>
          <target state="translated">La première commande crée une table de hachage du nom de paramètre et la valeur du paramètre paires et le stocke dans la variable $HashArguments.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The second command uses the $HashArguments variable in a command with splatting.</source>
          <target state="translated">La deuxième commande utilise la variable $HashArguments dans une commande avec l’opérateur de splatting.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The At symbol (@HashArguments) replaces the dollar sign ($HashArguments) in the command.</source>
          <target state="translated">Le symbole At (@HashArguments) remplace le signe dollar ($HashArguments) dans la commande.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To provide a value for the WhatIf switch parameter, use $True or $False.</source>
          <target state="translated">Pour fournir une valeur pour le paramètre WhatIf, utilisez $True ou $False.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$HashArguments = @{ Path = "test.txt"; Destination = "test2.txt"; WhatIf = $true } PS C:&gt;Copy-Item @HashArguments</source>
          <target state="translated">C: &gt; $HashArguments = @{chemin d’accès = « test.txt » ; Destination = « test2.txt » ; WhatIf = $true} PS C: &gt; Copy-Item @HashArguments</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note: In the first command, the At symbol (@) indicates a hash table, not a splatted value.</source>
          <target state="translated">Remarque : dans la première commande, le symbole At (@) indique une table de hachage, pas une valeur splatted.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The syntax for hash tables in Windows PowerShell is: @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>; …}</source>
          <target state="translated">La syntaxe pour les tables de hachage dans Windows PowerShell est : @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>;...}</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH ARRAYS</source>
          <target state="translated">OPÉRATEUR DE SPLATTING AVEC DES TABLEAUX</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Use an array to splat values for positional parameters, which do not require parameter names.</source>
          <target state="translated">Utilisez un tableau de valeurs de splat pour les paramètres positionnels, qui ne nécessitent pas de noms de paramètre.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The values must be in position-number order in the array.</source>
          <target state="translated">Les valeurs doivent être dans l’ordre des numéros de position dans le tableau.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">Les exemples suivants comparent deux commandes Copy-Item qui copie le fichier Test.txt dans le fichier Test2.txt dans le même répertoire.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are omitted.</source>
          <target state="translated">Le premier exemple utilise le format classique dans lequel les noms de paramètres sont omis.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The parameter values appear in position order in the command.</source>
          <target state="translated">Les valeurs de paramètre s’affichent dans l’ordre de position dans la commande.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Copy-Item "test.txt" "test2.txt" -WhatIf</source>
          <target state="translated">« Test.txt » « test2.txt » - WhatIf Copy-Item</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The second example uses array splatting.</source>
          <target state="translated">Le deuxième exemple utilise l’opérateur de splatting de tableau.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The first command creates an array of the parameter values and stores it in the $ArrayArguments variable.</source>
          <target state="translated">La première commande crée un tableau des valeurs de paramètre et le stocke dans la variable $ArrayArguments.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The values are in position order in the array.</source>
          <target state="translated">Les valeurs sont dans l’ordre de position dans le tableau.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The second command uses the $ArrayArguments variable in a command in splatting.</source>
          <target state="translated">La deuxième commande utilise la variable $ArrayArguments dans une commande de l’opérateur de splatting.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The At symbol (@ArrayArguments) replaces the dollar sign ($ArrayArguments) in the command.</source>
          <target state="translated">Le symbole At (@ArrayArguments) remplace le signe dollar ($ArrayArguments) dans la commande.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$ArrayArguments = "test.txt", "test2.txt" PS C:&gt;Copy-Item @ArrayArguments -WhatIf</source>
          <target state="translated">C: &gt; $ArrayArguments = « test.txt », « test2.txt « PS C: &gt; @ArrayArguments Copy-Item - WhatIf</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">EXEMPLES</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This example shows how to re-use splatted values in different commands.</source>
          <target state="translated">Cet exemple montre comment réutiliser les valeurs splatted dans les différentes commandes.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The commands in this example use the Write-Host cmdlet to write messages to the host program console.</source>
          <target state="translated">Les commandes de cet exemple montre comment utilisent l’applet de commande Write-Host pour écrire des messages dans la console du programme hôte.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It uses splatting to specify the foreground and background colors.</source>
          <target state="translated">Elle utilise l’opérateur de splatting pour spécifier les couleurs de premier plan et d’arrière-plan.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To change the colors of all commands, just change the value of the $Colors variable.</source>
          <target state="translated">Pour modifier les couleurs de toutes les commandes, simplement modifier la valeur de la variable $Colors.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter names and values and stores the hash table in the $Colors variable.</source>
          <target state="translated">La première commande crée une table de hachage des noms de paramètre et les valeurs et stocke la table de hachage dans la variable $Colors.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>$Colors = @{ForegroundColor = "black" BackgroundColor = "white"}</source>
          <target state="translated">$Colors = @{ForegroundColor = « noir » BackgroundColor = « white »}</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The second and third commands use the $Colors variable for splatting in a Write-Host command.</source>
          <target state="translated">Les deuxième et troisième commandes utilisent la variable $Colors pour l’opérateur de splatting dans une commande Write-Host.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To use the $Colors variable, replace the dollar sign ($Colors) with an At symbol (@Colors).</source>
          <target state="translated">Pour utiliser la variable $Colors, remplacez le symbole dollar ($Colors) avec un symbole At (@Colors).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Write a message with the colors in $Colors Write-Host "This is a test."</source>
          <target state="translated">Écrire un message avec les couleurs dans $Colors Write-Host « Ceci est un test ».</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>@Colors</source>
          <target state="translated">@Colors</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Write second message with same colors.</source>
          <target state="translated">Écrire le deuxième message avec les mêmes couleurs.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The position of splatted hash table does not matter.</source>
          <target state="translated">La position de la table de hachage splatted n’a pas d’importance.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Write-Host @Colors "This is another test."</source>
          <target state="translated">Write-Host @Colors « Ceci est un autre test ».</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This example shows how to forward their parameters to other commands by using splatting and the $PSBoundParameters automatic variable.</source>
          <target state="translated">Cet exemple montre comment transférer les paramètres vers d’autres commandes en utilisant l’opérateur de splatting et de la variable automatique $PSBoundParameters.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The $PSBoundParameters automatic variable is a dictionary (System.Collections.Generic.Dictionary) that contains all of the parameter names and values that are used when a script or function is run.</source>
          <target state="translated">La variable automatique $PSBoundParameters est un dictionnaire qui contient tous les noms de paramètres et les valeurs qui sont utilisées lors de l’exécution d’un script ou une fonction (System.Collections.Generic.Dictionary).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the following example, we use the $PSBoundParameters variable to forward the parameters values passed to a script or function from Test2 function to the Test1 function.</source>
          <target state="translated">Dans l’exemple suivant, nous utilisons le $PSBoundParameters variable pour transmettre les valeurs des paramètres passés à un script ou une fonction à partir de la fonction Test2 à la fonction Test1.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Both calls to the Test1 function from Test2 use splatting.</source>
          <target state="translated">Les deux appels à la fonction Test1 de Test2 utilisent l’opérateur de splatting.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>function Test1 { param($a, $b, $c)</source>
          <target state="translated">fonction Test1 {param ($a $b, $c)</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>$a $b $c }</source>
          <target state="translated">$a $b $c}</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>function Test2 { param($a, $b, $c)</source>
          <target state="translated">fonction Test2 {param ($a $b, $c)</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $a, $b, and $c.</source>
          <target state="translated">Appelez la fonction $a $b, Test1 et $c.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Test1 @PsBoundParameters</source>
          <target state="translated">Test1 @PsBoundParameters</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $b and $c, but not with $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") | Out-Null Test1 @LimitedParameters }</source>
          <target state="translated">Appelez la fonction Test1 $b et $c, mais pas avec $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") | Out-Null Test1 @LimitedParameters}</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Test2 -a 1 -b 2 -c 3</source>
          <target state="translated">C: &gt; Test2 - a 1 -b - c 2 3</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>SPLATTING COMMAND PARAMETERS</source>
          <target state="translated">OPÉRATEUR DE SPLATTING DES PARAMÈTRES DE COMMANDE</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use splatting to represent the parameters of a command.</source>
          <target state="translated">Vous pouvez utiliser l’opérateur de splatting pour représenter les paramètres d’une commande.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This technique is useful when you are creating a proxy function, that is, a function that calls another command.</source>
          <target state="translated">Cette technique est utile lorsque vous créez une fonction de proxy, autrement dit, une fonction qui appelle une autre commande.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This feature is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">Cette fonctionnalité est introduite dans Windows PowerShell 3.0.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To splat the parameters of a command, use @Args to represent the command parameters.</source>
          <target state="translated">Pour splat les paramètres d’une commande, utilisez @Args pour représenter les paramètres de commande.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This technique is easier than enumerating command parameters and it works without revision even if the parameters of the called command change.</source>
          <target state="translated">Cette technique est plus facile que l’énumération des paramètres de commande et il fonctionne sans révision même si les paramètres de la commande appelée changent.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The feature uses the $Args automatic variable, which contains all unassigned parameter values.</source>
          <target state="translated">La fonction utilise la variable automatique $Args, qui contient toutes les valeurs de paramètre non attribué.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, the following function calls the Get-Process cmdlet.</source>
          <target state="translated">Par exemple, la fonction suivante appelle l’applet de commande Get-Process.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In this function, @Args represents all of the parameters of the Get-Process cmdlet.</source>
          <target state="translated">Dans cette fonction, @Args représente tous les paramètres de l’applet de commande Get-Process.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>function Get-MyProcess { Get-Process @Args }</source>
          <target state="translated">fonction Get-MyProcess {Get-Process @Args}</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you use the Get-MyProcess function, all unassigned parameters and parameter values are passed to @Args, as shown in the following commands.</source>
          <target state="translated">Lorsque vous utilisez la fonction Get-MyProcess, tous les paramètres non attribués et les valeurs de paramètres sont transmis à @Args, comme indiqué dans les commandes suivantes.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell</source>
          <target state="translated">C: &gt; Get-MyProcess-nom de PowerShell</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">Gère les VM (m) Id d’UC ProcessName de npm (k) PM (k) WS (k)</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>463      46   225484     237196   719    15.86   3228 powershell</source>
          <target state="translated">463 46 225484 237196 719 15.86 3228 powershell</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell_Ise -FileVersionInfo</source>
          <target state="translated">C: &gt; Get-MyProcess-nom - FileVersionInfo PowerShell_Ise</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>ProductVersion   FileVersion      FileName</source>
          <target state="translated">Nom de fichier ProductVersion FileVersion</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>6.2.9200.16384   6.2.9200.1638... C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</source>
          <target state="translated">6.2.9200.16384   6.2.9200.1638... C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You can use @Args in a function that has explicitly declared parameters.</source>
          <target state="translated">Vous pouvez utiliser @Args dans une fonction qui a déclaré explicitement les paramètres.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can use it more than once in a function, but all parameters that you enter are passed to all instances of @Args, as shown in the following example.</source>
          <target state="translated">Vous pouvez l’utiliser plusieurs fois dans une fonction, mais tous les paramètres que vous entrez sont transmis à toutes les instances de @Args, comme indiqué dans l’exemple suivant.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>function Get-MyCommand { Param ([switch]$P, [switch]$C) if ($P) { Get-Process @Args } if ($C) { Get-Command @Args } }</source>
          <target state="translated">fonction Get-MyCommand {Param ([commutateur] $P, [commutateur] $C) si ($P) {Get-Process @Args} si ($C) {Get-Command @Args}}</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyCommand -P -C -Name PowerShell</source>
          <target state="translated">C: &gt; Get-MyCommand - P -C-nom de PowerShell</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">Gère les VM (m) Id d’UC ProcessName de npm (k) PM (k) WS (k)</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>408      28    75568      83176   620     1.33   1692 powershell</source>
          <target state="translated">408 28 75568 83176 620 1,33 1692 powershell</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Path               : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Extension          : .exe Definition         : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Visibility         : Public OutputType         : {System.String} Name               : powershell.exe CommandType        : Application ModuleName         : Module             : RemotingCapability : PowerShell Parameters         : ParameterSets      : HelpUri            : FileVersionInfo    : File:             C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</source>
          <target state="translated">Chemin d’accès : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Extension : .exe définition : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe visibilité : OutputType Public : {System.String} nom : powershell.exe CommandType : Application ModuleName : Module : RemotingCapability : les paramètres PowerShell : ParameterSets : HelpUri : FileVersionInfo : fichier : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">VOIR AUSSI</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>about_Arrays about_Automatic_Variables about_Hash_Tables about_Parameters</source>
          <target state="translated">about_Arrays about_Automatic_Variables about_Hash_Tables about_Parameters</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>