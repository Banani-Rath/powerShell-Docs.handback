<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67fc0a1ae3bba1fed7ba846dd601774ee8268276</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Break.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">96ef8ce26be1424de16362503a74c06e22eefffe</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa0dba048828eed5dd6a6486a27d382a58d84af6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Break</source>
          <target state="translated">有关中断</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>TOPIC</source>
          <target state="translated">TOPIC</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">简短说明</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Describes a statement you can use to immediately exit Foreach, For, While, Do, or Switch statements.</source>
          <target state="translated">介绍可用于立即退出 Foreach 中，对于，一个语句，或切换语句时。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">详细说明</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When a Break statement appears in a loop, such as a Foreach, For, Switch, or While loop, the Break statement causes Windows PowerShell to immediately exit the loop.</source>
          <target state="translated">Break 语句将出现在循环中，如 Foreach，交换机，或虽然循环，Break 语句将导致 Windows PowerShell 立即退出循环时。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In a Switch construct that does not loop, Break causes Windows PowerShell to exit the Switch code block.</source>
          <target state="translated">在开关构造，它不会循环中断原因 Windows PowerShell 退出 Switch 代码块。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label that lets you exit embedded loops.</source>
          <target state="translated">Break 语句可以包含一个标签，您可以退出嵌入的循环。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A label can specify any loop keyword, such as Foreach, For, or While, in a script.</source>
          <target state="translated">标签可指定任何循环关键字，如 Foreach 中，对于，或 While、 在脚本中。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When you use a label, Break exits the specified loop.</source>
          <target state="translated">当您使用一个标签时，Break 将退出指定的循环。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Break exits the specified loop, regardless of which loop the Break statement is in.</source>
          <target state="translated">Break 将退出的循环中 Break 语句都是该指定的循环。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following example shows how to use a Break statement to exit a For statement:</source>
          <target state="translated">下面的示例演示如何使用 Break 语句退出 For 语句︰</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>for($i=1; $i -le 10; $i++) { Write-Host $i break }</source>
          <target state="translated">对于 ($i = 1; $i-le 10; $i + +) {Write-host $i 中断}</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In this example, the Break statement exits the For loop when the $i variable equals 1.</source>
          <target state="translated">在此示例中，Break 语句退出 For 循环，当 $i 变量等于 1。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Even though the For statement evaluates to True until $i is greater than 10, Windows PowerShell reaches the break statement the first time the For loop is run.</source>
          <target state="translated">即使 For 语句的计算结果为 True，直到 $i 大于 10，Windows PowerShell 达到运行 For 循环的 break 语句第一个时间。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It is more common to use the Break statement in a loop where an inner condition must be met.</source>
          <target state="translated">它是更常见的是，必须满足内部条件在循环中使用 Break 语句。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Consider the following Foreach statement example:</source>
          <target state="translated">请考虑以下 Foreach 语句示例︰</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>$i=0 $varB = 10,20,30,40 foreach ($val in $varB) { $i++ if ($val -eq 30) { break } } Write-Host "30 was found in array position $i"</source>
          <target state="translated">$i = 0 $varB = 10,20,30,40 foreach ($val 中 $varB) {$i + + 如果 ($val-eq 30) {中断}} Write-host"30 找数组位置 $i"</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach statement iterates the $varB array.</source>
          <target state="translated">在此示例中，Foreach 语句循环访问 $varB 数组。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Each time the code block is run, the $i variable is incremented by 1.</source>
          <target state="translated">每次运行代码块，$i 变量增加 1。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The If statement evaluates to False the first two times the loop is run.</source>
          <target state="translated">如果为 False 运行两次循环的第一个语句计算。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The third time the loop is run, $i equals 3, and the $val variable equals 30.</source>
          <target state="translated">第三次运行循环时，$i 等于 3，并且 $val 变量等于 30。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>At this point, the Break statement runs, and the Foreach loop exits.</source>
          <target state="translated">此时，Break 语句在运行时和 Foreach 循环退出。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You break out of the other looping statements in the same way you break out of the Foreach loop.</source>
          <target state="translated">您中断其他循环语句与打破 Foreach 循环相同的方式。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In the following example, the Break statement exits a While statement when a DivideByZeroException exception is trapped using the Trap statement.</source>
          <target state="translated">在下面的示例中，Break 语句退出 While 语句时使用该 Trap 语句捕获 DivideByZeroException 异常。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>$i = 3 while ($true) { trap [DivideByZeroException] { Write-Host "divide by zero trapped" break } 1 / $i-- }</source>
          <target state="translated">$i = 3 时 ($true) {捕获 [DivideByZeroException] {Write-host"除数为零捕获"中断} 1 / $i}</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label.</source>
          <target state="translated">Break 语句可以包含一个标签。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If you use the Break keyword with a label, Windows PowerShell exits the labeled loop instead of exiting the current loop.</source>
          <target state="translated">如果使用带有标签的 Break 关键字，Windows PowerShell 将退出而不是退出当前循环标签的循环。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The syntax for a label is as follows (this example shows a label in a While loop):</source>
          <target state="translated">标签的语法，如下所示是 (此示例演示一个标签在 While 循环):</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>:myLabel while (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</source>
          <target state="translated">︰ 同时 myLabel (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The label is a colon followed by a name that you assign.</source>
          <target state="translated">将为您分配一个名称后跟一个冒号。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The label must be the first token in a statement, and it must be followed by the looping keyword, such as While.</source>
          <target state="translated">标签必须是一个语句中的第一个标记，并且它后面必须是循环的关键字，如时。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, only loop keywords, such as Foreach, For, and While can have a label.</source>
          <target state="translated">在 Windows PowerShell 中，仅循环关键字，例如，Foreach，，For 和 While 可以有标签。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Break moves execution out of the labeled loop.</source>
          <target state="translated">分页符将移出标记循环的执行。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In embedded loops, this has a different result than the Break keyword has when it is used by itself.</source>
          <target state="translated">在嵌入的循环，这都有不同的结果比关键字具有单独使用时的断点。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This schematic example has a While statement with a For statement:</source>
          <target state="translated">一段时间，但具有示意示例使用 For 语句的语句︰</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>:myLabel while (&lt;condition 1&gt;) { for ($item in $items) { if (&lt;condition 2&gt;) { break myLabel } $item = $x   # A statement inside the For-loop } } $a = $c  # A statement after the labeled While-loop</source>
          <target state="translated">: myLabel while （&lt; 条件 1 &gt;） {($item $items 中) 为 {如果 （&lt; 条件 2 &gt;） {中断 myLabel} $item = $x For 循环内的 # A 语句}} $ = $c 后带标签的 While 循环的 # A 语句</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If condition 2 evaluates to True, the execution of the script skips down to the statement after the labeled loop.</source>
          <target state="translated">如果条件 2 的计算结果为 True，在脚本的执行跳至标签的循环后的语句。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the example, execution starts again with the statement "$a = $c".</source>
          <target state="translated">在示例中，执行重新启动与语句"$ = $c"。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can nest many labeled loops, as shown in the following schematic example.</source>
          <target state="translated">下面的示意图示例中所示，您可以嵌套许多标记为的循环。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>:red while (<ph id="ph1">&lt;condition1&gt;</ph>) { :yellow while (<ph id="ph2">&lt;condition2&gt;</ph>) { while (<ph id="ph3">&lt;condition3&gt;</ph>) { if ($a) {break} if ($b) {break red} if ($c) {break yellow} } After innermost loop } After "yellow" loop } After "red" loop</source>
          <target state="translated">︰ 红色时 (<ph id="ph1">&lt;condition1&gt;</ph>) {: 黄色时 (<ph id="ph2">&lt;condition2&gt;</ph>) {时 (<ph id="ph3">&lt;condition3&gt;</ph>) {如果 ($) {中断} 如果 ($b) {中断红色} 如果 ($c) {中断黄色}} 之后最里面的循环}"黄色"循环之后}"红色"的循环之后</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If the $b variable evaluates to True, execution of the script resumes after the loop that is labeled "red".</source>
          <target state="translated">如果 $b 变量的计算结果为 True，将在标记为"红色"的循环后恢复执行脚本。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the $c variable evaluates to True, execution of the script control resumes after the loop that is labeled "yellow".</source>
          <target state="translated">如果 $c 变量的计算结果为 True，将在标记为"黄色"循环后恢复执行的脚本控件。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If the $a variable evaluates to True, execution resumes after the innermost loop.</source>
          <target state="translated">如果 $ 变量的计算结果为 True，则将在最里面的循环后恢复执行。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>No label is needed.</source>
          <target state="translated">需要无标签。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Windows PowerShell does not limit how far labels can resume execution.</source>
          <target state="translated">Windows PowerShell 不限制多久标签可以继续执行。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The label can even pass control across script and function call boundaries.</source>
          <target state="translated">标签可以甚至将控制传递跨脚本和函数调用边界。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The Break keyword is used to leave the Switch construct.</source>
          <target state="translated">Break 关键字用于将交换机构造。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, the following Switch statement uses Break statements to test for the most specific condition:</source>
          <target state="translated">例如，下面的 Switch 语句使用 Break 语句来测试最具体的条件︰</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>$var = "word2" switch -regex ($var) { "word2" { Write-Host "Exact" $_ break }</source>
          <target state="translated">$var ="word2"开关的正则表达式 ($var) {"word2"{Write-host"Exact"$_ 中断}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>"word.*" { Write-Host "Match on the prefix" $_ break }</source>
          <target state="translated">"word.*"{Write-host"前缀匹配"$_ 中断}</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>"w.*" { Write-Host "Match on at least the first letter" $_ break }</source>
          <target state="translated">"w.*"{Write-host"至少的第一个字母匹配"$_ 中断}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>default { Write-Host "No match" $_ break } }</source>
          <target state="translated">默认值 {Write-host"不匹配"$_ 中断}}</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In this example, the $var variable is created and initialized to a string value of "word2".</source>
          <target state="translated">在此示例中，$var 变量创建并初始化为"word2"的字符串值。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The Switch statement uses the Regex class to match the variable value first with the term "word2".</source>
          <target state="translated">Switch 语句使用正则表达式类用术语"word2"首先匹配变量的值。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>(The Regex class is a regular expression Microsoft .NET Framework class.) Because the variable value and the first test in the Switch statement match, the first code block in the Switch statement runs.</source>
          <target state="translated">（正则表达式类是正则表达式的 Microsoft.NET Framework 类。）因为变量值和 Switch 语句匹配项中的第一个测试，第一个代码块中运行 Switch 语句。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When Windows PowerShell reaches the first Break statement, the Switch statement exits.</source>
          <target state="translated">当 Windows PowerShell 达到第一个 Break 语句时，Switch 语句将退出。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If the four Break statements are removed from the example, all four conditions are met.</source>
          <target state="translated">如果示例中删除四个 Break 语句，则符合所有四个条件。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This example uses the break statement to display results when the most specific condition is met.</source>
          <target state="translated">此示例中使用 break 语句以满足最具体的条件时显示结果。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>about_Comparison_Operators about_Continue about_For about_Foreach about_Switch about_Throw about_Trap about_Try_Catch_Finally about_While</source>
          <target state="translated">about_Comparison_Operators about_Continue about_For about_Foreach about_Switch about_Throw about_Trap about_Try_Catch_Finally about_While</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>