<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-cn">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">651533c5450dcc0f88b4ff26eddb57d2bc4223a3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_WQL.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6d782ebf4ac7990d28c26df759e74af3c63221a4</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3db30d43b3e70cf5b7eb3abff7fdb721e43fa9b9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_WQL</source>
          <target state="translated">about_WQL</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About WQL</source>
          <target state="translated">有关 WQL</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_WQL</source>
          <target state="translated">about_WQL</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_WQL</source>
          <target state="translated">about_WQL</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">简短说明</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes WMI Query Language (WQL), which can be used to get WMI objects in Windows PowerShell.</source>
          <target state="translated">介绍可用于获取 Windows PowerShell 中的 WMI 对象的 WMI 查询语言 (WQL)。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">详细说明</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>WQL is the Windows Management Instrumentation (WMI) query language, which is the language used to get information from WMI.</source>
          <target state="translated">WQL 是 Windows Management Instrumentation (WMI) 查询语言，它是用于从 WMI 获取信息的语言。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You are not required to use WQL to perform a WMI query in Windows PowerShell.</source>
          <target state="translated">您不需要使用 WQL 在 Windows PowerShell 中执行 WMI 查询。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Instead, you can use the parameters of the Get-WmiObject or Get-CimInstance cmdlets.</source>
          <target state="translated">相反，您可以使用 Get-wmiobject 或 Get-ciminstance cmdlet 的参数。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>WQL queries are somewhat faster than standard Get-WmiObject commands and the improved performance is evident when the commands run on hundreds of systems.</source>
          <target state="translated">WQL 查询要比标准 Get-wmiobject 命令有点快并提高的性能时，可以明显在数百个系统上运行的命令。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>However, be sure that the time you spend to write a successful WQL query doesn't outweigh the performance improvement.</source>
          <target state="translated">但是，请确保您要编写一个成功的 WQL 查询所花费的时间不超过对性能的改进。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The basic WQL statements you need to use WQL are Select, Where, and From.</source>
          <target state="translated">您需要使用 WQL 的基本 WQL 语句为 Select、 Where、 和从。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>WHEN TO USE WQL</source>
          <target state="translated">何时使用 WQL</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>When working with WMI, and especially with WQL, do not forget that you are also using Windows PowerShell.</source>
          <target state="translated">在使用通过 WMI，，尤其是使用 WQL 时，不要忘记你还使用 Windows PowerShell。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Often, if a WQL query does not work as expected, it's easier to use a standard Windows PowerShell command than to debug the WQL query.</source>
          <target state="translated">通常，如果 WQL 查询不会按预期方式工作，是更轻松地使用标准 Windows PowerShell 命令比调试 WQL 查询。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Unless you are returning massive amounts of data from across bandwidth-constrained remote systems, it is rarely productive to spend hours trying to perfect a complicated and convoluted WQL query when there is a perfectly acceptable Windows cmdlet that does the same thing, if a bit more slowly.</source>
          <target state="translated">除非您在返回的大量数据从跨多个带宽受限的远程系统，很少提高工作效率要花费数小时尝试在没有完全可以接受 Windows cmdlet 执行相同的事情，如果一个位速度更慢时才完美复杂而又费解的 WQL 查询。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>USING THE SELECT STATEMENT</source>
          <target state="translated">使用 SELECT 语句</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A typical WMI query begins with a Select statement that gets all properties or particular properties of a WMI class.</source>
          <target state="translated">典型的 WMI 查询以获取所有属性或 WMI 类的特定属性的 Select 语句开始。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>To select all properties of a WMI class, use an asterisk (*).</source>
          <target state="translated">若要选择 WMI 类的所有属性，使用星号 （*）。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The From keyword specifies the WMI class.</source>
          <target state="translated">From 关键字指定 WMI 类。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A Select statement has the following format:</source>
          <target state="translated">Select 语句具有以下格式︰</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Select <ph id="ph1">&lt;property&gt;</ph> from &lt;WMI-class&gt;</source>
          <target state="translated">选择 <ph id="ph1">&lt;property&gt;</ph> 从 &lt; WMI 类 &gt;</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For example, the following Select statement selects all properties (*) from the instances of the Win32_Bios WMI class.</source>
          <target state="translated">例如，以下 Select 语句选择所有属性 （*） 从 Win32_Bios WMI 类的实例。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Select * from Win32_Bios</source>
          <target state="translated">选择 * Win32_Bios 从</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To select a particular property of a WMI class, place the property name between the Select and From keywords.</source>
          <target state="translated">若要选择 WMI 类的特定属性，将属性名称以及从关键字之间选择。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following query selects only the name of the BIOS from the Win32_Bios WMI class.</source>
          <target state="translated">下面的查询选择 Win32_Bios WMI 类中只有 BIOS 的名称。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The command saves the query in the $queryName variable.</source>
          <target state="translated">该命令将查询保存在 $queryName 变量中。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Select Name from Win32_Bios</source>
          <target state="translated">Win32_Bios 从选择的名称</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To select more than one property, use commas to separate the property names.</source>
          <target state="translated">若要选择多个属性，请使用逗号来分隔属性名称。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following WMI query selects the name and the version of the Win32_Bios WMI class.</source>
          <target state="translated">下面的 WMI 查询选择的名称和 Win32_Bios WMI 类的版本。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The command saves the query in the $queryNameVersion variable.</source>
          <target state="translated">该命令将查询保存在 $queryNameVersion 变量中。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Select name, version from Win32_Bios</source>
          <target state="translated">选择名称和从 Win32_Bios 版本</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>USING THE WQL QUERY</source>
          <target state="translated">使用 WQL 查询</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>There are two ways to use WQL query in Windows PowerShell command.</source>
          <target state="translated">有两种方式在 Windows PowerShell 命令中使用的 WQL 查询。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>-- Use the Get-WmiObject cmdlet -- Use the Get-CimInstance cmdlet -- Use the [wmisearcher] type accelerator.</source>
          <target state="translated">-使用 Get-wmiobject cmdlet — 使用 Get CimInstance cmdlet — 使用 [wmisearcher] 类型快捷键。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>USING THE GET-WMIOBJECT CMDLET</source>
          <target state="translated">使用 GET-WMIOBJECT CMDLET</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The most basic way to use the WQL query is to enclose it in quotation marks (as a string) and then use the query string as the value of the Query parameter of the Get-WmiObject cmdlet, as shown in the following example.</source>
          <target state="translated">若要使用的 WQL 查询的最基本方法是将其括在引号中 （以字符串形式） 并将查询字符串作为 Get-wmiobject cmdlet 查询参数的值在下面的示例所示。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Query "Select * from Win32_Bios"</source>
          <target state="translated">PS c: &gt; Get-wmiobject-查询"选择 * 从 Win32_Bios"</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW (1.36) 制造商︰ 联想名称︰ 默认系统 BIOS 序列号︰ R9FPY3P 版本︰ 联想 – 1360年</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can also save the WQL statement in a variable and then use the variable as the value of the Query parameter, as shown in the following command.</source>
          <target state="translated">可以还将 WQL 语句保存在变量中，然后作为查询参数的值使用变量，如下面的命令中所示。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $query = "Select * from Win32_Bios" PS C:&gt; Get-WmiObject –Query $query</source>
          <target state="translated">PS $query c: &gt; ="选择 * 从 Win32_Bios"PS c: &gt; Get-wmiobject – 查询 $query</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can use either format with any WQL statement.</source>
          <target state="translated">可以在任何 WQL 语句中使用这两种格式。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The following command uses the query in the $queryName variable to get only the name and version properties of the system BIOS.</source>
          <target state="translated">下面的命令使用 $queryName 变量中的查询来获取仅系统 BIOS 的名称和版本属性。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $queryNameVersion = "Select Name, Version from Win32_Bios" PS C:&gt; Get-WmiObject -Query $queryNameVersion</source>
          <target state="translated">PS $queryNameVersion c: &gt; ="选择名称和版本从 Win32_Bios"PS c: &gt; Get-wmiobject-查询 $queryNameVersion</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS Version          : LENOVO - 1360</source>
          <target state="translated">名称︰ 默认系统 BIOS 版本︰ 联想-1360年</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Remember that you can use the parameters of the Get-WmiObject cmdlet to get the same result.</source>
          <target state="translated">请记住，您可以使用 Get-wmiobject cmdlet 的参数来获得相同的结果。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For example, the following command also gets the values of the Name and Version properties of instances of the Win32_Bios WMI class.</source>
          <target state="translated">例如，以下命令还将获取 Win32_Bios WMI 类的实例的名称和版本属性的值。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject –Class Win32_Bios -Property Name, Version</source>
          <target state="translated">PS c: &gt; Get-wmiobject – Win32_Bios 类的属性名称、 版本</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS Version          : LENOVO - 1360</source>
          <target state="translated">名称︰ 默认系统 BIOS 版本︰ 联想-1360年</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>USING THE GET-CIMINSTANCE CMDLET</source>
          <target state="translated">使用 GET CIMINSTANCE CMDLET</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, you can use the Get-CimInstance cmdlet to run WQL queries.</source>
          <target state="translated">从 Windows PowerShell 3.0 开始，您可以使用 Get CimInstance cmdlet 运行 WQL 查询。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Get-CimInstance gets instances of CIM-compliant classes, including WMI classes.</source>
          <target state="translated">Get CimInstance 获取符合 CIM 标准的类，其中包括 WMI 类的实例。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The CIM cmdlets, introduced Windows PowerShell 3.0, perform the same tasks as the WMI cmdlets.</source>
          <target state="translated">CIM cmdlet 中，引入了 Windows PowerShell 3.0 中，执行与 WMI cmdlet 相同的任务。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The CIM cmdlets comply with WS-Management (WSMan) standards and with the Common Information Model (CIM) standard, which enables the cmdlets to use the same techniques to manage Windows computers and computers that are running other operating systems.</source>
          <target state="translated">CIM cmdlet 符合 Ws-management (WSMan) 标准与使用通用信息模型 (CIM) 标准，从而使得这些 cmdlet 以使用相同技术来管理 Windows 计算机和正在运行其他操作系统的计算机。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The following command uses the Get-CimInstance cmdlet to run a WQL query.</source>
          <target state="translated">下面的命令使用 Get-ciminstance cmdlet 运行的 WQL 查询。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Any WQL query that can be used with Get-WmiObject can also be used with Get-CimInstance.</source>
          <target state="translated">此外可以与 Get-ciminstance 使用任何可与 Get-wmiobject 一起使用的 WQL 查询。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-CimInstance -Query "Select * from Win32_Bios"</source>
          <target state="translated">PS c: &gt; Get-ciminstance-查询"选择 * 从 Win32_Bios"</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW (1.36) 制造商︰ 联想名称︰ 默认系统 BIOS 序列号︰ R9FPY3P 版本︰ 联想 – 1360年</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Get-CimInstance returns a CimInstance object, instead of the ManagementObject that Get-WmiObject returns, but the objects are quite similar.</source>
          <target state="translated">Get-ciminstance 返回 CimInstance 对象，而不是 ManagementObject 该 Get-wmiobject 返回时，但这些对象是非常相似。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>PS C:&gt;(Get-CimInstance -Query "Select <bpt id="p1">*</bpt> from Win32_Bios").GetType().FullName Microsoft.Management.Infrastructure.CimInstance PS C:&gt;(Get-WmiObject -Query "Select <ept id="p1">*</ept> from Win32_Bios").GetType().FullName System.Management.ManagementObject</source>
          <target state="translated">PS c: &gt; (Get-ciminstance-查询"Select <bpt id="p1">*</bpt> 从 Win32_Bios")。GetType()。FullName Microsoft.Management.Infrastructure.CimInstance PS c: &gt; (Get-wmiobject-查询"Select <ept id="p1">*</ept> 从 Win32_Bios")。GetType()。FullName System.Management.ManagementObject</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>USING THE [wmisearcher] TYPE ACCELERATOR</source>
          <target state="translated">使用 [wmisearcher] 类型快捷键</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The [wmisearcher] type accelerator creates a ManagementObjectSearcher object from a WQL statement string.</source>
          <target state="translated">[Wmisearcher] 类型快捷键从 WQL 语句字符串创建 ManagementObjectSearcher 对象。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The ManagementObjectSearcher object has many properties and methods, but the most basic method is the Get method, which invokes the specified WMI query and returns the resulting objects.</source>
          <target state="translated">ManagementObjectSearcher 对象具有很多属性和方法，但最基本的方法是 Get 方法，它会调用指定的 WMI 查询并返回所得到的对象。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>By using the [wmisearcher], you gain easy access to the ManagementObjectSearcher .NET Framework class.</source>
          <target state="translated">通过使用 [wmisearcher]，可以轻松访问 ManagementObjectSearcher.NET Framework 类。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This lets you query WMI and to configure the way the query is conducted.</source>
          <target state="translated">这样就可以在 WMI 中查询和可配置的方式查询执行。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>To use the [wmisearcher] type accelerator:</source>
          <target state="translated">若要使用 [wmisearcher] 类型快捷键︰</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Cast the  WQL string into a ManagementObjectSearcher object.</source>
          <target state="translated">WQL 字符串转换为 ManagementObjectSearcher 对象。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Call the Get method of the ManagementObjectSearcher object.</source>
          <target state="translated">调用 ManagementObjectSearcher 对象的 Get 方法。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, the following command casts the "select all" query, saves the result in the $bios variable, and then calls the Get method of the ManagementObjectSearcher object in the $bios variable.</source>
          <target state="translated">例如，以下命令将强制转换"全选"查询、 将结果保存在 $bios 变量中，然后调用 $bios 变量中的 ManagementObjectSearcher 对象的 Get 方法。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $bios = [wmisearcher]"Select * from Win32_Bios" PS C:&gt; $bios.Get()</source>
          <target state="translated">PS $bios c: &gt; = [wmisearcher]"中选择 * 从 Win32_Bios"c: &gt; $bios PS。Get()</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW (1.36) 制造商︰ 联想名称︰ 默认系统 BIOS 序列号︰ R9FPY3P 版本︰ 联想 – 1360年</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>NOTE: Only selected object properties are displayed by default.</source>
          <target state="translated">注意︰ 默认情况下，将显示仅所选的对象属性。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>These properties are defined in the Types.ps1xml file.</source>
          <target state="translated">这些属性是在 Types.ps1xml 文件中定义的。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can use the [wmisearcher] type accelerator to cast the query or the variable.</source>
          <target state="translated">[Wmisearcher] 类型快捷键可用于将查询或将变量强制转换。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In the following example, the [wmisearcher] type accelerator is used to cast the variable.</source>
          <target state="translated">在下面的示例中，[wmisearcher] 类型快捷键用于转换该变量。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The result is the same.</source>
          <target state="translated">结果是相同的。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>PS C:&gt; [wmisearcher]$bios = "Select * from Win32_Bios" PS C:&gt; $bios.Get()</source>
          <target state="translated">PS c: &gt; wmisearcher $bios ="选择 * 从 Win32_Bios"PS c: &gt; $bios。Get()</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW (1.36) 制造商︰ 联想名称︰ 默认系统 BIOS 序列号︰ R9FPY3P 版本︰ 联想 – 1360年</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>When you use the [wmisearcher] type accelerator, it changes the query string into a ManagementObjectSearcher object, as shown in the following commands.</source>
          <target state="translated">当使用 [wmisearcher] 类型快捷键时，它更改查询字符串转换为 ManagementObjectSearcher 对象，如下面的命令中所示。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$a = "Select * from Win32_Bios" PS C:&gt;$a.GetType().FullName System.String</source>
          <target state="translated">PS c: &gt;$ a ="选择 * 从 Win32_Bios"PS c: &gt; $a.GetType()。FullName System.String</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$a = [wmisearcher]"Select * from Win32_Bios" PS C:&gt;$a.GetType().FullName System.Management.ManagementObjectSearcher</source>
          <target state="translated">PS c: &gt;$ = [wmisearcher] a"中选择 * 从 Win32_Bios"PS c: &gt; $a.GetType()。FullName System.Management.ManagementObjectSearcher</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This command format works on any query.</source>
          <target state="translated">此命令格式适用于任何查询。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The following command gets the value of the Name property of the Win32_Bios WMI class.</source>
          <target state="translated">以下命令获取 Win32_Bios WMI 类的 Name 属性的值。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $biosname = [wmisearcher]"Select Name from Win32_Bios" PS C:&gt; $biosname.Get()</source>
          <target state="translated">PS $biosname c: &gt; = [wmisearcher]"中选择的名称，从 Win32_Bios"PS c: &gt; $biosname。Get()</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS</source>
          <target state="translated">名称︰ 默认系统 BIOS</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>You can perform this operation in a single command, although the command is a bit more difficult to interpret.</source>
          <target state="translated">可以在单个命令中，执行此操作，尽管该命令是有点更难于解释。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In this format, you use the [wmisearcher] type accelerator to cast the WQL query string to a ManagementObjectSearcher, and then call the Get method on the object -- all in a single command.</source>
          <target state="translated">在这种格式，可以使用 [wmisearcher] 类型快捷键来将 WQL 查询字符串转换为 ManagementObjectSearcher，然后对象--在单个命令中的所有调用 Get 方法。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The parentheses () that enclose the casted string direct Windows PowerShell to cast the string before calling the method.</source>
          <target state="translated">将强制转换后的字符串括在括号 （） 指示 Windows PowerShell 先将字符串转换调用方法前。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>PS C:&gt; ([wmisearcher]"Select name from Win32_Bios").Get()</source>
          <target state="translated">PS c: &gt; ([wmisearcher]"已完成从 Win32_Bios Select name")。Get()</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS</source>
          <target state="translated">名称︰ 默认系统 BIOS</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>USING THE BASIC WQL WHERE STATEMENT</source>
          <target state="translated">使用基本 WQL 其中语句</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A Where statement establishes conditions for the data that a Select statement returns.</source>
          <target state="translated">答︰ 其中语句建立的 Select 语句返回的数据的条件。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The Where statement has the following format:</source>
          <target state="translated">Where 语句具有以下格式︰</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>where</source>
          <target state="translated">（其中</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>where Name = 'Notepad.exe'</source>
          <target state="translated">where Name = 'Notepad.exe</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The Where statement is used with the Select statement, as shown in the following example.</source>
          <target state="translated">Where 语句用于 Select 语句，如下面的示例中所示。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Select * from Win32_Process where Name = 'Notepad.exe'</source>
          <target state="translated">选择 * from Win32_Process where Name = 'Notepad.exe</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When using the Where statement, the property name and value must be accurate.</source>
          <target state="translated">当使用 Where 语句、 属性名称和值必须精确。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the Notepad processes on the local computer.</source>
          <target state="translated">例如，以下命令将获取本地计算机上 Notepad 进程。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Query "Select * from Win32_Process where name = 'Notepad.exe'"</source>
          <target state="translated">PS c: &gt; Get-wmiobject-查询"选择 * from Win32_Process where name = 'Notepad.exe'"</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>However, the following command fails, because the process name includes the ".exe" file name extension.</source>
          <target state="translated">但是，下面的命令失败，因为相应的进程名称包含".exe"文件扩展名。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Query "Select * from Win32_Process where name = 'Notepad'"</source>
          <target state="translated">PS c: &gt; Get-wmiobject-查询"选择 * from Win32_Process where name = 记事本"</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>WHERE STATEMENT COMPARISON OPERATORS</source>
          <target state="translated">其中语句比较运算符</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following operators are valid in a WQL Where statement.</source>
          <target state="translated">以下运算符中都有效的 WQL Where 语句。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Operator    Description</source>
          <target state="translated">运算符说明</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>=           Equal !=          Not equal &lt;&gt;          Not equal &lt;           Less than</source>
          <target state="translated">= 相等 ！ = 不等于 &lt;&gt; 不等于 &lt; 小于</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>&lt;=          Less than or equal =          Greater than or equal LIKE        Wildcard match IS          Evaluates null ISNOT       Evaluates not null ISA         Evaluates a member of a WMI class</source>
          <target state="translated">&lt; = 小于或等于 = 大于或等于像通配符匹配是计算结果为 null ISNOT 计算结果不为 null ISA 的计算结果的 WMI 类成员</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>There are other operators, but these are the ones used for making comparisons.</source>
          <target state="translated">其他运算符，但这些都是用于进行比较。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>For example, the following query selects the Name and Priority properties from processes in the Win32_Process class where the process priority is greater than or equal to 11.</source>
          <target state="translated">例如，下面的查询选择的名称和优先级属性与在其中进程优先级是大于或等于 11 Win32_Process 类中的进程。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The Get-WmiObject cmdlet runs the query.</source>
          <target state="translated">Get-wmiobject cmdlet 运行的查询。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>$highPriority = "Select Name, Priority from Win32_Process where Priority &gt;= 11" Get-WmiObject -Query $highPriority</source>
          <target state="translated">$highPriority ="选择名称，从 Win32_Process 的优先级，优先级 &gt; = 11"Get-wmiobject-查询 $highPriority</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>USING THE WQL OPERATORS IN THE FILTER PARAMETER</source>
          <target state="translated">在筛选器参数中使用 WQL 运算符</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The WQL operators can also be used in the value of the Filter parameter of the Get-WmiObject or Get-CimInstance cmdlets, as well as in the value of the Query parameters of these cmdlets.</source>
          <target state="translated">WQL 运算符还可在 Get-wmiobject 或 Get-ciminstance cmdlet，则 Filter 参数的值以及在这些 cmdlet 的查询参数的值。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the Name and ProcessID properties of the last five processes that have ProcessID values greater than 1004.</source>
          <target state="translated">例如，以下命令将获取具有大于 1004 ProcessID 值的最后五个进程的名称和 ProcessID 属性。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The command uses the Filter parameter to specify the ProcessID condition.</source>
          <target state="translated">该命令使用筛选器参数来指定 ProcessID 条件。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Class Win32_Process ` -Property Name, ProcessID -Filter "ProcessID &gt;= 1004" | Sort ProcessID | Select Name, ProcessID -Last 5</source>
          <target state="translated">PS c: &gt; Get-wmiobject-类 Win32_Process' 的属性名称、 ProcessID-筛选器"ProcessID &gt; = 1004年"|排序 ProcessID |选择名称，ProcessID-最后 5</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Name                                 ProcessID</source>
          <target state="translated">名称 ProcessID</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>SROSVC.exe                                4220</source>
          <target state="translated">SROSVC.exe 4220</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>WINWORD.EXE                               4664</source>
          <target state="translated">WINWORD。EXE                               4664</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>TscHelp.exe                               4744 SnagIt32.exe                              4748 WmiPrvSE.exe                              5056</source>
          <target state="translated">TscHelp.exe 4744 SnagIt32.exe 4748 WmiPrvSE.exe 5056</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>USING THE LIKE OPERATOR</source>
          <target state="translated">使用 LIKE 运算符</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The Like operator lets you use wildcard characters to filter the results of a WQL query.</source>
          <target state="translated">Like 运算符，可以使用通配符来筛选结果的 WQL 查询。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Like Operator  Description</source>
          <target state="translated">类似运算符说明</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>[]             Character in a range [a-f] or a set of characters [abcdef].</source>
          <target state="translated">[] 范围 [a-f] 或 [abcdef] 字符集中的字符。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The items in a set do not need to be consecutive or listed in alphabetical order.</source>
          <target state="translated">一组中的项不需要是连续或按字母顺序列出。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>^              Character not in a range [^a-f] or not in a set [^abcdef].</source>
          <target state="translated">^ 不在一系列字符 [^ a-f] 或一组中不存在 [^ abcdef]。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The items in a set do not need to be consecutive or listed in alphabetical order.</source>
          <target state="translated">一组中的项不需要是连续或按字母顺序列出。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>%              A string of zero or more characters</source>
          <target state="translated">%的零个或多个字符的字符串</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>              One character. (underscore)    NOTE: To use a literal underscore in a query string, enclose it in square brackets [<ept id="p1">_</ept>].</source>
          <target state="translated"><bpt id="p1">_</bpt>              1 个字符。（下划线）   注意︰ 若要在查询字符串中使用文字下划线，将其括在方括号 [<ept id="p1">_</ept>]。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>When the Like operator is used without any wildcard characters or range operators, it behaves like the equality operator (=) and returns objects only when they are an exact match for the pattern.</source>
          <target state="translated">使用 Like 运算符时没有任何通配符或范围运算符，它类似于相等运算符 （=），并返回对象，仅当它们时完全匹配的模式。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>You can combine the range operation with the percent wildcard character to create simple, yet powerful filters.</source>
          <target state="translated">您可以组合的百分号通配符，以创建简单、 但功能强大的筛选器的范围操作。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>LIKE OPERATOR EXAMPLES</source>
          <target state="translated">类似的运算符示例</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>EXAMPLE 1: [<ph id="ph1">&lt;range&gt;</ph>] The following commands start Notepad and then search for an instance of the Win32_Process class that has a name that starts with a letter between "H" and "N" (case-insensitive).</source>
          <target state="translated">示例 1: [<ph id="ph1">&lt;range&gt;</ph>] 以下命令启动记事本，然后搜索以字母"H"和"N"（不区分大小写） 之间开头的名称的 Win32_Process 类的实例。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The query should return any process from Hotpad.exe through Notepad.exe.</source>
          <target state="translated">从通过 Notepad.exe Hotpad.exe，则查询应返回的任何进程。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Notepad   # Starts Notepad PS C:&gt; $query = "Select * from win32_Process where Name LIKE '[H-N]otepad.exe'" PS C:&gt; Get-WmiObject -Query $query | Select Name, ProcessID</source>
          <target state="translated">PS c: &gt; 记事本 # 启动记事本 PS $query c: &gt; ="选择 * from win32_Process 名称，如 [H N] otepad.exe"PS c: &gt; Get-wmiobject-查询 $query |选择名称，ProcessID</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Name                                ProcessID</source>
          <target state="translated">名称 ProcessID</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>notepad.exe                              1740</source>
          <target state="translated">notepad.exe 1740</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>EXAMPLE 2: [<ph id="ph1">&lt;range&gt;</ph>] and % The following commands select all process that have a name that begins with a letter between A and P (case-insensitive) followed by zero or more letters in any combination.</source>
          <target state="translated">示例 2: [<ph id="ph1">&lt;range&gt;</ph>] 和 %以下命令选择具有名称之间的字母开头的所有进程 A 和 P （不区分大小写） 后, 跟零个或多个字母的任意组合。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The Get-WmiObject cmdlet runs the query, the Select-Object cmdlet gets the Name and ProcessID properties, and the Sort-Object cmdlet sorts the results in alphabetical order by name.</source>
          <target state="translated">运行查询时的 Get-wmiobject cmdlet、 Select-object cmdlet 将获取名称和 ProcessID 属性中，和 Sort-object cmdlet 按名称对结果按字母顺序排序。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$query = "Select * from win32_Process where name LIKE '[A-P]%'" PS C:&gt;Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID | Sort-Object -Property Name</source>
          <target state="translated">PS c: &gt; $query ="选择 * from win32_Process 其中 name LIKE '[A P] %'"PS c: &gt; Get-wmiobject-查询 $query |Select-object-属性名称、 ProcessID |排序对象的属性名称</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>EXAMPLE 3: Not in Range (^) The following command gets processes whose names do not begin with any of the following letters:</source>
          <target state="translated">示例 3︰ 不在范围内 (^) 以下命令将获取其名称不是以任何以下字母开头的进程︰</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>A, S, W, P, R, C, U, N</source>
          <target state="translated">A、 S、 W、 P、 R、 C、 U、 N</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>and followed zero or more letters.</source>
          <target state="translated">且跟零个或多个字母。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$query = "Select * from win32_Process where name LIKE '[^ASWPRCUN]%'" PS C:&gt;Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID | Sort-Object -Property Name</source>
          <target state="translated">PS c: &gt; $query ="选择 * from win32_Process 名称喜欢其中 [^ ASWPRCUN] %'"PS c: &gt; Get-wmiobject-查询 $query |Select-object-属性名称、 ProcessID |排序对象的属性名称</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>EXAMPLE 4: Any characters -- or none (%) The following commands get processes that have names that begin with "calc".</source>
          <target state="translated">示例 4:-的任何字符或 none （%）以下命令将获取具有名称以"calc"开头的进程。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The % symbol in WQL is equivalent to the asterisk (*) symbol in regular expressions.</source>
          <target state="translated">在 WQL 中的 %符号等效于正则表达式中的星号 （*） 符号。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $query = "Select * from win32_Process where Name LIKE 'calc%'" PS C:&gt; Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID</source>
          <target state="translated">PS $query c: &gt; ="选择 * from win32_Process where Name LIKE 'calc %'"PS c: &gt; Get-wmiobject-查询 $query |Select-object-属性名称、 ProcessID</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Name                               ProcessID</source>
          <target state="translated">名称 ProcessID</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>calc.exe                                4424</source>
          <target state="translated">calc.exe 4424</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>EXAMPLE 5: One character (_) The following commands get processes that have names that have the following pattern, "c_lc.exe" where the underscore character represents any one character.</source>
          <target state="translated">示例 5: 1 个字符 (_) 以下命令获取名称中使用了以下模式"c_lc.exe"其中下划线字符表示的任何一个字符的进程。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>This pattern matches any name from calc.exe through czlc.exe, or c9lc.exe, but does not match names in which the "c" and "l" are separated by more than one character.</source>
          <target state="translated">此模式匹配从 calc.exe 通过 czlc.exe 或 c9lc.exe，任何名称，但与在其中的"c"和"l"隔开多个字符的名称不匹配。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $query = "Select * from Win32_Process where Name LIKE 'c_lc.exe'" PS C:&gt; Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID</source>
          <target state="translated">PS $query c: &gt; ="选择 * from Win32_Process where Name LIKE 'c_lc.exe'"PS c: &gt; Get-wmiobject-查询 $query |Select-object-属性名称、 ProcessID</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Name                                 ProcessID</source>
          <target state="translated">名称 ProcessID</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>calc.exe                                  4424</source>
          <target state="translated">calc.exe 4424</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>EXAMPLE 6: Exact match The following commands get processes named WLIDSVC.exe.</source>
          <target state="translated">示例 6︰ 完全匹配项的以下命令获取进程名为 WLIDSVC.exe。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Even though the query uses the Like keyword, it requires an exact match, because the value does not include any wildcard characters.</source>
          <target state="translated">即使该查询使用 Like 关键字，它需要完全匹配，因为值不包含任何通配符。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>$query = "Select * from win32_Process where name LIKE 'WLIDSVC.exe'" Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID</source>
          <target state="translated">$query ="选择 * from win32_Process 其中 name LIKE 'WLIDSVC.exe'"Get-wmiobject-查询 $query |Select-object-属性名称、 ProcessID</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Name                                 ProcessID</source>
          <target state="translated">名称 ProcessID</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>WLIDSVC.exe                                84</source>
          <target state="translated">WLIDSVC.exe 84</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>USING THE OR OPERATOR</source>
          <target state="translated">使用或运算符</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>To specify multiple independent conditions, use the Or keyword.</source>
          <target state="translated">若要指定多个独立的条件，请使用或关键字。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The Or keyword appears in the Where clause.</source>
          <target state="translated">Or 关键字出现在 Where 子句。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>It performs an inclusive OR operation on two (or more) conditions and returns items that meet any of the conditions.</source>
          <target state="translated">它执行两个 （或更多） 条件非独占或运算，并返回满足任何条件的项。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The Or operator has the following format:</source>
          <target state="translated">或运算符具有以下格式︰</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> or <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</source>
          <target state="translated">Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> or <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>For example, the following commands get all instances of the Win32_Process WMI class but returns them only if the process name is winword.exe or excel.exe.</source>
          <target state="translated">例如，以下命令获取 Win32_Process WMI 类的所有实例，但仅当该进程的名称是 winword.exe 或 excel.exe 返回它们。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_Process where Name = 'winword.exe' or Name = 'excel.exe'" PS C:&gt;Get-WmiObject -Query $q</source>
          <target state="translated">PS c: &gt; $q ="选择 * from Win32_Process where Name = 'winword.exe 或名称 = excel.exe"PS c: &gt; Get-wmiobject-查询 $q</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The Or statement can be used with more than two conditions.</source>
          <target state="translated">Or 语句可以用于两个以上的条件。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>In the following query, the Or statement gets Winword.exe, Excel.exe, or Powershell.exe.</source>
          <target state="translated">在下面的查询或语句获取 Winword.exe、 Excel.exe 或 Powershell.exe。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>$q = "Select * from Win32_Process where Name = 'winword.exe' or Name = 'excel.exe' or Name = 'powershell.exe'"</source>
          <target state="translated">$q ="选择 * from Win32_Process where Name = 'winword.exe 或名称 = excel.exe 或名称 = powershell.exe'"</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>USING THE AND OPERATOR</source>
          <target state="translated">使用 AND 运算符</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>To specify multiple related conditions, use the And keyword.</source>
          <target state="translated">若要指定多个相关的条件，请使用关键字。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The And keyword appears in the Where clause.</source>
          <target state="translated">关键字将出现在 Where 子句。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>It returns items that meet all of the conditions.</source>
          <target state="translated">它将返回满足所有条件的项。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The And operator has the following format:</source>
          <target state="translated">And 运算符具有以下格式︰</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> and <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</source>
          <target state="translated">Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> and <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>For example, the following commands get processes that have a name of "Winword.exe" and the process ID of 6512.</source>
          <target state="translated">例如，以下命令将获取具有名称"Winword.exe"和 6512 的进程 ID 的进程。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Note that the commands use the Get-CimInstance cmdlet.</source>
          <target state="translated">请注意，这些命令使用 Get-ciminstance cmdlet。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_Process where Name = 'winword.exe' and ProcessID =6512" PS C:&gt; Get-CimInstance -Query $q</source>
          <target state="translated">PS c: &gt; $q ="选择 * from Win32_Process where Name = 'winword.exe 和 ProcessID = 6512"PS c: &gt; Get-ciminstance-查询 $q</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>ProcessId        Name             HandleCount      WorkingSetSize   VirtualSize</source>
          <target state="translated">ProcessId 名称 HandleCount WorkingSetSize VirtualSize</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>6512             WINWORD.EXE      768              117170176        633028608</source>
          <target state="translated">6512 WINWORD。EXE 768 117170176 633028608</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>All operators, including the Like operators are valid with the Or and And operators.</source>
          <target state="translated">所有运算符，其中包括 Like 运算符都都有效，且或运算和运算符。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>And, you can combine the Or and And operators in a single query with parentheses that tell Windows PowerShell which clauses to process first.</source>
          <target state="translated">您可以综合或运算，并带有括号的单个查询中的运算符，告诉 Windows PowerShell 要首先处理的子句。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>This command uses the Windows PowerShell continuation character (`) divide the command into two lines.</source>
          <target state="translated">此命令使用 Windows PowerShell 延续字符 （'） 除命令为两个行。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_Process ` where (Name = 'winword.exe' or Name = 'excel.exe') and HandleCount &gt; 700"</source>
          <target state="translated">PS $q c: &gt; ="选择 * 从 Win32_Process' 何处 (名称 = winword.exe 或名称 = excel.exe) 和 HandleCount &gt; 700"</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-CimInstance -Query $q ProcessId        Name             HandleCount      WorkingSetSize   VirtualSize</source>
          <target state="translated">PS c: &gt; Get-ciminstance-查询 $q ProcessId 名称 HandleCount WorkingSetSize VirtualSize</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>6512             WINWORD.EXE      797              117268480        634425344</source>
          <target state="translated">6512 WINWORD。EXE 797 117268480 634425344</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>9610             EXCEL.EXE        727               38858752        323227648</source>
          <target state="translated">9610 EXCEL。EXE 727 38858752 323227648</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>SEARCHING FOR NULL VALUES</source>
          <target state="translated">搜索的 NULL 值</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Searching for null values in WMI is challenging, because it can lead to unpredictable results.</source>
          <target state="translated">搜索在 WMI 中的 null 值具有挑战性，因为这可能会导致不可预知的结果。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Null is not zero and it is not equivalent or to an empty string.</source>
          <target state="translated">Null 不为零，并且不等效也为空字符串。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Some WMI class properties are initialized and others are not, so a search for null might not work for all properties.</source>
          <target state="translated">初始化一些 WMI 类属性，并且其他人不可用，因此搜索 null 可能无法工作的所有属性。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>To search for null values, use the Is operator with a value of "null".</source>
          <target state="translated">若要搜索的 null 值，使用 Is 运算符值为"null"。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For example, the following commands get processes that have a null value for the IntallDate property.</source>
          <target state="translated">例如，以下命令将获取具有 IntallDate 属性的 null 值的进程。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The commands return many processes.</source>
          <target state="translated">命令返回多个进程。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_Process where InstallDate is null" PS C:&gt;Get-WmiObject -Query $q</source>
          <target state="translated">PS c: &gt; $q ="选择 * from Win32_Process InstallDate 为 null 的情况"PS c: &gt; Get-wmiobject-查询 $q</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>In contrast, the following command, gets user accounts that have a null value for the Description property.</source>
          <target state="translated">与此相反，以下命令，获取具有 null 值的 Description 属性的用户帐户。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>This command does not return any user accounts, even though most user accounts do not have any value for the Description property.</source>
          <target state="translated">此命令不返回任何用户帐户，即使大多数用户帐户不具有任何值说明属性的也是如此。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_UserAccount where Description is null" PS C:&gt;Get-WmiObject -Query $q</source>
          <target state="translated">PS c: &gt; $q ="选择 * 从 Win32_UserAccount 说明为 null 的情况"PS c: &gt; Get-wmiobject-查询 $q</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>To find the user accounts that have no value for the Description property, use the equality operator to get an empty string.</source>
          <target state="translated">若要查找的 Description 属性没有值的用户帐户，请使用相等运算符以获取为空字符串。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>To represent the empty string, use two consecutive single quotation marks.</source>
          <target state="translated">若要表示空字符串，使用两个连续单引号引起来。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>$q = "Select * from Win32_UserAccount where Description = '' "</source>
          <target state="translated">$q ="选择 * 从 Win32_UserAccount 其中说明 = '"</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>USING TRUE OR FALSE</source>
          <target state="translated">使用 TRUE 或 FALSE</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>To get Boolean values in the properties of WMI objects, use True and False.</source>
          <target state="translated">若要获取 WMI 对象的属性中的布尔值，请使用 True 和 False。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>They are not case sensitive.</source>
          <target state="translated">它们不区分大小写。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The following WQL query returns only local user accounts from a domain joined computer.</source>
          <target state="translated">以下 WQL 查询返回从加入域的计算机只有本地用户帐户。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_UserAccount where LocalAccount = True" PS C:&gt;Get-CimInstance -Query $q</source>
          <target state="translated">PS c: &gt; $q ="选择 * 从 Win32_UserAccount 其中 LocalAccount = True"PS c: &gt; Get-ciminstance-查询 $q</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>To find domain accounts, use a value of False, as shown in the following example.</source>
          <target state="translated">若要查找的域帐户，请在下面的示例所示使用值为 False。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_UserAccount where LocalAccount = False" PS C:&gt;Get-CimInstance -Query $q</source>
          <target state="translated">PS c: &gt; $q ="选择 * 从 Win32_UserAccount 其中 LocalAccount = False"PS c: &gt; Get-ciminstance-查询 $q</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>USING THE ESCAPE CHARACTER</source>
          <target state="translated">使用转义字符</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>WQL uses the backslash () as its escape character.</source>
          <target state="translated">WQL 使用反斜杠 （） 作为它的转义字符。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>This is different from Windows PowerShell, which uses the backtick character (`).</source>
          <target state="translated">这是不同于 Windows PowerShell，使用反引号字符 （'）。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Quotation marks, and the characters used for quotation marks, often need to be escaped so that they are not misinterpreted.</source>
          <target state="translated">引号引起来，并用于引号引起来的字符，通常需要转义，以使不被错误解释。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>To find a user whose name includes a single quotation mark, use a backslash to escape the single quotation mark, as shown in the following command.</source>
          <target state="translated">若要查找名称中包含单引号的用户，使用反斜杠进行转义单引号，如下面的命令中所示。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_UserAccount where Name = 'Tim O<ph id="ph1">\'</ph>Brian'" PS C:&gt; Get-CimInstance -Query $q Name             Caption          AccountType      SID              Domain</source>
          <target state="translated">PS $q c: &gt; ="选择 * 从 Win32_UserAccount where Name = Tim O<ph id="ph1">\'</ph>Brian'"PS c: &gt; Get-ciminstance-查询 $q 名标题 AccountType SID 域</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Tim O'Brian      FABRIKAM\TimO    512              S-1-5-21-1457... FABRIKAM</source>
          <target state="translated">Tim 遍 O'Brian FABRIKAM\TimO 512 S-1-5-21-1457...FABRIKAM</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>In some case, the backslash also needs to be escaped.</source>
          <target state="translated">在某些情况下，反斜杠还需要对其进行转义。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>For example, the following commands generate an Invalid Query error due to the backslash in the Caption value.</source>
          <target state="translated">例如，以下命令生成无效的查询错误由于反斜杠标题值中。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_UserAccount where Caption = 'Fabrikam\TimO'" PS C:&gt; Get-CimInstance -Query $q Get-CimInstance : Invalid query At line:1 char:1</source>
          <target state="translated">PS $q c: &gt; ="选择 * 从 Win32_UserAccount 其中标题 = 'Fabrikam\TimO'"PS c: &gt; Get-ciminstance-查询 $q Get-ciminstance︰ 无效的查询在行︰ 1 char: 1</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Get-CimInstance -Query $q</source>
          <target state="translated">Get-ciminstance-查询 $q</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~~~~~~~</source>
          <target state="translated">+!包括 [] ~ ~ ~</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>CategoryInfo          : InvalidArgument: (:) [Get-CimInstance], CimException</source>
          <target state="translated">CategoryInfo: InvalidArgument: （:）[Get-ciminstance]，CimException</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>FullyQualifiedErrorId : HRESULT 0x80041017,Microsoft.Management.Infrastructure.CimCmdlets</source>
          <target state="translated">FullyQualifiedErrorId: HRESULT 0x80041017,Microsoft.Management.Infrastructure.CimCmdlets</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>To escape the backslash, use a second backslash character, as shown in the following command.</source>
          <target state="translated">若要将反斜杠进行转义，使用第二个反斜杠字符，如下面的命令中所示。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_UserAccount where Caption = 'Fabrikam\TimO'" PS C:&gt; Get-CimInstance -Query $q</source>
          <target state="translated">PS $q c: &gt; ="选择 * 从 Win32_UserAccount，标题 = 'Fabrikam\TimO'"PS c: &gt; Get-ciminstance-查询 $q</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另请参阅</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>about_Escape_Characters about_Quoting_Rules about_WMI about_WMI_Cmdlets</source>
          <target state="translated">about_Escape_Characters about_Quoting_Rules about_WMI about_WMI_Cmdlets</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>