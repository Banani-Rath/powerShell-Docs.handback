<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">14a5473339913a93f4731578790c72f08ddac71f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Foreach.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e9374a96bbcc07aa9b5019b6f8d991fab190adf0</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29cff617b56a2c9d858ed6fd0fed891cd36e58fe</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell コマンドレット</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About ForEach</source>
          <target state="translated">ForEach について</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Foreach</source>
          <target state="translated">about_Foreach</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">概要</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes a language command you can use to traverse all the items in a collection of items.</source>
          <target state="translated">項目のコレクション内のすべての項目を通過する使用できる言語コマンドについて説明します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細説明</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Foreach statement (also known as a Foreach loop) is a language construct for stepping through (iterating) a series of values in a collection of items.</source>
          <target state="translated">Foreach ステートメント (Foreach ループとも呼ばれます) をステップ実行 (反復処理する) 言語構成要素は、一連の項目のコレクション内の値。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The simplest and most typical type of collection to traverse is an array.</source>
          <target state="translated">走査するコレクションの最も単純で最も一般的な型は配列です。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Within a Foreach loop, it is common to run one or more commands against each item in an array.</source>
          <target state="translated">Foreach ループ内では、配列内の各項目に対して 1 つまたは複数のコマンドを実行する一般的なです。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Syntax The following shows the ForEach syntax:</source>
          <target state="translated">次の構文は、ForEach 構文を示しています。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>foreach ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>){<ph id="ph3">&lt;statement list&gt;</ph>}</source>
          <target state="translated">foreach ($<ph id="ph1">&lt;item&gt;</ph> $<ph id="ph2">&lt;collection&gt;</ph>) {<ph id="ph3">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Simplified syntax Starting in Windows PowerShell 3.0, syntax with language keywords such as Where and ForEach was simplified.</source>
          <target state="translated">簡略化した構文以降では、Windows PowerShell 3.0 では、場所などの言語キーワードの構文と ForEach が簡素化します。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Comparison operators that work on the members of a collection are treated as parameters.</source>
          <target state="translated">コレクションのメンバーで機能する比較演算子は、パラメーターとして扱われます。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can use a method on the members of a collection without containing it in a script block or adding the automatic variable "$_.".</source>
          <target state="translated">スクリプト ブロックを格納しているか、自動変数の「$_」を追加することがなく、コレクションのメンバーに、メソッドを使用できます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the following two examples:</source>
          <target state="translated">次の 2 つの例を考慮してください。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>dir cert:\ -Recurse | foreach GetKeyAlgorithm dir cert:\ -Recurse | foreach {$_.GetKeyAlgorithm()}</source>
          <target state="translated">dir cert: \-Recurse |foreach GetKeyAlgorithm dir cert: \-Recurse |foreach {$_ です。GetKeyAlgorithm()}</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Although both commands work, the first returns results without using a script block or the $_.</source>
          <target state="translated">どちらのコマンドで動作する 1 つ目は、スクリプト ブロックまたは $_ を使用せず結果を返します。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>automatic variable.</source>
          <target state="translated">自動変数です。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The method GetKeyAlgorithm is treated as a parameter of ForEach.</source>
          <target state="translated">GetKeyAlgorithm メソッドは、ForEach のパラメーターとして扱われます。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The first command returns the same results, but without errors, because the simplified syntax does not attempt to return results for items for which the specified argument did not apply.</source>
          <target state="translated">最初のコマンドは、同じ結果を返しますが、エラーなしを指定された引数は適用されませんでした項目の結果を返すために簡略化された構文が行われませんので。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Get-Process property Description is passed as a parameter argument of the ForEach statement.</source>
          <target state="translated">この例では、Get-process プロパティの説明は渡されます ForEach ステートメントの引数のパラメーターとして。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The results are the descriptions of active processes.</source>
          <target state="translated">結果は、アクティブなプロセスの説明を示します。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Get-Process | ForEach Description</source>
          <target state="translated">Get-process |ForEach の説明</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The Foreach statement outside a command pipeline The part of the Foreach statement enclosed in parenthesis represents a variable and a collection to iterate.</source>
          <target state="translated">コマンド パイプラインの Foreach ステートメントをかっこで囲まれた部分の外側の Foreach ステートメントでは、変数および反復処理するコレクションを表します。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows PowerShell creates the variable ($<ph id="ph1">&lt;item&gt;</ph>) automatically when the Foreach loop runs.</source>
          <target state="translated">Windows PowerShell 変数を作成する ($<ph id="ph1">&lt;item&gt;</ph>)、Foreach ループが実行時に自動的にします。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Prior to each iteration through the loop, the variable is set to a value in the collection.</source>
          <target state="translated">ループの各反復処理する前に、変数は、コレクション内の値に設定されます。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The block following a Foreach statement {<ph id="ph1">&lt;statement list&gt;</ph>} contains a set of commands to execute against each item in a collection.</source>
          <target state="translated">Foreach ステートメントに続くブロック {<ph id="ph1">&lt;statement list&gt;</ph>} コレクション内の各項目に対して実行するコマンドのセットが含まれています。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Examples For example, the Foreach loop in the following example displays the values in the $letterArray array.</source>
          <target state="translated">例の例では、次の例では、Foreach ループは $letterArray 配列の値を表示します。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>$letterArray = "a","b","c","d" foreach ($letter in $letterArray) { Write-Host $letter }</source>
          <target state="translated">$letterArray ="a"、"b"、「c"、」d"foreach ($letterArray で $letter) {Write-host $letter}</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In this example, the $letterArray array is created and initialized with the string values "a", "b", "c", and "d".</source>
          <target state="translated">$LetterArray 配列が作成され、文字列値で初期化されたこの例では"a"、"b"、"c"および"d"です。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The first time the Foreach statement runs, it sets the $letter variable equal to the first item in $letterArray ("a").</source>
          <target state="translated">Foreach ステートメントを初めて実行する設定 $letter 変数の最初の項目と等しい $letterArray ("a") にします。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Then, it uses the Write-Host cmdlet to display the letter a.</source>
          <target state="translated">Write-host コマンドレットを使用して、文字を表示し、です。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The next time through the loop, $letter is set to "b", and so on.</source>
          <target state="translated">ループで次回 $letter は"b"に設定されます。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>After the Foreach loop displays the letter d, Windows PowerShell exits the loop.</source>
          <target state="translated">Foreach ループでは、文字 d が表示されたら、Windows PowerShell は、ループを終了します。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement must appear on a single line to run it as a command at the Windows PowerShell command prompt.</source>
          <target state="translated">全体の Foreach ステートメントは、Windows PowerShell コマンド プロンプトでコマンドとして実行する単一の行に表示する必要があります。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement does not have to appear on a single line if you place the command in a .ps1 script file instead.</source>
          <target state="translated">全体の Foreach ステートメントは、代わりに .ps1 スクリプト ファイルにコマンドを配置する場合は、単一の行に表示する必要はありません。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Foreach statements can also be used together with cmdlets that return a collection of items.</source>
          <target state="translated">Foreach ステートメントは、項目のコレクションを返すコマンドレットと共に使用できます。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement steps through the list of items that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">次の例では、Get-childitem コマンドレットによって返される項目の一覧を Foreach ステートメント手順を実行します。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { Write-Host $file }</source>
          <target state="translated">foreach (Get-childitem に $file) {Write-host $file}</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can refine the example by using an If statement to limit the results that are returned.</source>
          <target state="translated">例を絞り込む場合を使用して、返される結果を制限するステートメントです。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement performs the same looping operation as the previous example, but it adds an If statement to limit the results to files that are greater than 100 kilobytes (KB):</source>
          <target state="translated">次の例では、Foreach ステートメントは前の例と同じループ処理を行います。 今回は、If が追加されて結果が 100 (kb) より大きいファイルを制限するステートメント。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file } }</source>
          <target state="translated">foreach (Get-childitem に $file) {場合 ($file.length gt 100 KB) {Write-host $file}}</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach loop uses a property of the $file variable to perform a comparison operation ($file.length -gt 100KB).</source>
          <target state="translated">この例では、Foreach ループは、比較操作 ($file.length gt 100 KB) を実行するのに $file 変数のプロパティを使用します。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The $file variable contains all the properties in the object that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">$File 変数には、Get-childitem コマンドレットによって返されるオブジェクト内のすべてのプロパティが含まれています。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Therefore, you can return more than just a file name.</source>
          <target state="translated">そのため、ファイル名だけを返すことができます。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In the next example, Windows PowerShell returns the length and the last access time inside the statement list:</source>
          <target state="translated">次の例では、Windows PowerShell は、長さやステートメントの一覧内の最終アクセス日時を返します。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file Write-Host $file.length Write-Host $file.lastaccesstime } }</source>
          <target state="translated">foreach (Get-childitem に $file) {場合 ($file.length gt 100 KB) {Write-host $file Write-host $file.length Write-host $file.lastaccesstime}}</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In this example, you are not limited to running a single command in a statement list.</source>
          <target state="translated">この例では限定されない、ステートメントの一覧で 1 つのコマンドを実行します。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can also use a variable outside a Foreach loop and increment the variable inside the loop.</source>
          <target state="translated">Foreach ループの外側の変数を使用し、ループ内で、変数をインクリメントできます。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following example counts files over 100 KB in size:</source>
          <target state="translated">次の例では、100 KB を超えるサイズのファイルをカウントします。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>$i = 0 foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file "file size:" ($file.length / 1024).ToString("F0") KB $i = $i + 1 } }</source>
          <target state="translated">$i = 0 foreach (Get-childitem に $file) {場合 ($file.length gt 100 KB) {Write-host $file"ファイルのサイズ:"($file.length/1024)。ToString("F0") KB $i = $i + 1}}</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>if ($i -ne 0) { Write-Host Write-Host $i " file(s) over 100 KB in the current directory."}</source>
          <target state="translated">場合 ($i-ne 0) {Write-host Write-host $i「個のファイル以上 100 KB で、現在のディレクトリです」}。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>else { Write-Host "No files greater than 100 KB in the current directory."</source>
          <target state="translated">else {Write-host「ファイルはありません、現在のディレクトリが 100 KB より大きい」</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the preceding example, the $i variable is set to 0 outside the loop, and the variable is incremented inside the loop for each file that is found that is larger than 100 KB.</source>
          <target state="translated">前の例では、$i 変数は、ループの外側の 0 に設定し、ファイルごとにある 100 KB を超えるサイズの大きなループ内で、変数が増加します。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When the loop exits, an If statement evaluates the value of $i to display a count of all the files over 100 KB.</source>
          <target state="translated">ループを終了すると、If ステートメントは 100 KB を超えるのすべてのファイルの数を表示する $i の値を評価します。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Or, it displays a message stating that no files over 100 KB were found.</source>
          <target state="translated">または、100 KB を超えるファイルが見つからなかったことを示すメッセージが表示されます。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The previous example also demonstrates how to format the file length results:</source>
          <target state="translated">前の例では、ファイルの長さの結果を書式設定する方法も示します。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>($file.length / 1024).ToString("F0")</source>
          <target state="translated">($file.length/1024)。ToString("F0")</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The value is divided by 1,024 to show the results in kilobytes rather than bytes, and the resulting value is then formatted using the fixed-point format specifier to remove any decimal values from the result.</source>
          <target state="translated">値を (バイト単位) ではなく、キロバイト単位で結果を表示する 1,024 で除算し、結果として得られる値が結果から、decimal 型の値を削除する、固定小数点の書式指定子を使用して書式設定し、します。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The 0 makes the format specifier show no decimal places.</source>
          <target state="translated">0 は、小数点以下桁数が表示されていない書式指定子を使用できます。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The Foreach Statement Inside a Command Pipeline When Foreach appears in a command pipeline, Windows PowerShell uses the foreach alias, which calls the ForEach-Object command.</source>
          <target state="translated">Windows PowerShell foreach エイリアスは、Foreach-object コマンドの呼び出しを使用して、コマンド パイプラインに Foreach ステートメント内のコマンド パイプラインと Foreach が表示されます。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When you use the foreach alias in a command pipeline, you do not include the ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>) syntax as you do with the Foreach statement.</source>
          <target state="translated">コマンド パイプラインで foreach エイリアスを使用するときに含めないようにする、($<ph id="ph1">&lt;item&gt;</ph> $<ph id="ph2">&lt;collection&gt;</ph>)、Foreach ステートメントを使用すると構文操作を行います。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is because the prior command in the pipeline provides this information.</source>
          <target state="translated">パイプラインの前のコマンドは、この情報を提供するためです。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline is as follows:</source>
          <target state="translated">コマンド パイプラインで使用すると foreach エイリアスの構文は次のとおりです。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>| foreach {&lt;command_block&gt;}</source>
          <target state="translated">|foreach {&lt; command_block &gt;}</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, the Foreach loop in the following command displays processes whose working set (memory usage) is greater than 20 megabytes (MB).</source>
          <target state="translated">たとえば、次のコマンドでの Foreach ループには、プロセスのワーキング セット (メモリ使用量) が 20 mb より大きいが表示されます。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The Get-Process command gets all of the processes on the computer.</source>
          <target state="translated">Get-Process コマンドは、コンピューター上のすべてのプロセスを取得します。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The Foreach alias performs the commands in the script block on each process in sequence.</source>
          <target state="translated">Foreach はエイリアス、シーケンスで、各プロセスのスクリプト ブロックでコマンドを実行します。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The IF statement selects processes with a working set (WS) greater than 20 megabytes.</source>
          <target state="translated">IF ステートメントでは、20 メガバイトを超えるワーキング セット (WS) を使ってプロセスを選択します。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Write-Host cmdlet writes the name of the process followed by a colon.</source>
          <target state="translated">Write-host コマンドレットは、コロンの後にプロセスの名前を書き込みます。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It divides the working set value, which is stored in bytes by 1 megabyte to get the working set value in megabytes.</source>
          <target state="translated">ワーキング セットの値をメガバイト単位で取得する 1 メガバイトでバイトで格納される、ワーキング セット値を除算します。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Then it converts the result from a double to a string.</source>
          <target state="translated">その結果を変換 double 型の値から文字列にします。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It displays the value as a fixed point number with zero decimals (F0), a space separator (" "), and then "MB".</source>
          <target state="translated">値ゼロ 10 進数 (F0)、空白区切りと固定小数点数として表示されます ("") とし、"MB"です。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Write-Host "Processes with working sets greater than 20 MB."</source>
          <target state="translated">Write-host [プロセス ワーキング セットの 20 MB を超えると"</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Get-Process | foreach { if ($_.WS -gt 20MB) { Write-Host $.name ": " ($.WS/1MB).ToString("F0") MB -Separator ""} }</source>
          <target state="translated">Get-process |foreach {場合 ($_ です。WS-gt 20 MB) {Write-host $.name":"($ です。WS/1MB)。ToString("F0") MB の区切り記号""}}</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks.</source>
          <target state="translated">Foreach では、最初のコマンド ブロック、中間コマンドのブロック、および最後のコマンド ブロック エイリアスもサポートします。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.</source>
          <target state="translated">最初と最後のコマンド ブロックは 1 回実行し、Foreach ループ コレクションまたは配列をステップ実行するたびに、中間のコマンド ブロックが実行されます。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline with a beginning, middle, and ending set of command blocks is as follows:</source>
          <target state="translated">コマンド ブロックの先頭、ミドル ネーム、および終了セット コマンド パイプラインで使用すると foreach エイリアスの構文は次のとおりです。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>| foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>}{<ph id="ph2">&lt;middle
command_block&gt;</ph>}{<ph id="ph3">&lt;ending command_block&gt;</ph>}</source>
          <target state="translated">|foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>} {<ph id="ph2">&lt;middle
command_block&gt;</ph>} {<ph id="ph3">&lt;ending command_block&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of the beginning, middle, and end command blocks.</source>
          <target state="translated">次の例では、先頭、中央、および最後のコマンド ブロックの使用を示します。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach { $fileCount = $directoryCount = 0}{ if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}{ "$directoryCount directories and $fileCount files"}</source>
          <target state="translated">Get-childitem |foreach {$fileCount $directoryCount の = = 0} {場合 ($_ です。PsIsContainer) {$directoryCount:operator++} else {$fileCount + +}} {「$directoryCount ディレクトリと $fileCount ファイル」}</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The beginning block creates and initializes two variables to 0:</source>
          <target state="translated">先頭ブロックを作成し、0 に 2 つの変数を初期化します。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>{$fileCount = $directoryCount = 0}</source>
          <target state="translated">{$fileCount $directoryCount の = = 0}</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The middle block evaluates whether each item returned by Get-ChildItem is a directory or a file:</source>
          <target state="translated">中央のブロックは、Get-childitem によって返される各項目がディレクトリかファイルかどうかを評価します。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>{if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}</source>
          <target state="translated">{場合 ($_ です。PsIsContainer) {$directoryCount:operator++} else {$fileCount + +}}</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If the item that is returned is a directory, the $directoryCount variable is incremented by 1.</source>
          <target state="translated">返される項目がディレクトリである場合は、$directoryCount 変数が 1 ずつインクリメントされます。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If the item is not a directory, the $fileCount variable is incremented by 1.</source>
          <target state="translated">項目は、ディレクトリではなく、$fileCount 変数は 1 ずつインクリメントされます。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The ending block runs after the middle block completes its looping operation and then returns the results of the operation:</source>
          <target state="translated">最後のブロックが実行されます中間のブロックは、ループの操作を完了し、操作の結果を返します。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>{"$directoryCount directories and $fileCount files"}</source>
          <target state="translated">{「$directoryCount ディレクトリと $fileCount ファイル」}</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By using the beginning, middle, and ending command block structure and the pipeline operator, you can rewrite the earlier example to find any files that are greater than 100 KB, as follows:</source>
          <target state="translated">初級、ミドル ネーム、および終了コマンドのブロック構造体と、パイプライン演算子を使用すると、前の例が次のように 100 KB を超えるファイルを検索を書き直すことができます。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach{ $i = 0}{ if ($_.length -gt 100KB) { Write-Host $.name "file size:" ($.length / 1024).ToString("F0") KB $i++ } }{ if ($i -ne 0) { Write-Host Write-Host "$i file(s) over 100 KB in the current directory."</source>
          <target state="translated">Get-childitem |foreach {$i = 0} {場合 ($_.length-gt 100 KB) {Write-host $.name"ファイルのサイズ:"($.length/1024)。ToString("F0") KB $i++}} {場合 ($i-ne 0) {Write-host Write-host「$i ファイルが現在のディレクトリに 100 KB を超える」。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>} else { Write-Host "No files greater than 100 KB in the current directory."}</source>
          <target state="translated">} else {Write-host「ファイルはありません、現在のディレクトリが 100 KB より大きい」}。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example, a function which returns the functions that are used in scripts and script modules, demonstrates how to use the MoveNext method (which works similarly to "skip X" on a For loop) and the Current property of the $foreach variable inside of a foreach script block, even if there are unusually- or inconsistently-spaced function definitions that span multiple lines to declare the function name.</source>
          <target state="translated">次の例では、スクリプトとスクリプト モジュールで使用される関数を返す関数は、関数名の宣言に複数の行にまたがってが異常にか一貫性がないの幅での関数定義がある場合でも、MoveNext メソッド (これは、For ループの「X のスキップ」するには、同様に動作) と、foreach スクリプト ブロックの内部で $foreach 変数の現在のプロパティを使用する方法を示します。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The example also works if there are comments in the functions used in a script or script module.</source>
          <target state="translated">この例では、スクリプトまたはスクリプト モジュールで使用される関数にコメントがある場合でも有効です。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>function Get-FunctionPosition { [CmdletBinding()] [OutputType('FunctionPosition')] param( [Parameter(Position=0, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String[]] $Path</source>
          <target state="translated">関数の Get FunctionPosition {[CmdletBinding()] [OutputType('FunctionPosition')] param ([パラメーター (位置 = 0、必須、ValueFromPipeline、ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String $Path]</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">)です。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>process { try { $filesToProcess = if ($_ -is [System.IO.FileSystemInfo]) {</source>
          <target state="translated">プロセス {ください {$filesToProcess = ($_-[System.IO.FileSystemInfo] は、) {</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>} else { Get-Item -Path $Path } foreach ($item in $filesToProcess) { if ($item.PSIsContainer -or $item.Extension -notin @('.ps1','.psm1')) { continue } $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile($item.FullName,([REF]$tokens),([REF]$errors)) if ($errors) { Write-Warning "File '$($item.FullName)' has $($errors.Count) parser errors."</source>
          <target state="translated">} else {Get-item-パス $Path} foreach ($filesToProcess で $item) {場合 ($item します。PSIsContainer- または $item です。拡張機能のない @('.ps1','.psm1')) {続行} $tokens = $errors $ast を $null に = = [System.Management.Automation.Language.Parser]::ParseFile ($item します。FullName,([REF]$tokens),([REF]$errors)) 場合 ($errors) {Write-warning"ファイル ' $($item.FullName)' が $($errors.Count) パーサー エラー。"</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>} :tokenLoop foreach ($token in $tokens) { if ($token.Kind -ne 'Function') { continue } $position = $token.Extent.StartLineNumber do { if (-not $foreach.MoveNext()) { break tokenLoop } $token = $foreach.Current } until ($token.Kind -in @('Generic','Identifier')) $functionPosition = [pscustomobject]@{ Name = $token.Text LineNumber = $position Path = $item.FullName } Add-Member -InputObject $functionPosition -TypeName FunctionPosition -PassThru } } } catch { throw } } }</source>
          <target state="translated">}: tokenLoop foreach ($tokens で $token) {場合 ($token します。Kind-ne 'Function') {続行} $position = $token です。Extent.StartLineNumber は {場合 (-$foreach されません。MoveNext()) {中断 tokenLoop} $token = $foreach です。現在} まで ($token します。Kind - @('Generic','Identifier')) $functionPosition で [pscustomobject] = @{名前 = $token です。テキスト LineNumber $position パスの = = $item です。FullName} Add-member InputObject $functionPosition TypeName FunctionPosition-passthru}}} catch {throw}}}</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">関連項目</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables about_If Foreach-Object</source>
          <target state="translated">about_Automatic_Variables about_If Foreach-object</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>