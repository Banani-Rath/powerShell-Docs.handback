<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-56a7a5e" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c3bcf9dc6f70383e971d9c1ae75ec78860111de9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\fundamental\Using-Variables-to-Store-Objects.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5034db062c90997f27524daaf96670de86ec6263</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Using Variables to Store Objects</source>
          <target state="translated">Usar variables para almacenar objetos</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Using Variables to Store Objects</source>
          <target state="translated">Usar variables para almacenar objetos</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Windows PowerShell works with objects.</source>
          <target state="translated">Windows PowerShell funciona con objetos.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you create variables <ph id="ph1">\-</ph> essentially named objects <ph id="ph2">\-</ph> to preserve output to use later.</source>
          <target state="translated">Windows PowerShell permite crear variables (básicamente objetos con nombre) para conservar la salida para usos posteriores.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>If you are used to working with variables in other shells, remember that Windows PowerShell variables are objects, not text.</source>
          <target state="translated">Si está acostumbrado a trabajar con variables en otros shells, recuerde que las variables de Windows PowerShell son objetos, no texto.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Variables are always specified with the initial character $, and can include any alphanumeric characters or the underscore in their names.</source>
          <target state="translated">Las variables siempre se especifican con el carácter inicial $ y pueden incluir cualquier carácter alfanumérico o el carácter de subrayado en sus nombres.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Creating a Variable</source>
          <target state="translated">Crear una variable</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can create a variable by typing a valid variable name:</source>
          <target state="translated">Para crear una variable, puede escribir un nombre de variable válido:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This returns no result because <bpt id="p1">**</bpt>$loc<ept id="p1">**</ept> does not have a value.</source>
          <target state="translated">Esto no devuelve ningún resultado porque <bpt id="p1">**</bpt>$loc<ept id="p1">**</ept> no tiene un valor.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can create a variable and assign it a value in the same step.</source>
          <target state="translated">Puede crear una variable y asignarle un valor en el mismo paso.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Windows PowerShell only creates the variable if it does not exist; otherwise, it assigns the specified value to the existing variable.</source>
          <target state="translated">Windows PowerShell solo crea la variable si no existe; de lo contrario, asigna el valor especificado a la variable existente.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>To store your current location in the variable <bpt id="p1">**</bpt>$loc<ept id="p1">**</ept>, type:</source>
          <target state="translated">Para almacenar su ubicación actual en la variable <bpt id="p1">**</bpt>$loc<ept id="p1">**</ept>, escriba:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>There is no output displayed when you type this command because the output is sent to $loc.</source>
          <target state="translated">No se muestra ninguna salida cuando escribe este comando porque la salida se envía a $loc.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, displayed output is a side effect of the fact that data which is not otherwise directed always gets sent to the screen.</source>
          <target state="translated">En Windows PowerShell, la salida mostrada es un efecto secundario del hecho de que los datos siempre se envíen a la pantalla, si no se indica de otro modo.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Typing $loc will show your current location:</source>
          <target state="translated">Al escribir $loc se mostrará su ubicación actual:</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> to display information about the contents of variables.</source>
          <target state="translated">Puede usar <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> para mostrar información sobre el contenido de las variables.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Piping $loc to Get<ph id="ph1">\-</ph>Member will show you that it is a <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> object, just like the output from Get<ph id="ph2">\-</ph>Location:</source>
          <target state="translated">La canalización de $loc a Get<ph id="ph1">\-</ph>Member mostrará que se trata de un objeto <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept>, al igual que la salida de Get<ph id="ph2">\-</ph>Location:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Manipulating Variables</source>
          <target state="translated">Manipular variables</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Windows PowerShell provides several commands to manipulate variables.</source>
          <target state="translated">Windows PowerShell proporciona varios comandos para manipular variables.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can see a complete listing in a readable form by typing:</source>
          <target state="translated">Para ver una lista completa en un formato legible, escriba:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In addition to the variables you create in your current Windows PowerShell session, there are several system<ph id="ph1">\-</ph>defined variables.</source>
          <target state="translated">Además de las variables que crea en la sesión actual de Windows PowerShell, existen varias variables definidas por el sistema.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">**</bpt>Remove<ph id="ph1">\-</ph>Variable<ept id="p1">**</ept> cmdlet to clear out all of the variables which are not controlled by Windows PowerShell.</source>
          <target state="translated">Puede usar el cmdlet <bpt id="p1">**</bpt>Remove<ph id="ph1">\-</ph>Variable<ept id="p1">**</ept> para borrar todas las variables que no se controlen mediante Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Type the following command to clear all variables:</source>
          <target state="translated">Escriba el siguiente comando para borrar todas las variables:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This will produce the confirmation prompt you see below.</source>
          <target state="translated">Esto generará el mensaje de confirmación que aparece a continuación.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If you then run the <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Variable<ept id="p1">**</ept> cmdlet, you will see the remaining Windows PowerShell variables.</source>
          <target state="translated">Si ejecuta el cmdlet <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Variable<ept id="p1">**</ept>, verá las demás variables de Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Since there is also a variable Windows PowerShell drive, you can also display all Windows PowerShell variables by typing:</source>
          <target state="translated">Puesto que también existe una unidad de Windows PowerShell variable, también puede mostrar todas las variables de Windows PowerShell. Para ello, escriba:</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Using Cmd.exe Variables</source>
          <target state="translated">Usar variables de Cmd.exe</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Although Windows PowerShell is not Cmd.exe, it runs in a command shell environment and can use the same variables available in any environment in Windows.</source>
          <target state="translated">Aunque Windows PowerShell no es Cmd.exe, se ejecuta en un entorno de shell de comandos y puede usar las mismas variables disponibles en cualquier entorno de Windows.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>These variables are exposed through a drive named <bpt id="p1">**</bpt>env<ept id="p1">**</ept>:.</source>
          <target state="translated">Estas variables se exponen a través de una unidad denominada <bpt id="p1">**</bpt>env<ept id="p1">**</ept>:.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You can view these variables by typing:</source>
          <target state="translated">Para ver estas variables, escriba:</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Although the standard variable cmdlets are not designed to work with <bpt id="p1">**</bpt>env:<ept id="p1">**</ept> variables, you can still use them by specifying the <bpt id="p2">**</bpt>env:<ept id="p2">**</ept> prefix.</source>
          <target state="translated">Aunque los cmdlets de variables estándar no están diseñados para trabajar con variables <bpt id="p1">**</bpt>env:<ept id="p1">**</ept>, puede seguir usándolos si especifica el prefijo <bpt id="p2">**</bpt>env:<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For example, to see the operating system root directory, you can use the command<ph id="ph1">\-</ph>shell <bpt id="p1">**</bpt>%SystemRoot%<ept id="p1">**</ept> variable from within Windows PowerShell by typing:</source>
          <target state="translated">Por ejemplo, para ver el directorio raíz del sistema operativo, puede usar la variable <ph id="ph1">\-</ph>%SystemRoot%<bpt id="p1">**</bpt> del shell de comandos en Windows PowerShell. Para ello, escriba:</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can also create and modify environment variables from within Windows PowerShell.</source>
          <target state="translated">También puede crear y modificar variables de entorno desde Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Environment variables accessed from Windows PowerShell conform to the normal rules for environment variables elsewhere in Windows.</source>
          <target state="translated">Las variables de entorno a las que se accede desde Windows PowerShell se ajustan a las reglas habituales para las variables de entorno en cualquier otra ubicación de Windows.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>