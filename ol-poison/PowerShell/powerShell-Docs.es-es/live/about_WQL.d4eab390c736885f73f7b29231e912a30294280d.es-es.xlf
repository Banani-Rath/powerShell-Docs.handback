<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4b4248c351eb33e465bc767b73056ee4a50f01ed</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_WQL.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cba8c5579926ff48036011b055f30e267d90796d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3db30d43b3e70cf5b7eb3abff7fdb721e43fa9b9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_WQL</source>
          <target state="translated">about_WQL</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">cmdlet de PowerShell</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About WQL</source>
          <target state="translated">Acerca de WQL</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_WQL</source>
          <target state="translated">about_WQL</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_WQL</source>
          <target state="translated">about_WQL</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIPCIÓN BREVE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes WMI Query Language (WQL), which can be used to get WMI objects in Windows PowerShell.</source>
          <target state="translated">Describe el lenguaje de consulta de WMI (WQL), que puede usarse para obtener objetos WMI en Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIPCIÓN LARGA</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>WQL is the Windows Management Instrumentation (WMI) query language, which is the language used to get information from WMI.</source>
          <target state="translated">WQL es el lenguaje de consulta de Instrumental de administración de Windows (WMI), que es el idioma que se utiliza para obtener información de WMI.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You are not required to use WQL to perform a WMI query in Windows PowerShell.</source>
          <target state="translated">No tienen que usar WQL para realizar una consulta WMI en Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Instead, you can use the parameters of the Get-WmiObject or Get-CimInstance cmdlets.</source>
          <target state="translated">En su lugar, puede usar los parámetros de los cmdlets Get-WmiObject o Get-CimInstance.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>WQL queries are somewhat faster than standard Get-WmiObject commands and the improved performance is evident when the commands run on hundreds of systems.</source>
          <target state="translated">Las consultas WQL son un poco más rápido que los comandos Get-WmiObject estándar y la mejora de rendimiento es evidente cuando los comandos que se ejecutan en cientos de sistemas.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>However, be sure that the time you spend to write a successful WQL query doesn't outweigh the performance improvement.</source>
          <target state="translated">Sin embargo, asegúrese de que el tiempo que se emplea para escribir una consulta WQL correcta no superan la mejora del rendimiento.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The basic WQL statements you need to use WQL are Select, Where, and From.</source>
          <target state="translated">Las instrucciones WQL básicas que deberá usar WQL son Select, dónde y desde.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>WHEN TO USE WQL</source>
          <target state="translated">CUÁNDO USAR WQL</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>When working with WMI, and especially with WQL, do not forget that you are also using Windows PowerShell.</source>
          <target state="translated">Al trabajar con WMI y especialmente con WQL, no olvide que también se usa Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Often, if a WQL query does not work as expected, it's easier to use a standard Windows PowerShell command than to debug the WQL query.</source>
          <target state="translated">A menudo, si una consulta WQL no funciona según lo esperado, es más fácil usar un comando estándar de Windows PowerShell que para depurar la consulta WQL.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Unless you are returning massive amounts of data from across bandwidth-constrained remote systems, it is rarely productive to spend hours trying to perfect a complicated and convoluted WQL query when there is a perfectly acceptable Windows cmdlet that does the same thing, if a bit more slowly.</source>
          <target state="translated">A menos que se va a devolver grandes cantidades de datos en sistemas remotos con limitaciones de ancho de banda, es poco productivo que pasar horas tratando perfeccionar una consulta WQL complicada e intrincada cuando hay un cmdlet de Windows perfectamente aceptable que hace lo mismo, si un poco más lentamente.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>USING THE SELECT STATEMENT</source>
          <target state="translated">MEDIANTE LA INSTRUCCIÓN SELECT</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A typical WMI query begins with a Select statement that gets all properties or particular properties of a WMI class.</source>
          <target state="translated">Una consulta WMI típica comienza con una instrucción Select que obtiene todas las propiedades o propiedades concretas de una clase WMI.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>To select all properties of a WMI class, use an asterisk (*).</source>
          <target state="translated">Para seleccionar todas las propiedades de una clase WMI, utilice un asterisco (*).</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The From keyword specifies the WMI class.</source>
          <target state="translated">La palabra clave From especifica la clase WMI.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A Select statement has the following format:</source>
          <target state="translated">Una instrucción Select tiene el formato siguiente:</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Select <ph id="ph1">&lt;property&gt;</ph> from &lt;WMI-class&gt;</source>
          <target state="translated">Seleccione <ph id="ph1">&lt;property&gt;</ph> de &lt; clase WMI &gt;</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For example, the following Select statement selects all properties (*) from the instances of the Win32_Bios WMI class.</source>
          <target state="translated">Por ejemplo, la siguiente instrucción Select selecciona todas las propiedades (*) de las instancias de la clase Win32_Bios WMI.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Select * from Win32_Bios</source>
          <target state="translated">Seleccionar * desde Win32_Bios</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To select a particular property of a WMI class, place the property name between the Select and From keywords.</source>
          <target state="translated">Para seleccionar una propiedad determinada de una clase WMI, coloque el nombre de propiedad entre la selección y de palabras clave.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following query selects only the name of the BIOS from the Win32_Bios WMI class.</source>
          <target state="translated">La siguiente consulta selecciona sólo el nombre de la BIOS de la clase Win32_Bios WMI.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The command saves the query in the $queryName variable.</source>
          <target state="translated">El comando guarda la consulta en la variable $queryName.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Select Name from Win32_Bios</source>
          <target state="translated">Seleccione el nombre de Win32_Bios</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To select more than one property, use commas to separate the property names.</source>
          <target state="translated">Para seleccionar más de una propiedad, utilice comas para separar los nombres de propiedad.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following WMI query selects the name and the version of the Win32_Bios WMI class.</source>
          <target state="translated">La siguiente consulta WMI selecciona el nombre y la versión de la clase Win32_Bios WMI.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The command saves the query in the $queryNameVersion variable.</source>
          <target state="translated">El comando guarda la consulta en la variable $queryNameVersion.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Select name, version from Win32_Bios</source>
          <target state="translated">Seleccione el nombre de la versión de Win32_Bios</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>USING THE WQL QUERY</source>
          <target state="translated">UTILIZANDO LA CONSULTA WQL</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>There are two ways to use WQL query in Windows PowerShell command.</source>
          <target state="translated">Hay dos maneras de utilizar la consulta WQL en el comando de Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>-- Use the Get-WmiObject cmdlet -- Use the Get-CimInstance cmdlet -- Use the [wmisearcher] type accelerator.</source>
          <target state="translated">--Utilice el cmdlet Get-WmiObject, Use el Get-CimInstance cmdlet--utilice el Acelerador de tipo [wmisearcher].</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>USING THE GET-WMIOBJECT CMDLET</source>
          <target state="translated">MEDIANTE EL CMDLET GET-WMIOBJECT.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The most basic way to use the WQL query is to enclose it in quotation marks (as a string) and then use the query string as the value of the Query parameter of the Get-WmiObject cmdlet, as shown in the following example.</source>
          <target state="translated">La manera más sencilla de usar la consulta WQL es ponga comillas (como una cadena) y, a continuación, utilizar la cadena de consulta como el valor del parámetro de consulta del cmdlet Get-WmiObject, tal como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Query "Select * from Win32_Bios"</source>
          <target state="translated">PS C: &gt; Get-WmiObject-consulta "selecciona * de Win32_Bios"</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW fabricante (1,36): nombre LENOVO: predeterminado SerialNumber de BIOS del sistema: versión R9FPY3P: LENOVO – 1360</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can also save the WQL statement in a variable and then use the variable as the value of the Query parameter, as shown in the following command.</source>
          <target state="translated">Puede guardar la instrucción WQL en una variable y, a continuación, utilice la variable como el valor del parámetro de consulta, como se muestra en el siguiente comando.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $query = "Select * from Win32_Bios" PS C:&gt; Get-WmiObject –Query $query</source>
          <target state="translated">PS C: &gt; $query = "Seleccionar * de Win32_Bios" PS C: &gt; Get-WmiObject – $query de consulta</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can use either format with any WQL statement.</source>
          <target state="translated">Puede utilizar cualquiera de los formatos con cualquier instrucción WQL.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The following command uses the query in the $queryName variable to get only the name and version properties of the system BIOS.</source>
          <target state="translated">El siguiente comando utiliza la consulta en la variable $queryName para obtener sólo las propiedades de nombre y la versión del BIOS del sistema.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $queryNameVersion = "Select Name, Version from Win32_Bios" PS C:&gt; Get-WmiObject -Query $queryNameVersion</source>
          <target state="translated">PS C: &gt; $queryNameVersion = "Seleccionar nombre y la versión de Win32_Bios" PS C: &gt; Get-WmiObject-$queryNameVersion de consulta</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS Version          : LENOVO - 1360</source>
          <target state="translated">Nombre: Valor predeterminado de versión del BIOS del sistema: LENOVO - 1360</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Remember that you can use the parameters of the Get-WmiObject cmdlet to get the same result.</source>
          <target state="translated">Recuerde que puede usar los parámetros del cmdlet Get-WmiObject para obtener el mismo resultado.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For example, the following command also gets the values of the Name and Version properties of instances of the Win32_Bios WMI class.</source>
          <target state="translated">Por ejemplo, el siguiente comando también obtiene los valores de las propiedades Name y Version de instancias de la clase Win32_Bios WMI.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject –Class Win32_Bios -Property Name, Version</source>
          <target state="translated">PS C: &gt; Get-WmiObject: clase Win32_Bios-nombre de propiedad, versión</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS Version          : LENOVO - 1360</source>
          <target state="translated">Nombre: Valor predeterminado de versión del BIOS del sistema: LENOVO - 1360</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>USING THE GET-CIMINSTANCE CMDLET</source>
          <target state="translated">MEDIANTE EL CMDLET GET-CIMINSTANCE</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, you can use the Get-CimInstance cmdlet to run WQL queries.</source>
          <target state="translated">A partir de Windows PowerShell 3.0, puede usar el cmdlet Get-CimInstance para ejecutar consultas WQL.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Get-CimInstance gets instances of CIM-compliant classes, including WMI classes.</source>
          <target state="translated">Get-CimInstance Obtiene las instancias de clases compatibles con CIM, incluidas las clases WMI.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The CIM cmdlets, introduced Windows PowerShell 3.0, perform the same tasks as the WMI cmdlets.</source>
          <target state="translated">Los cmdlets CIM, presentó Windows PowerShell 3.0, lleve a cabo las mismas tareas que los cmdlets WMI.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The CIM cmdlets comply with WS-Management (WSMan) standards and with the Common Information Model (CIM) standard, which enables the cmdlets to use the same techniques to manage Windows computers and computers that are running other operating systems.</source>
          <target state="translated">Los cmdlets CIM cumplen con los estándares de WS-Management (WSMan) y con el Common Information Model (CIM) estándar, que permite a los cmdlets para utilizar las mismas técnicas para administrar equipos de Windows y equipos que ejecutan otros sistemas operativos.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The following command uses the Get-CimInstance cmdlet to run a WQL query.</source>
          <target state="translated">El siguiente comando usa el cmdlet Get-CimInstance para ejecutar una consulta WQL.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Any WQL query that can be used with Get-WmiObject can also be used with Get-CimInstance.</source>
          <target state="translated">También se puede usar cualquier consulta WQL que puede utilizarse con Get-WmiObject con Get-CimInstance.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-CimInstance -Query "Select * from Win32_Bios"</source>
          <target state="translated">PS C: &gt; Get-CimInstance-consulta "selecciona * de Win32_Bios"</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW fabricante (1,36): nombre LENOVO: predeterminado SerialNumber de BIOS del sistema: versión R9FPY3P: LENOVO – 1360</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Get-CimInstance returns a CimInstance object, instead of the ManagementObject that Get-WmiObject returns, but the objects are quite similar.</source>
          <target state="translated">Get-CimInstance devuelve un objeto CimInstance, en lugar de la ManagementObject devuelve que Get-WmiObject, pero los objetos son bastante similares.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>PS C:&gt;(Get-CimInstance -Query "Select <bpt id="p1">*</bpt> from Win32_Bios").GetType().FullName Microsoft.Management.Infrastructure.CimInstance PS C:&gt;(Get-WmiObject -Query "Select <ept id="p1">*</ept> from Win32_Bios").GetType().FullName System.Management.ManagementObject</source>
          <target state="translated">PS C: &gt; (Get-CimInstance-consulta "Select <bpt id="p1">*</bpt> de Win32_Bios"). GetType(). FullName Microsoft.Management.Infrastructure.CimInstance PS C: &gt; (Get-WmiObject-consulta "Select <ept id="p1">*</ept> de Win32_Bios"). GetType(). FullName System.Management.ManagementObject</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>USING THE [wmisearcher] TYPE ACCELERATOR</source>
          <target state="translated">UTILIZAR EL ACELERADOR de TIPO [wmisearcher]</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The [wmisearcher] type accelerator creates a ManagementObjectSearcher object from a WQL statement string.</source>
          <target state="translated">El Acelerador de tipo [wmisearcher], crea un objeto de ManagementObjectSearcher desde una cadena de la instrucción WQL.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The ManagementObjectSearcher object has many properties and methods, but the most basic method is the Get method, which invokes the specified WMI query and returns the resulting objects.</source>
          <target state="translated">El objeto ManagementObjectSearcher tiene muchas propiedades y métodos, pero el método más básico es el método Get, que invoca la consulta WMI especificada y devuelve los objetos resultantes.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>By using the [wmisearcher], you gain easy access to the ManagementObjectSearcher .NET Framework class.</source>
          <target state="translated">Mediante el uso de la sección [wmisearcher], obtendrá un acceso sencillo a la clase ManagementObjectSearcher .NET Framework.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This lets you query WMI and to configure the way the query is conducted.</source>
          <target state="translated">Esto le permite consultar WMI y configurar la forma en que la consulta se lleva a cabo.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>To use the [wmisearcher] type accelerator:</source>
          <target state="translated">Para utilizar el Acelerador de tipo [wmisearcher]:</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Cast the  WQL string into a ManagementObjectSearcher object.</source>
          <target state="translated">Convierte la cadena WQL en un objeto ManagementObjectSearcher.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Call the Get method of the ManagementObjectSearcher object.</source>
          <target state="translated">Llame al método Get del objeto ManagementObjectSearcher.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, the following command casts the "select all" query, saves the result in the $bios variable, and then calls the Get method of the ManagementObjectSearcher object in the $bios variable.</source>
          <target state="translated">Por ejemplo, el siguiente comando convierte la consulta "Seleccionar todo", guarda el resultado en la variable $bios y, a continuación, llama al método Get del objeto ManagementObjectSearcher en la variable $bios.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $bios = [wmisearcher]"Select * from Win32_Bios" PS C:&gt; $bios.Get()</source>
          <target state="translated">PS C: &gt; $bios = [wmisearcher] "seleccionar * de Win32_Bios" PS C: &gt; $bios. ::Get()</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW fabricante (1,36): nombre LENOVO: predeterminado SerialNumber de BIOS del sistema: versión R9FPY3P: LENOVO – 1360</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>NOTE: Only selected object properties are displayed by default.</source>
          <target state="translated">NOTA: Sólo las propiedades de objetos seleccionados se muestran de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>These properties are defined in the Types.ps1xml file.</source>
          <target state="translated">Estas propiedades se definen en el archivo Types.ps1xml.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can use the [wmisearcher] type accelerator to cast the query or the variable.</source>
          <target state="translated">Puede utilizar el Acelerador de tipo [wmisearcher] para convertir la consulta o la variable.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In the following example, the [wmisearcher] type accelerator is used to cast the variable.</source>
          <target state="translated">En el ejemplo siguiente, el Acelerador de tipo [wmisearcher] se utiliza para convertir la variable.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The result is the same.</source>
          <target state="translated">El resultado es el mismo.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>PS C:&gt; [wmisearcher]$bios = "Select * from Win32_Bios" PS C:&gt; $bios.Get()</source>
          <target state="translated">PS C: &gt; [wmisearcher] $bios = "Seleccionar * de Win32_Bios" PS C: &gt; $bios. ::Get()</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW fabricante (1,36): nombre LENOVO: predeterminado SerialNumber de BIOS del sistema: versión R9FPY3P: LENOVO – 1360</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>When you use the [wmisearcher] type accelerator, it changes the query string into a ManagementObjectSearcher object, as shown in the following commands.</source>
          <target state="translated">Cuando se utiliza el Acelerador de tipo [wmisearcher], cambia la cadena de consulta en un objeto ManagementObjectSearcher, como se muestra en los siguientes comandos.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$a = "Select * from Win32_Bios" PS C:&gt;$a.GetType().FullName System.String</source>
          <target state="translated">PS C: &gt; $a = "seleccionar * de Win32_Bios" PS C: &gt; $a.GetType(). FullName System.String</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$a = [wmisearcher]"Select * from Win32_Bios" PS C:&gt;$a.GetType().FullName System.Management.ManagementObjectSearcher</source>
          <target state="translated">PS C: &gt; $a = [wmisearcher] "seleccionar * de Win32_Bios" PS C: &gt; $a.GetType(). FullName System.Management.ManagementObjectSearcher</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This command format works on any query.</source>
          <target state="translated">Este formato de comando funciona en cualquier consulta.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The following command gets the value of the Name property of the Win32_Bios WMI class.</source>
          <target state="translated">El siguiente comando obtiene el valor de la propiedad Name de la clase Win32_Bios WMI.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $biosname = [wmisearcher]"Select Name from Win32_Bios" PS C:&gt; $biosname.Get()</source>
          <target state="translated">PS C: &gt; $biosname = [wmisearcher] "Seleccionar nombre de Win32_Bios" PS C: &gt; $biosname. ::Get()</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS</source>
          <target state="translated">Nombre: Valor predeterminado sistema BIOS</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>You can perform this operation in a single command, although the command is a bit more difficult to interpret.</source>
          <target state="translated">Puede realizar esta operación en un solo comando, aunque el comando es un poco más difícil de interpretar.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In this format, you use the [wmisearcher] type accelerator to cast the WQL query string to a ManagementObjectSearcher, and then call the Get method on the object -- all in a single command.</source>
          <target state="translated">En este formato, utilice el Acelerador de tipo [wmisearcher] para convertir la cadena de consulta WQL en un ManagementObjectSearcher y, a continuación, llamar al método Get en el objeto, todo ello en un solo comando.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The parentheses () that enclose the casted string direct Windows PowerShell to cast the string before calling the method.</source>
          <target state="translated">Los paréntesis () que incluya la cadena de manera directa de Windows PowerShell para convertir la cadena antes de llamar al método.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>PS C:&gt; ([wmisearcher]"Select name from Win32_Bios").Get()</source>
          <target state="translated">PS C: &gt; ([wmisearcher] "Seleccionar nombre de Win32_Bios"). ::Get()</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS</source>
          <target state="translated">Nombre: Valor predeterminado sistema BIOS</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>USING THE BASIC WQL WHERE STATEMENT</source>
          <target state="translated">USAR WQL BÁSICO DONDE INSTRUCCIÓN</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A Where statement establishes conditions for the data that a Select statement returns.</source>
          <target state="translated">Un archivo donde instrucción establece condiciones para los datos que devuelve una instrucción Select.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The Where statement has the following format:</source>
          <target state="translated">Where instrucción tiene el siguiente formato:</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>where</source>
          <target state="translated">, donde</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>where Name = 'Notepad.exe'</source>
          <target state="translated">WHERE Name = "Notepad.exe"</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The Where statement is used with the Select statement, as shown in the following example.</source>
          <target state="translated">Where instrucción se utiliza con la instrucción Select, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Select * from Win32_Process where Name = 'Notepad.exe'</source>
          <target state="translated">Seleccione * from Win32_Process where Name = "Notepad.exe"</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When using the Where statement, the property name and value must be accurate.</source>
          <target state="translated">Cuando se utiliza Where instrucción, el nombre de propiedad y el valor deben ser precisos.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the Notepad processes on the local computer.</source>
          <target state="translated">Por ejemplo, el comando siguiente obtiene los procesos en el Bloc de notas en el equipo local.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Query "Select * from Win32_Process where name = 'Notepad.exe'"</source>
          <target state="translated">PS C: &gt; Get-WmiObject-consulta "selecciona * from Win32_Process donde name ="Notepad.exe""</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>However, the following command fails, because the process name includes the ".exe" file name extension.</source>
          <target state="translated">Sin embargo, el comando siguiente produce un error, porque el nombre del proceso incluye la extensión de nombre de archivo ".exe".</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Query "Select * from Win32_Process where name = 'Notepad'"</source>
          <target state="translated">PS C: &gt; Get-WmiObject-consulta "selecciona * from Win32_Process donde name = 'El Bloc de notas'"</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>WHERE STATEMENT COMPARISON OPERATORS</source>
          <target state="translated">DONDE LOS OPERADORES DE COMPARACIÓN DE INSTRUCCIÓN</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following operators are valid in a WQL Where statement.</source>
          <target state="translated">Los siguientes operadores son válidos en una instrucción Where de WQL.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Operator    Description</source>
          <target state="translated">Descripción del operador</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>=           Equal !=          Not equal &lt;&gt;          Not equal &lt;           Less than</source>
          <target state="translated">= Igual! = no es igual a &lt;&gt; no igual a &lt; menor que</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>&lt;=          Less than or equal =          Greater than or equal LIKE        Wildcard match IS          Evaluates null ISNOT       Evaluates not null ISA         Evaluates a member of a WMI class</source>
          <target state="translated">&lt; = menor o igual = mayor o igual COMO coincidencia de caracteres comodín ES se evalúa como null ISNOT se evalúa como no null ISA se evalúa como un miembro de una clase WMI</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>There are other operators, but these are the ones used for making comparisons.</source>
          <target state="translated">Hay otros operadores, pero estos son los que se usan para realizar comparaciones.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>For example, the following query selects the Name and Priority properties from processes in the Win32_Process class where the process priority is greater than or equal to 11.</source>
          <target state="translated">Por ejemplo, la siguiente consulta selecciona las propiedades de nombre y la prioridad de procesos en la clase Win32_Process donde la prioridad del proceso es mayor o igual a 11.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The Get-WmiObject cmdlet runs the query.</source>
          <target state="translated">El cmdlet Get-WmiObject ejecuta la consulta.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>$highPriority = "Select Name, Priority from Win32_Process where Priority &gt;= 11" Get-WmiObject -Query $highPriority</source>
          <target state="translated">$highPriority = "Seleccione el nombre de prioridad de Win32_Process donde prioridad &gt; = 11" Get-WmiObject-$highPriority de consulta</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>USING THE WQL OPERATORS IN THE FILTER PARAMETER</source>
          <target state="translated">USO DE LOS OPERADORES DE WQL EN EL PARÁMETRO DE FILTRO</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The WQL operators can also be used in the value of the Filter parameter of the Get-WmiObject or Get-CimInstance cmdlets, as well as in the value of the Query parameters of these cmdlets.</source>
          <target state="translated">Los operadores WQL también pueden utilizarse en el valor del parámetro de filtro de los cmdlets Get-WmiObject o Get-CimInstance, así como en el valor de los parámetros de consulta de estos cmdlets.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the Name and ProcessID properties of the last five processes that have ProcessID values greater than 1004.</source>
          <target state="translated">Por ejemplo, el comando siguiente obtiene las propiedades Name y ProcessID de los últimos cinco procesos que tienen valores ProcessID mayores 1004.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The command uses the Filter parameter to specify the ProcessID condition.</source>
          <target state="translated">El comando utiliza el parámetro de filtro para especificar la condición ProcessID.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Class Win32_Process ` -Property Name, ProcessID -Filter "ProcessID &gt;= 1004" | Sort ProcessID | Select Name, ProcessID -Last 5</source>
          <target state="translated">PS C: &gt; Get-WmiObject-clase Win32_Process'-nombre de propiedad, ProcessID-filtro "ProcessID &gt; = 1004" | Ordenar ProcessID | Seleccione el nombre de ProcessID-últimas 5</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Name                                 ProcessID</source>
          <target state="translated">Nombre ProcessID</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>SROSVC.exe                                4220</source>
          <target state="translated">SROSVC.exe 4220</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>WINWORD.EXE                               4664</source>
          <target state="translated">WINWORD. EXE                               4664</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>TscHelp.exe                               4744 SnagIt32.exe                              4748 WmiPrvSE.exe                              5056</source>
          <target state="translated">TscHelp.exe 4744 SnagIt32.exe 4748 WmiPrvSE.exe 5056</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>USING THE LIKE OPERATOR</source>
          <target state="translated">MEDIANTE EL OPERADOR LIKE</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The Like operator lets you use wildcard characters to filter the results of a WQL query.</source>
          <target state="translated">El operador Like permite utilizar caracteres comodín para filtrar los resultados de una consulta WQL.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Like Operator  Description</source>
          <target state="translated">Como la descripción del operador</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>[]             Character in a range [a-f] or a set of characters [abcdef].</source>
          <target state="translated">Caracteres en un intervalo [a-f] o un juego de caracteres [abcdef] de [].</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The items in a set do not need to be consecutive or listed in alphabetical order.</source>
          <target state="translated">Los elementos de un conjunto no es necesario ser consecutivos o lista en orden alfabético.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>^              Character not in a range [^a-f] or not in a set [^abcdef].</source>
          <target state="translated">^ Carácter no está en un intervalo [^ a-f] o no en un conjunto [^ abcdef].</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The items in a set do not need to be consecutive or listed in alphabetical order.</source>
          <target state="translated">Los elementos de un conjunto no es necesario ser consecutivos o lista en orden alfabético.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>%              A string of zero or more characters</source>
          <target state="translated">% Una cadena de cero o más caracteres</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>              One character. (underscore)    NOTE: To use a literal underscore in a query string, enclose it in square brackets [<ept id="p1">_</ept>].</source>
          <target state="translated"><bpt id="p1">_</bpt>              Un carácter. (carácter de subrayado)    NOTA: Para utilizar un carácter de subrayado literal en una cadena de consulta, escríbalo entre corchetes [<ept id="p1">_</ept>].</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>When the Like operator is used without any wildcard characters or range operators, it behaves like the equality operator (=) and returns objects only when they are an exact match for the pattern.</source>
          <target state="translated">Cuando se utiliza el operador Like sin caracteres comodín ni los operadores de intervalo, se comporta como el operador de igualdad (=) y devuelve objetos solo si son una coincidencia exacta para el modelo.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>You can combine the range operation with the percent wildcard character to create simple, yet powerful filters.</source>
          <target state="translated">Puede combinar la operación de intervalo con el carácter comodín de porcentaje para crear filtros simples, pero muy eficaces.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>LIKE OPERATOR EXAMPLES</source>
          <target state="translated">COMO EJEMPLOS DE OPERADORES</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>EXAMPLE 1: [<ph id="ph1">&lt;range&gt;</ph>] The following commands start Notepad and then search for an instance of the Win32_Process class that has a name that starts with a letter between "H" and "N" (case-insensitive).</source>
          <target state="translated">EJEMPLO 1: [<ph id="ph1">&lt;range&gt;</ph>] los siguientes comandos iniciar Bloc de notas y, a continuación, buscar una instancia de la clase Win32_Process que tiene un nombre que empieza por una letra entre "H" y "N" (entre mayúsculas y minúsculas).</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The query should return any process from Hotpad.exe through Notepad.exe.</source>
          <target state="translated">La consulta debe devolver cualquier proceso de Hotpad.exe a través de Notepad.exe.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Notepad   # Starts Notepad PS C:&gt; $query = "Select * from win32_Process where Name LIKE '[H-N]otepad.exe'" PS C:&gt; Get-WmiObject -Query $query | Select Name, ProcessID</source>
          <target state="translated">PS C: &gt; # el Bloc de notas se inicia el Bloc de notas PS C: &gt; $query = "seleccionar * de win32_Process where nombre LIKE '[H-N] otepad.exe'" PS C: &gt; Get-WmiObject-consultar $query | Seleccione el nombre, ProcessID</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Name                                ProcessID</source>
          <target state="translated">Nombre ProcessID</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>notepad.exe                              1740</source>
          <target state="translated">Notepad.exe 1740</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>EXAMPLE 2: [<ph id="ph1">&lt;range&gt;</ph>] and % The following commands select all process that have a name that begins with a letter between A and P (case-insensitive) followed by zero or more letters in any combination.</source>
          <target state="translated">EJEMPLO 2: [<ph id="ph1">&lt;range&gt;</ph>] y los siguientes comandos de % seleccione todos los procesos que tienen un nombre que comience con una letra entre A y P (entre mayúsculas y minúsculas) seguido de cero o más letras en cualquier combinación.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The Get-WmiObject cmdlet runs the query, the Select-Object cmdlet gets the Name and ProcessID properties, and the Sort-Object cmdlet sorts the results in alphabetical order by name.</source>
          <target state="translated">El cmdlet Get-WmiObject ejecuta la consulta, el cmdlet Select-Object Obtiene las propiedades Name y ProcessID y el cmdlet Sort-Object ordena los resultados en orden alfabético por nombre.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$query = "Select * from win32_Process where name LIKE '[A-P]%'" PS C:&gt;Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID | Sort-Object -Property Name</source>
          <target state="translated">PS C: &gt; $query = "seleccionar * de win32_Process donde nombre LIKE '[A-P] %'" PS C: &gt; Get-WmiObject-consultar $query | Select-Object - nombre de propiedad, ProcessID | Sort-Object-nombre de propiedad</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>EXAMPLE 3: Not in Range (^) The following command gets processes whose names do not begin with any of the following letters:</source>
          <target state="translated">EJEMPLO 3: Fuera del intervalo (^), el siguiente comando obtiene los procesos cuyo nombre comience con cualquiera de las siguientes letras:</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>A, S, W, P, R, C, U, N</source>
          <target state="translated">A, S, W, P, R, C, U, N</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>and followed zero or more letters.</source>
          <target state="translated">y seguido de cero o más letras.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$query = "Select * from win32_Process where name LIKE '[^ASWPRCUN]%'" PS C:&gt;Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID | Sort-Object -Property Name</source>
          <target state="translated">PS C: &gt; $query = "seleccionar * de win32_Process donde nombre COMO ' [^ ASWPRCUN] %'" PS C: &gt; Get-WmiObject-consultar $query | Select-Object - nombre de propiedad, ProcessID | Sort-Object-nombre de propiedad</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>EXAMPLE 4: Any characters -- or none (%) The following commands get processes that have names that begin with "calc".</source>
          <target state="translated">EJEMPLO 4: Caracteres--o ninguno (%) Los siguientes comandos obtienen los procesos que tienen nombres que comienzan con "calc".</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The % symbol in WQL is equivalent to the asterisk (*) symbol in regular expressions.</source>
          <target state="translated">El símbolo % en WQL es equivalente al símbolo de asterisco (*) en las expresiones regulares.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $query = "Select * from win32_Process where Name LIKE 'calc%'" PS C:&gt; Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID</source>
          <target state="translated">PS C: &gt; $query = "seleccionar * de win32_Process donde nombre LIKE '% calc'" PS C: &gt; Get-WmiObject-consultar $query | Select-Object - nombre de propiedad, ProcessID</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Name                               ProcessID</source>
          <target state="translated">Nombre ProcessID</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>calc.exe                                4424</source>
          <target state="translated">Calc.exe 4424</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>EXAMPLE 5: One character (_) The following commands get processes that have names that have the following pattern, "c_lc.exe" where the underscore character represents any one character.</source>
          <target state="translated">EJEMPLO 5: Un carácter (_) los siguientes comandos obtienen los procesos que tienen nombres que tienen el siguiente patrón, "c_lc.exe" donde el carácter de subrayado representa cualquier carácter.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>This pattern matches any name from calc.exe through czlc.exe, or c9lc.exe, but does not match names in which the "c" and "l" are separated by more than one character.</source>
          <target state="translated">Este patrón coincide con cualquier nombre de calc.exe a través de czlc.exe o c9lc.exe, pero no coincide con los nombres en el que están separados por más de un carácter "c" y "l".</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $query = "Select * from Win32_Process where Name LIKE 'c_lc.exe'" PS C:&gt; Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID</source>
          <target state="translated">PS C: &gt; $query = "seleccionar * de Win32_Process donde nombre COMO 'c_lc.exe'" PS C: &gt; Get-WmiObject-consultar $query | Select-Object - nombre de propiedad, ProcessID</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Name                                 ProcessID</source>
          <target state="translated">Nombre ProcessID</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>calc.exe                                  4424</source>
          <target state="translated">Calc.exe 4424</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>EXAMPLE 6: Exact match The following commands get processes named WLIDSVC.exe.</source>
          <target state="translated">EJEMPLO 6: Los siguientes comandos obtienen procesos de coincidencia exacta con el nombre WLIDSVC.exe.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Even though the query uses the Like keyword, it requires an exact match, because the value does not include any wildcard characters.</source>
          <target state="translated">Aunque la consulta usa la palabra clave Like, requiere a una coincidencia exacta, porque el valor no incluye todos los caracteres comodín.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>$query = "Select * from win32_Process where name LIKE 'WLIDSVC.exe'" Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID</source>
          <target state="translated">$query = "seleccionar * de win32_Process donde nombre COMO 'WLIDSVC.exe'" Get-WmiObject-consultar $query | Select-Object - nombre de propiedad, ProcessID</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Name                                 ProcessID</source>
          <target state="translated">Nombre ProcessID</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>WLIDSVC.exe                                84</source>
          <target state="translated">WLIDSVC.exe 84</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>USING THE OR OPERATOR</source>
          <target state="translated">MEDIANTE EL OPERADOR OR (OPERADOR)</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>To specify multiple independent conditions, use the Or keyword.</source>
          <target state="translated">Para especificar varias condiciones independientes, utilice la palabra clave Or.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The Or keyword appears in the Where clause.</source>
          <target state="translated">La palabra clave Or aparece en Where cláusula.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>It performs an inclusive OR operation on two (or more) conditions and returns items that meet any of the conditions.</source>
          <target state="translated">Realiza una operación OR inclusiva en dos (o más) condiciones y devuelve los elementos que cumplen las condiciones.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The Or operator has the following format:</source>
          <target state="translated">El operador Or tiene el formato siguiente:</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> or <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</source>
          <target state="translated">Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> or <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>For example, the following commands get all instances of the Win32_Process WMI class but returns them only if the process name is winword.exe or excel.exe.</source>
          <target state="translated">Por ejemplo, los siguientes comandos de obtener todas las instancias de la clase WMI Win32_Process pero devuelve solo si el nombre del proceso es winword.exe o excel.exe.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_Process where Name = 'winword.exe' or Name = 'excel.exe'" PS C:&gt;Get-WmiObject -Query $q</source>
          <target state="translated">PS C: &gt; $q = "Seleccione * from Win32_Process where Name = 'winword.exe' o nombre = 'excel.exe'" PS C: &gt; Get-WmiObject-$q de consulta</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The Or statement can be used with more than two conditions.</source>
          <target state="translated">Puede utilizarse la instrucción Or con más de dos condiciones.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>In the following query, the Or statement gets Winword.exe, Excel.exe, or Powershell.exe.</source>
          <target state="translated">En la siguiente consulta, la instrucción Or obtiene Winword.exe, Excel.exe o Powershell.exe.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>$q = "Select * from Win32_Process where Name = 'winword.exe' or Name = 'excel.exe' or Name = 'powershell.exe'"</source>
          <target state="translated">$q = "Seleccione * from Win32_Process where Name = 'winword.exe' o nombre = 'excel.exe' o nombre = 'powershell.exe'"</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>USING THE AND OPERATOR</source>
          <target state="translated">MEDIANTE EL OPERADOR Y</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>To specify multiple related conditions, use the And keyword.</source>
          <target state="translated">Para especificar varias condiciones relacionadas, utilice la palabra clave And.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The And keyword appears in the Where clause.</source>
          <target state="translated">La palabra clave And aparece en Where cláusula.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>It returns items that meet all of the conditions.</source>
          <target state="translated">Devuelve los elementos que cumplen las condiciones.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The And operator has the following format:</source>
          <target state="translated">El operador And tiene el formato siguiente:</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> and <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</source>
          <target state="translated">Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> and <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>For example, the following commands get processes that have a name of "Winword.exe" and the process ID of 6512.</source>
          <target state="translated">Por ejemplo, los siguientes comandos obtienen los procesos que tienen el nombre de "Winword.exe" y el identificador de proceso de 6512.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Note that the commands use the Get-CimInstance cmdlet.</source>
          <target state="translated">Tenga en cuenta que los comandos usan el cmdlet Get-CimInstance.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_Process where Name = 'winword.exe' and ProcessID =6512" PS C:&gt; Get-CimInstance -Query $q</source>
          <target state="translated">PS C: &gt; $q = "Seleccione * from Win32_Process where Name = 'winword.exe' y ProcessID = 6512" PS C: &gt; Get-CimInstance-$q de consulta</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>ProcessId        Name             HandleCount      WorkingSetSize   VirtualSize</source>
          <target state="translated">Nombre ProcessId HandleCount WorkingSetSize VirtualSize</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>6512             WINWORD.EXE      768              117170176        633028608</source>
          <target state="translated">6512 WINWORD. EXE 768 117170176 633028608</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>All operators, including the Like operators are valid with the Or and And operators.</source>
          <target state="translated">Todos los operadores, incluidos los operadores Like son válidos con el operador Or y y operadores.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>And, you can combine the Or and And operators in a single query with parentheses that tell Windows PowerShell which clauses to process first.</source>
          <target state="translated">Y puede combinar la operación Or y y operadores en una sola consulta entre paréntesis que indicar a Windows PowerShell que cláusulas procesar primero.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>This command uses the Windows PowerShell continuation character (`) divide the command into two lines.</source>
          <target state="translated">Este comando usa el comando de la división de Windows PowerShell continuación carácter (') en dos líneas.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_Process ` where (Name = 'winword.exe' or Name = 'excel.exe') and HandleCount &gt; 700"</source>
          <target state="translated">PS C: &gt; $q = "seleccionar * desde dónde de Win32_Process (nombre = 'winword.exe' o nombre = 'excel.exe') y HandleCount 700 &gt;"</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-CimInstance -Query $q ProcessId        Name             HandleCount      WorkingSetSize   VirtualSize</source>
          <target state="translated">PS C: &gt; Get-CimInstance-$q ProcessId nombre HandleCount WorkingSetSize VirtualSize de consulta</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>6512             WINWORD.EXE      797              117268480        634425344</source>
          <target state="translated">6512 WINWORD. EXE 797 117268480 634425344</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>9610             EXCEL.EXE        727               38858752        323227648</source>
          <target state="translated">EXCEL 9610. EXE 727 38858752 323227648</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>SEARCHING FOR NULL VALUES</source>
          <target state="translated">BÚSQUEDA DE VALORES NULL</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Searching for null values in WMI is challenging, because it can lead to unpredictable results.</source>
          <target state="translated">Buscar valores null en WMI es un desafío, porque puede provocar resultados imprevisibles.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Null is not zero and it is not equivalent or to an empty string.</source>
          <target state="translated">NULL no es cero y no es equivalente o en una cadena vacía.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Some WMI class properties are initialized and others are not, so a search for null might not work for all properties.</source>
          <target state="translated">Algunas propiedades de la clase WMI se inicializan y otros no lo están, por lo que una búsqueda de null podría no funcionar para todas las propiedades.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>To search for null values, use the Is operator with a value of "null".</source>
          <target state="translated">Para buscar valores null, utilice el operador con un valor "null".</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For example, the following commands get processes that have a null value for the IntallDate property.</source>
          <target state="translated">Por ejemplo, los siguientes comandos de obtienen los procesos que tienen un valor nulo para la propiedad IntallDate.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The commands return many processes.</source>
          <target state="translated">Los comandos devuelven muchos procesos.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_Process where InstallDate is null" PS C:&gt;Get-WmiObject -Query $q</source>
          <target state="translated">PS C: &gt; $q = "seleccionar * de Win32_Process donde InstallDate es null" PS C: &gt; Get-WmiObject-$q de consulta</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>In contrast, the following command, gets user accounts that have a null value for the Description property.</source>
          <target state="translated">En cambio, el comando siguiente, obtiene las cuentas de usuario que tienen un valor null para la propiedad Description.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>This command does not return any user accounts, even though most user accounts do not have any value for the Description property.</source>
          <target state="translated">Este comando no devuelve ninguna cuenta de usuario, aunque la mayoría de las cuentas de usuario no tiene ningún valor para la propiedad Description.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_UserAccount where Description is null" PS C:&gt;Get-WmiObject -Query $q</source>
          <target state="translated">PS C: &gt; $q = "seleccionar * desde Win32_UserAccount donde la descripción es null" PS C: &gt; Get-WmiObject-$q de consulta</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>To find the user accounts that have no value for the Description property, use the equality operator to get an empty string.</source>
          <target state="translated">Para buscar las cuentas de usuario que no tienen ningún valor para la propiedad Description, utilice el operador de igualdad para obtener una cadena vacía.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>To represent the empty string, use two consecutive single quotation marks.</source>
          <target state="translated">Para representar una cadena vacía, utilice dos comillas consecutivas simples.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>$q = "Select * from Win32_UserAccount where Description = '' "</source>
          <target state="translated">$q = "seleccionar * desde Win32_UserAccount donde descripción = ''."</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>USING TRUE OR FALSE</source>
          <target state="translated">USO DE TRUE O FALSE</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>To get Boolean values in the properties of WMI objects, use True and False.</source>
          <target state="translated">Para obtener los valores booleanos en las propiedades de objetos WMI, utilice True y False.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>They are not case sensitive.</source>
          <target state="translated">No distinguen mayúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The following WQL query returns only local user accounts from a domain joined computer.</source>
          <target state="translated">La siguiente consulta WQL devuelve sólo cuentas de usuario local de un equipo unido a un dominio.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_UserAccount where LocalAccount = True" PS C:&gt;Get-CimInstance -Query $q</source>
          <target state="translated">PS C: &gt; $q = "seleccionar * desde Win32_UserAccount donde LocalAccount = True" PS C: &gt; Get-CimInstance-$q de consulta</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>To find domain accounts, use a value of False, as shown in the following example.</source>
          <target state="translated">Para buscar las cuentas de dominio, utilice un valor de False, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_UserAccount where LocalAccount = False" PS C:&gt;Get-CimInstance -Query $q</source>
          <target state="translated">PS C: &gt; $q = "seleccionar * desde Win32_UserAccount donde LocalAccount = False" PS C: &gt; Get-CimInstance-$q de consulta</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>USING THE ESCAPE CHARACTER</source>
          <target state="translated">USAR EL CARÁCTER DE ESCAPE</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>WQL uses the backslash () as its escape character.</source>
          <target state="translated">WQL usa la barra inversa () como carácter de escape.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>This is different from Windows PowerShell, which uses the backtick character (`).</source>
          <target state="translated">Esto es diferente de Windows PowerShell, que utiliza el carácter de acento grave (').</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Quotation marks, and the characters used for quotation marks, often need to be escaped so that they are not misinterpreted.</source>
          <target state="translated">Las comillas y los caracteres utilizados para las comillas, a menudo necesitan ser caracteres de escape para que no se interprete erróneamente.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>To find a user whose name includes a single quotation mark, use a backslash to escape the single quotation mark, as shown in the following command.</source>
          <target state="translated">Para buscar un usuario cuyo nombre incluya una comilla simple, utilice una barra diagonal inversa para anular la comilla simple, como se muestra en el siguiente comando.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_UserAccount where Name = 'Tim O<ph id="ph1">\'</ph>Brian'" PS C:&gt; Get-CimInstance -Query $q Name             Caption          AccountType      SID              Domain</source>
          <target state="translated">PS C: &gt; $q = "seleccionar * desde Win32_UserAccount donde nombre = ' Tim O<ph id="ph1">\'</ph>Brian'" PS C: &gt; Get-CimInstance-consultar $q Name título AccountType SID Domain</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Tim O'Brian      FABRIKAM\TimO    512              S-1-5-21-1457... FABRIKAM</source>
          <target state="translated">TIM cuyo FABRIKAM\TimO 512 S-1-5-21-1457... FABRIKAM</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>In some case, the backslash also needs to be escaped.</source>
          <target state="translated">En algunos casos, la barra diagonal inversa también debe ser de escape.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>For example, the following commands generate an Invalid Query error due to the backslash in the Caption value.</source>
          <target state="translated">Por ejemplo, los siguientes comandos generan un error de consulta no válida debido a la barra diagonal inversa en el valor de título.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_UserAccount where Caption = 'Fabrikam\TimO'" PS C:&gt; Get-CimInstance -Query $q Get-CimInstance : Invalid query At line:1 char:1</source>
          <target state="translated">PS C: &gt; $q = "seleccionar * desde Win32_UserAccount donde el título = 'Fabrikam\TimO'" PS C: &gt; Get-CimInstance-consultar $q Get-CimInstance: la consulta no válida en línea: 1 char: 1</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Get-CimInstance -Query $q</source>
          <target state="translated">Get-CimInstance-$q de consulta</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~~~~~~~</source>
          <target state="translated">+! INCLUIR [] ~ ~ ~</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>CategoryInfo          : InvalidArgument: (:) [Get-CimInstance], CimException</source>
          <target state="translated">CategoryInfo: InvalidArgument: (:) [Get-CimInstance] CimException</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>FullyQualifiedErrorId : HRESULT 0x80041017,Microsoft.Management.Infrastructure.CimCmdlets</source>
          <target state="translated">FullyQualifiedErrorId: HRESULT 0x80041017,Microsoft.Management.Infrastructure.CimCmdlets</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>To escape the backslash, use a second backslash character, as shown in the following command.</source>
          <target state="translated">Para salir de la barra diagonal inversa, use una segunda barra diagonal inversa, como se muestra en el siguiente comando.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_UserAccount where Caption = 'Fabrikam\TimO'" PS C:&gt; Get-CimInstance -Query $q</source>
          <target state="translated">PS C: &gt; $q = "seleccionar * desde Win32_UserAccount donde el título = 'Fabrikam\TimO'" PS C: &gt; Get-CimInstance-$q de consulta</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">VEA TAMBIÉN</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>about_Escape_Characters about_Quoting_Rules about_WMI about_WMI_Cmdlets</source>
          <target state="translated">about_Escape_Characters about_Quoting_Rules about_WMI about_WMI_Cmdlets</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>