<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9e3678c50582d25cf0c15d13ad31c9a5f012b40e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Splatting.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e36ef81e5150035ee958828a7d6d78c0c3d9bdec</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ae441651a33a38fb6adb54d944f2fdf31e5766d7</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">cmdlet de PowerShell</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Splatting</source>
          <target state="translated">Acerca de expansión</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Splatting</source>
          <target state="translated">about_Splatting</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIPCIÓN BREVE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how to use splatting to pass parameters to commands in Windows PowerShell.</source>
          <target state="translated">Describe cómo usar la expansión para pasar parámetros a los comandos de Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIPCIÓN LARGA</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>[This topic was contributed by Rohn Edwards of Gulfport, Mississippi, a system administrator and the winner of the Advanced Division of the 2012 Scripting Games.</source>
          <target state="translated">[Este tema se ha aportado por Rohn Edwards de Gulfport, Mississippi, un administrador del sistema y el ganador de la división avanzada de los juegos de Scripting de 2012.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Revised for Windows PowerShell 3.0.]</source>
          <target state="translated">Revisado para Windows PowerShell 3.0.]</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Splatting is a method of passing a collection of parameter values to a command as unit.</source>
          <target state="translated">Expansión es un método de pasar una colección de valores de parámetro para un comando como unidad.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Windows PowerShell associates each value in the collection with a command parameter.</source>
          <target state="translated">Windows PowerShell asocia cada valor de la colección con un parámetro de comando.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Splatted parameter values are stored in named splatting variables, which look like standard variables, but begin with an At symbol (@) instead of a dollar sign ($).</source>
          <target state="translated">Los valores de parámetro Splatted se almacenan en variables de expansión con nombre, que son similares a variables estándar, pero comienzan con un símbolo de At (@) en lugar de un signo de dólar ($).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The At symbol tells Windows PowerShell that you are passing a collection of values, instead of a single value.</source>
          <target state="translated">El símbolo de At indica a Windows PowerShell que está pasando una colección de valores, en lugar de un solo valor.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Splatting makes your commands shorter and easier to read.</source>
          <target state="translated">Expansión hace que los comandos más cortos y más fáciles de leer.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can re-use the splatting values in different command calls and use splatting to pass parameter values from the $PSBoundParameters automatic variable to other scripts and functions.</source>
          <target state="translated">Puede volver a utilizar los valores de expansión en llamadas de comandos diferente y usar la expansión para pasar valores de parámetro de la variable automática $PSBoundParameters a otros scripts y funciones.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, you can also use splatting to represent all parameters of a command.</source>
          <target state="translated">A partir de Windows PowerShell 3.0, también puede utilizar expansión para representar todos los parámetros de un comando.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">SINTAXIS</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To provide parameter values for positional parameters, in which parameter names are not required, use the array syntax.</source>
          <target state="translated">Para proporcionar los valores de parámetro para los parámetros posicionales, los nombres de parámetro que no son necesarios, use la sintaxis de la matriz.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To provide parameter name and value pairs, use the hash table syntax.</source>
          <target state="translated">Para proporcionar pares de nombre y valor de parámetro, use la sintaxis de la tabla hash.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The splatted value can appear anywhere in the parameter list.</source>
          <target state="translated">El valor de splatted puede aparecer en cualquier parte en la lista de parámetros.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>When splatting, you do not need to use a hash table or an array to pass all parameters.</source>
          <target state="translated">Cuando expansión, no es necesario utilizar una tabla hash o matriz para pasar todos los parámetros.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You may pass some parameters by using splatting and pass others by position or by parameter name.</source>
          <target state="translated">Se pueden pasar algunos parámetros mediante el uso de expansión y otros por posición o por nombre de parámetro.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Also, you can splat multiple objects in a single command just so you pass no more than one value for each parameter.</source>
          <target state="translated">También puede lámina varios objetos en un único comando para pasar no más de un valor para cada parámetro.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH HASH TABLES</source>
          <target state="translated">EXPANSIÓN CON TABLAS HASH</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use a hash table to splat parameter name and value pairs.</source>
          <target state="translated">Utilice una tabla hash para los pares de nombre y valor de parámetro lámina.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can use this format for all parameter types, including positional and named parameters and switch parameters.</source>
          <target state="translated">Puede usar este formato para todos los tipos de parámetro, incluidos los parámetros posicionales y con nombre y parámetros de modificador.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">Los ejemplos siguientes compara dos comandos Copy-Item que copie el archivo Test.txt en el archivo Test2.txt en el mismo directorio.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are included.</source>
          <target state="translated">El primer ejemplo utiliza el formato tradicional en el parámetro que se incluyen los nombres.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Copy-Item -Path "test.txt" -Destination "test2.txt" -WhatIf</source>
          <target state="translated">Copy-Item - Path "test.txt"-"test2.txt" - WhatIf de destino</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The second example uses hash table splatting.</source>
          <target state="translated">El segundo ejemplo utiliza la expansión de la tabla de hash.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter-name and parameter-value pairs and stores it in the $HashArguments variable.</source>
          <target state="translated">El primer comando crea una tabla hash del nombre de parámetro y valor del parámetro pares y lo almacena en la variable $HashArguments.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The second command uses the $HashArguments variable in a command with splatting.</source>
          <target state="translated">El segundo comando usa la variable $HashArguments en un comando de expansión.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The At symbol (@HashArguments) replaces the dollar sign ($HashArguments) in the command.</source>
          <target state="translated">El símbolo de At (@HashArguments) reemplaza el signo de dólar ($HashArguments) en el comando.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To provide a value for the WhatIf switch parameter, use $True or $False.</source>
          <target state="translated">Para proporcionar un valor para el parámetro de modificador WhatIf, utilice $True o $False.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$HashArguments = @{ Path = "test.txt"; Destination = "test2.txt"; WhatIf = $true } PS C:&gt;Copy-Item @HashArguments</source>
          <target state="translated">PS C: &gt; $HashArguments = @{ruta de acceso = "test.txt"; Destino = "test2.txt"; WhatIf = $true} PS C: &gt; @HashArguments Copy-Item</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note: In the first command, the At symbol (@) indicates a hash table, not a splatted value.</source>
          <target state="translated">Nota: en el primer comando, al símbolo (@) indica una tabla hash, no un valor de splatted.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The syntax for hash tables in Windows PowerShell is: @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>; …}</source>
          <target state="translated">La sintaxis de tablas hash en Windows PowerShell es: @{ <ph id="ph1">&lt;name&gt;=&lt;value&gt;</ph>; <ph id="ph2">&lt;name&gt;=&lt;value&gt;</ph>;...}</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>SPLATTING WITH ARRAYS</source>
          <target state="translated">EXPANSIÓN CON MATRICES</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Use an array to splat values for positional parameters, which do not require parameter names.</source>
          <target state="translated">Utilice una matriz de valores lámina para parámetros posicionales, que no requieren nombres de parámetro.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The values must be in position-number order in the array.</source>
          <target state="translated">Los valores deben estar en orden de número de posición de la matriz.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The following examples compare two Copy-Item commands that copy the Test.txt file to the Test2.txt file in the same directory.</source>
          <target state="translated">Los ejemplos siguientes compara dos comandos Copy-Item que copie el archivo Test.txt en el archivo Test2.txt en el mismo directorio.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The first example uses the traditional format in which parameter names are omitted.</source>
          <target state="translated">El primer ejemplo utiliza el formato tradicional en el que se omiten los nombres de parámetro.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The parameter values appear in position order in the command.</source>
          <target state="translated">Los valores de parámetro aparecen en orden de posición en el comando.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Copy-Item "test.txt" "test2.txt" -WhatIf</source>
          <target state="translated">Copy-Item "test2.txt" - WhatIf "test.txt"</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The second example uses array splatting.</source>
          <target state="translated">El segundo ejemplo utiliza la expansión de matriz.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The first command creates an array of the parameter values and stores it in the $ArrayArguments variable.</source>
          <target state="translated">El primer comando crea una matriz de los valores de parámetro y lo almacena en la variable $ArrayArguments.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The values are in position order in the array.</source>
          <target state="translated">Los valores están en orden de posición en la matriz.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The second command uses the $ArrayArguments variable in a command in splatting.</source>
          <target state="translated">El segundo comando usa la variable $ArrayArguments en un comando en expansión.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The At symbol (@ArrayArguments) replaces the dollar sign ($ArrayArguments) in the command.</source>
          <target state="translated">El símbolo de At (@ArrayArguments) reemplaza el signo de dólar ($ArrayArguments) en el comando.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$ArrayArguments = "test.txt", "test2.txt" PS C:&gt;Copy-Item @ArrayArguments -WhatIf</source>
          <target state="translated">PS C: &gt; $ArrayArguments = "test.txt", "test2.txt" PS C: &gt; Copy-Item @ArrayArguments - WhatIf</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">EJEMPLOS</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This example shows how to re-use splatted values in different commands.</source>
          <target state="translated">Este ejemplo muestra cómo volver a utilizar los valores de splatted en comandos diferentes.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The commands in this example use the Write-Host cmdlet to write messages to the host program console.</source>
          <target state="translated">Los comandos en este ejemplo usan el cmdlet Write-Host para escribir mensajes en la consola del programa host.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It uses splatting to specify the foreground and background colors.</source>
          <target state="translated">Expansión utiliza para especificar los colores de primer y segundo plano.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To change the colors of all commands, just change the value of the $Colors variable.</source>
          <target state="translated">Para cambiar los colores de todos los comandos, cambie el valor de la variable $Colors.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The first command creates a hash table of parameter names and values and stores the hash table in the $Colors variable.</source>
          <target state="translated">El primer comando crea una tabla hash de valores y nombres de parámetro y almacena en la tabla hash en la variable $Colors.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>$Colors = @{ForegroundColor = "black" BackgroundColor = "white"}</source>
          <target state="translated">$Colors = @{ForegroundColor = "black" BackgroundColor = "white"}</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The second and third commands use the $Colors variable for splatting in a Write-Host command.</source>
          <target state="translated">El segundo y tercer comando use la variable $Colors para expansión en un comando Write-Host.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To use the $Colors variable, replace the dollar sign ($Colors) with an At symbol (@Colors).</source>
          <target state="translated">Para usar la variable $Colors, reemplace el signo de dólar ($Colors) con un símbolo de At (@Colors).</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Write a message with the colors in $Colors Write-Host "This is a test."</source>
          <target state="translated">Escribir un mensaje con los colores en $Colors Write-Host "Es una prueba".</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>@Colors</source>
          <target state="translated">@Colors</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Write second message with same colors.</source>
          <target state="translated">Escribir el segundo mensaje con los mismos colores.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The position of splatted hash table does not matter.</source>
          <target state="translated">La posición de la tabla de hash splatted no importa.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Write-Host @Colors "This is another test."</source>
          <target state="translated">@Colors Write-Host "Es otra prueba".</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This example shows how to forward their parameters to other commands by using splatting and the $PSBoundParameters automatic variable.</source>
          <target state="translated">Este ejemplo muestra cómo enviar sus parámetros para otros comandos mediante la variable automática de $PSBoundParameters y de expansión.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The $PSBoundParameters automatic variable is a dictionary (System.Collections.Generic.Dictionary) that contains all of the parameter names and values that are used when a script or function is run.</source>
          <target state="translated">La variable automática de $PSBoundParameters es un diccionario (System.Collections.Generic.Dictionary) que contiene todos los nombres de parámetro y valores que se utilizan cuando se ejecuta un script o una función.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the following example, we use the $PSBoundParameters variable to forward the parameters values passed to a script or function from Test2 function to the Test1 function.</source>
          <target state="translated">En el ejemplo siguiente, se utiliza el $PSBoundParameters variable para reenviar los valores de parámetros se pasa a un script o una función de Test2 función a la función Test1.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Both calls to the Test1 function from Test2 use splatting.</source>
          <target state="translated">Ambas llamadas a la función Test1 de Test2 usan la expansión.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>function Test1 { param($a, $b, $c)</source>
          <target state="translated">función Test1 {param ($a y $b, $c)</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>$a $b $c }</source>
          <target state="translated">$a $b $c}</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>function Test2 { param($a, $b, $c)</source>
          <target state="translated">función Test2 {param ($a y $b, $c)</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $a, $b, and $c.</source>
          <target state="translated">Llame a la función Test1 con $a y $b y $c.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Test1 @PsBoundParameters</source>
          <target state="translated">Test1 @PsBoundParameters</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Call the Test1 function with $b and $c, but not with $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") | Out-Null Test1 @LimitedParameters }</source>
          <target state="translated">Llame a la función Test1 con $b y $c, pero no con $a $LimitedParameters = $PSBoundParameters $LimitedParameters.Remove("a") | Out-Null Test1 @LimitedParameters}</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Test2 -a 1 -b 2 -c 3</source>
          <target state="translated">PS C: &gt; Test2 - a 1 -b - 2c 3</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>SPLATTING COMMAND PARAMETERS</source>
          <target state="translated">PARÁMETROS DE COMANDO DE EXPANSIÓN</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use splatting to represent the parameters of a command.</source>
          <target state="translated">Puede usar la expansión para representar los parámetros de un comando.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This technique is useful when you are creating a proxy function, that is, a function that calls another command.</source>
          <target state="translated">Esta técnica es útil cuando se crea una función de servidor proxy, es decir, una función que llama a otro comando.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This feature is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">Esta característica se introdujo en Windows PowerShell 3.0.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>To splat the parameters of a command, use @Args to represent the command parameters.</source>
          <target state="translated">Para lámina los parámetros de un comando, utilice @Args para representar los parámetros del comando.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This technique is easier than enumerating command parameters and it works without revision even if the parameters of the called command change.</source>
          <target state="translated">Esta técnica es más fácil que enumere los parámetros del comando y funciona sin revisiones incluso si cambian los parámetros del comando llamado.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The feature uses the $Args automatic variable, which contains all unassigned parameter values.</source>
          <target state="translated">La característica utiliza la variable automática $Args, que contiene todos los valores de parámetro sin asignar.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, the following function calls the Get-Process cmdlet.</source>
          <target state="translated">Por ejemplo, la siguiente función llama el cmdlet Get-Process.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In this function, @Args represents all of the parameters of the Get-Process cmdlet.</source>
          <target state="translated">En esta función @Args representa todos los parámetros del cmdlet Get-Process.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>function Get-MyProcess { Get-Process @Args }</source>
          <target state="translated">función Get-MyProcess {Get-Process @Args}</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>When you use the Get-MyProcess function, all unassigned parameters and parameter values are passed to @Args, as shown in the following commands.</source>
          <target state="translated">Cuando utiliza la función Get-MyProcess, todos los parámetros sin asignar y valores de los parámetros se pasan a @Args, como se muestra en los siguientes comandos.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell</source>
          <target state="translated">PS C: &gt; Get-MyProcess-nombre de PowerShell</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">Controla ProcessName NPM(K) PM(K) WS(K) VM(M) ID de CPU.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>463      46   225484     237196   719    15.86   3228 powershell</source>
          <target state="translated">463 46 225484 237196 719 15.86 3228 powershell</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyProcess -Name PowerShell_Ise -FileVersionInfo</source>
          <target state="translated">PS C: &gt; Get-MyProcess-nombre PowerShell_Ise - FileVersionInfo</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>ProductVersion   FileVersion      FileName</source>
          <target state="translated">Nombre de archivo ProductVersion FileVersion</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>6.2.9200.16384   6.2.9200.1638... C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</source>
          <target state="translated">6.2.9200.16384   6.2.9200.1638... C:\Windows\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You can use @Args in a function that has explicitly declared parameters.</source>
          <target state="translated">Puede usar @Args en una función que se declara explícitamente los parámetros.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can use it more than once in a function, but all parameters that you enter are passed to all instances of @Args, as shown in the following example.</source>
          <target state="translated">Puede usar más de una vez en una función, pero todos los parámetros que especifique se pasan todas las instancias de @Args, como se muestra en el ejemplo siguiente.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>function Get-MyCommand { Param ([switch]$P, [switch]$C) if ($P) { Get-Process @Args } if ($C) { Get-Command @Args } }</source>
          <target state="translated">función Get MyCommand {Param ([modificador] $p, $C [modificador]) si ($p) {Get-Process @Args} si ($C) {Get-Command @Args}}</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-MyCommand -P -C -Name PowerShell</source>
          <target state="translated">PS C: &gt; Get-MyCommand - P -C-nombre de PowerShell</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)      WS(K) VM(M)   CPU(s)     Id ProcessName</source>
          <target state="translated">Controla ProcessName NPM(K) PM(K) WS(K) VM(M) ID de CPU.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>408      28    75568      83176   620     1.33   1692 powershell</source>
          <target state="translated">408 28 75568 83176 620 1,33 1692 powershell</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Path               : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Extension          : .exe Definition         : C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe Visibility         : Public OutputType         : {System.String} Name               : powershell.exe CommandType        : Application ModuleName         : Module             : RemotingCapability : PowerShell Parameters         : ParameterSets      : HelpUri            : FileVersionInfo    : File:             C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</source>
          <target state="translated">Ruta de acceso: Extensión C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe: definición .exe: visibilidad C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe: OutputType pública: {System.String} nombre: powershell.exe CommandType: aplicación ModuleName: módulo: RemotingCapability: parámetros de PowerShell: ParameterSets: HelpUri: FileVersionInfo: archivo: C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">VEA TAMBIÉN</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>about_Arrays about_Automatic_Variables about_Hash_Tables about_Parameters</source>
          <target state="translated">about_Arrays about_Automatic_Variables about_Hash_Tables about_Parameters</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>