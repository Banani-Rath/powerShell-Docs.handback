<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">128b330f029b09d6d15ebc5a1cda9c52bf275293</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\ForEach-Object.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">879467f5044fb17e5a8f5454d8866973d9eb2aff</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c6c78fd8c27534de8e0cc7bbe70b148ad56501c1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell 指令程式</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>ForEach-Object</source>
          <target state="translated">ForEach-Object</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>ForEach-Object</source>
          <target state="translated">ForEach-Object</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>SYNOPSIS</source>
          <target state="translated">概要</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Performs an operation against each item in a collection of input objects.</source>
          <target state="translated">針對輸入物件集合中的每個項目執行操作。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">語法</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ScriptBlockSet (Default)</source>
          <target state="translated">ScriptBlockSet （預設值）</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>PropertyAndMethodSet</source>
          <target state="translated">PropertyAndMethodSet</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>DESCRIPTION</source>
          <target state="translated">描述</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet performs an operation on each item in a collection of input objects.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet 會執行輸入物件的集合中的每個項目上的作業。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The input objects can be piped to the cmdlet or specified by using the <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parameter.</source>
          <target state="translated">可以使用管線傳送至 cmdlet 或使用指定的輸入的物件 <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> 參數。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 3.0, there are two different ways to construct a <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> command.</source>
          <target state="translated">從 Windows PowerShell 3.0 開始，有兩種不同的方式來建構 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 命令。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Script block<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>指令碼區塊<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can use a script block to specify the operation.</source>
          <target state="translated">您可以使用指令碼區塊來指定操作。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Within the script block, use the $_ variable to represent the current object.</source>
          <target state="translated">在指令碼區塊內，請使用 $_ 變數來代表目前的物件。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The script block is the value of the <bpt id="p1">*</bpt>Process<ept id="p1">*</ept> parameter.</source>
          <target state="translated">指令碼區塊是值 <bpt id="p1">*</bpt>程序<ept id="p1">*</ept> 參數。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The script block can contain any Windows PowerShell script.</source>
          <target state="translated">指令碼區塊可以包含任何 Windows PowerShell 指令碼。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the value of the <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> property of each process on the computer.</source>
          <target state="translated">例如，下列命令會取得的值 <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> 的電腦上的每個處理序的屬性。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Operation statement<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>運算陳述式<ept id="p1">**</ept>。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You can also write an operation statement, which is much more like natural language.</source>
          <target state="translated">您也可以撰寫較像自然語言操作陳述式。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can use the operation statement to specify a property value or call a method.</source>
          <target state="translated">您可以使用操作陳述式來指定屬性值或呼叫方法。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Operation statements were introduced in Windows PowerShell 3.0.</source>
          <target state="translated">操作陳述式是在 Windows PowerShell 3.0 中導入。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For example, the following command also gets the value of the <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> property of each process on the computer.</source>
          <target state="translated">例如，下列命令也會取得的值 <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> 的電腦上的每個處理序的屬性。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When using the script block format, in addition to using the script block that describes the operations that are performed on each input object, you can provide two additional script blocks.</source>
          <target state="translated">使用指令碼區塊格式時，除了使用描述在每個輸入物件上執行之操作的指令碼區塊之外，您還可以提供兩個額外的指令碼區塊。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The Begin script block, which is the value of the <bpt id="p1">*</bpt>Begin<ept id="p1">*</ept> parameter, runs before this cmdlet processes the first input object.</source>
          <target state="translated">Begin 指令碼區塊中，這是值的 <bpt id="p1">*</bpt>開始<ept id="p1">*</ept> 參數，執行這個指令程式會處理第一個輸入的物件之前執行。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The End script block, which is the value of the <bpt id="p1">*</bpt>End<ept id="p1">*</ept> parameter, runs after this cmdlet processes the last input object.</source>
          <target state="translated">結束指令碼區塊，這是值的 <bpt id="p1">*</bpt>結束<ept id="p1">*</ept> 參數，執行這個指令程式會處理的最後一個輸入的物件之後。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">範例</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Example 1: Divide integers in an array</source>
          <target state="translated">範例 1︰ 將整數陣列中</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This command takes an array of three integers and divides each one of them by 1024.</source>
          <target state="translated">此命令會接受三個整數的陣列，並將它們每個都除以 1024。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Example 2: Get the length of all the files in a directory</source>
          <target state="translated">範例 2︰ 取得目錄中的所有檔案的長度</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This command gets the files and directories in the Windows PowerShell installation directory ($pshome) and passes them to the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">此命令會取得 Windows PowerShell 安裝目錄 ($pshome) 中的檔案和目錄，並傳送至 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 指令程式。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If the object is not a directory, the script block gets the name of the file, divides the value of its <bpt id="p1">**</bpt>Length<ept id="p1">**</ept> property by 1024, and adds a space (" ") to separate it from the next entry.</source>
          <target state="translated">如果物件不是目錄，指令碼區塊會取得檔案的名稱、 將值除以其 <bpt id="p1">**</bpt>長度<ept id="p1">**</ept> 屬性除以 1024，並加上一個空格 ("") 將從下一個項目。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The cmdlet uses the <bpt id="p1">**</bpt>PSISContainer<ept id="p1">**</ept> property to determine whether an object is a directory.</source>
          <target state="translated">此指令程式會使用 <bpt id="p1">**</bpt>PSISContainer<ept id="p1">**</ept> 屬性來判斷物件是否為目錄。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Example 3: Operate on the most recent System events</source>
          <target state="translated">範例 3︰ 操作上的最新的系統事件</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This command gets the 1000 most recent events from the System event log and stores them in the $Events variable.</source>
          <target state="translated">此命令從 System 事件記錄檔取得 1000 個最新事件，並將它們儲存在 $Events 變數中。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It then pipes the events to the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">要的事件，然後使用管線傳送 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 指令程式。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>Begin<ept id="p1">*</ept> parameter displays the current date and time.</source>
          <target state="translated"> <bpt id="p1">*</bpt>開始<ept id="p1">*</ept> 參數會顯示目前的日期和時間。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Next, the <bpt id="p1">*</bpt>Process<ept id="p1">*</ept> parameter uses the <bpt id="p2">**</bpt>Out-File<ept id="p2">**</ept> cmdlet to create a text file that is named events.txt and stores the message property of each of the events in that file.</source>
          <target state="translated">下一步] <bpt id="p1">*</bpt>程序<ept id="p1">*</ept> 參數會使用 <bpt id="p2">**</bpt>Out-file<ept id="p2">**</ept> 指令程式可建立名為 events.txt，並將每一個事件的訊息屬性儲存在該檔案中的文字檔案。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Last, the <bpt id="p1">*</bpt>End<ept id="p1">*</ept> parameter is used to display the date and time after all of the processing has completed.</source>
          <target state="translated">最後， <bpt id="p1">*</bpt>結束<ept id="p1">*</ept> 參數用來顯示日期和時間在所有的處理已完成。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Example 4: Change the value of a Registry key</source>
          <target state="translated">範例 4︰ 變更登錄機碼的值</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This command changes the value of the <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> registry entry in all of the subkeys under the HKCU:\Network key to uppercase text.</source>
          <target state="translated">這個命令的值變更 <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> 中所有的子機碼為大寫文字 hkcu: \network 機碼下的登錄項目。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can use this format to change the form or content of a registry entry value.</source>
          <target state="translated">您可以使用這個格式來變更登錄項目值的形式或內容。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Each subkey in the <bpt id="p1">**</bpt>Network<ept id="p1">**</ept> key represents a mapped network drive that will reconnect at logon.</source>
          <target state="translated">在每個子機碼 <bpt id="p1">**</bpt>網路<ept id="p1">**</ept> 索引鍵所代表對應的網路磁碟機將在登入時重新連線。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> entry contains the UNC path of the connected drive.</source>
          <target state="translated"> <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> 項目會包含連線的磁碟機的 UNC 路徑。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For example, if you map the E: drive to <ph id="ph1">\\\\</ph>Server\Share, there will be an E subkey of HKCU:\Network and the value of the <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> registry entry in the E subkey will be <ph id="ph2">\\\\</ph>Server\Share.</source>
          <target state="translated">例如，如果您將對應的 e︰ 磁碟機 <ph id="ph1">\\\\</ph>多，會有 hkcu: \network E 子機碼和值 <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> E 子機碼中的登錄項目會是 <ph id="ph2">\\\\</ph>伺服器。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The command uses the Get-ItemProperty cmdlet to get all of the subkeys of the <bpt id="p1">**</bpt>Network<ept id="p1">**</ept> key and the Set-ItemProperty cmdlet to change the value of the <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> registry entry in each key.</source>
          <target state="translated">此命令使用 Get-itemproperty cmdlet 取得所有的子機碼 <bpt id="p1">**</bpt>網路<ept id="p1">**</ept> 索引鍵和 Set-itemproperty cmdlet 變更的值 <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> 每個機碼的登錄項目。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Set-ItemProperty<ept id="p1">**</ept> command, the path is the value of the <bpt id="p2">**</bpt>PSPath<ept id="p2">**</ept> property of the registry key.</source>
          <target state="translated">在 <bpt id="p1">**</bpt>Set-itemproperty<ept id="p1">**</ept> 命令時，路徑是值 <bpt id="p2">**</bpt>PSPath<ept id="p2">**</ept> 登錄機碼的屬性。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This is a property of the Microsoft .NET Framework object that represents the registry key, not a registry entry.</source>
          <target state="translated">這是 Microsoft.NET Framework 物件，代表登錄機碼，而不登錄項目屬性。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The command uses the <bpt id="p1">**</bpt>ToUpper()<ept id="p1">**</ept> method of the <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> value, which is a string (REG_SZ).</source>
          <target state="translated">此命令會使用 <bpt id="p1">**</bpt>ToUpper()<ept id="p1">**</ept> 方法 <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> 值，也就是字串 (REG_SZ)。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Because <bpt id="p1">**</bpt>Set-ItemProperty<ept id="p1">**</ept> is changing the property of each key, the <bpt id="p2">**</bpt>ForEach-Object<ept id="p2">**</ept> cmdlet is required to access the property.</source>
          <target state="translated">因為 <bpt id="p1">**</bpt>Set-itemproperty<ept id="p1">**</ept> 正在變更的屬性，每個索引鍵， <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> 指令程式，才可存取的屬性。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Example 5: Use the $Null automatic variable</source>
          <target state="translated">範例 5︰ 使用 $Null 自動變數</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This example shows the effect of piping the $Null automatic variable to the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">此範例示範的管線 $Null 自動變數來影響 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 指令程式。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Because Windows PowerShell treats null as an explicit placeholder, the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet generates a value for $Null, just as it does for other objects that you pipe to it.</source>
          <target state="translated">因為 Windows PowerShell 會將 null 視為明確的預留位置， <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 指令程式會產生值為 $Null，就如同您使用管線傳送至其他物件。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information about the $Null automatic variable, see about_Automatic_Variables.</source>
          <target state="translated">如需 $Null 自動變數的詳細資訊，請參閱 about_Automatic_Variables。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Example 6: Get property values</source>
          <target state="translated">範例 6︰ 取得屬性值</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>These commands gets the value of the <bpt id="p1">**</bpt>Path<ept id="p1">**</ept> property of all installed Windows PowerShell modules.</source>
          <target state="translated">這些命令取得的值 <bpt id="p1">**</bpt>路徑<ept id="p1">**</ept> 屬性的所有已安裝的 Windows PowerShell 模組。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>They use the <bpt id="p1">*</bpt>MemberName<ept id="p1">*</ept> parameter to specify the <bpt id="p2">**</bpt>Path<ept id="p2">**</ept> property of modules.</source>
          <target state="translated">他們使用 <bpt id="p1">*</bpt>MemberName<ept id="p1">*</ept> 參數來指定 <bpt id="p2">**</bpt>路徑<ept id="p2">**</ept> 模組的屬性。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The second command is equivalent to the first.</source>
          <target state="translated">第二個命令同等於第一個命令。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> alias of the <bpt id="p2">**</bpt>ForEach-Object<ept id="p2">**</ept> cmdlet and omits the name of the <bpt id="p3">*</bpt>MemberName<ept id="p3">*</ept> parameter, which is optional.</source>
          <target state="translated">它會使用 <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> 別名 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> 指令程式，並省略名稱 <bpt id="p3">*</bpt>MemberName<ept id="p3">*</ept> 參數是選擇性的。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet is very useful for getting property values, because it gets the value without changing the type, unlike the <bpt id="p2">**</bpt>Format<ept id="p2">**</ept> cmdlets or the Select-Object cmdlet, which change the property value type.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 指令程式是對於取得屬性值非常有用，因為它取得的值而不需要變更與不同的型別， <bpt id="p2">**</bpt>格式<ept id="p2">**</ept> 指令程式或變更屬性的 Select-object 指令程式實值型別。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Example 7: Split module names into component names</source>
          <target state="translated">範例 7︰ 將模組名稱分割成元件名稱</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>These commands split two dot-separated module names into their component names.</source>
          <target state="translated">這些命令將兩個以點分隔的模組名稱分割成其元件名稱。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The commands call the <bpt id="p1">**</bpt>Split<ept id="p1">**</ept> method of strings.</source>
          <target state="translated">命令呼叫 <bpt id="p1">**</bpt>分割<ept id="p1">**</ept> 方法的字串。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The three commands use different syntax, but they are equivalent and interchangeable.</source>
          <target state="translated">這三個命令使用不同的語法，但它們是相等的並且可交換使用。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The first command uses the traditional syntax, which includes a script block and the current object operator ($_).</source>
          <target state="translated">第一個命令使用傳統語法，其中包含指令碼區塊和目前物件運算子 ($_)。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It uses the dot syntax to specify the method and parentheses to enclose the delimiter argument.</source>
          <target state="translated">它使用點語法來指定要括住分隔符號引數的方法和括號。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The second command uses the <bpt id="p1">*</bpt>MemberName<ept id="p1">*</ept> parameter to specify the <bpt id="p2">**</bpt>Split<ept id="p2">**</ept> method and the <bpt id="p3">*</bpt>ArgumentName<ept id="p3">*</ept> parameter to identify the dot (".") as the split delimiter.</source>
          <target state="translated">第二個命令會使用 <bpt id="p1">*</bpt>MemberName<ept id="p1">*</ept> 參數來指定 <bpt id="p2">**</bpt>分割<ept id="p2">**</ept> 方法和 <bpt id="p3">*</bpt>ArgumentName<ept id="p3">*</ept> 參數來識別該點 ("。") 為分隔符號。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The third command uses the <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> alias of the <bpt id="p2">**</bpt>Foreach-Object<ept id="p2">**</ept> cmdlet and omits the names of the <bpt id="p3">*</bpt>MemberName<ept id="p3">*</ept> and <bpt id="p4">*</bpt>ArgumentList<ept id="p4">*</ept> parameters, which are optional.</source>
          <target state="translated">第三個命令會使用 <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> 別名 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> 指令程式，並省略名稱 <bpt id="p3">*</bpt>MemberName<ept id="p3">*</ept> 和 <bpt id="p4">*</bpt>ArgumentList<ept id="p4">*</ept> 是選擇性的參數。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The output of these three commands, shown below, is identical.</source>
          <target state="translated">這三個命令的輸出 (如下所示) 完全相同。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Split<ept id="p1">**</ept> is just one of many useful methods of strings.</source>
          <target state="translated"><bpt id="p1">**</bpt>分割<ept id="p1">**</ept> 只是其中一個字串的許多有用的方法。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>To see all of the properties and methods of strings, pipe a string to the Get-Member cmdlet.</source>
          <target state="translated">若要查看的所有屬性和方法的字串，透過管道傳送至 Get-member 指令程式的字串。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>PARAMETERS</source>
          <target state="translated">參數</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>-ArgumentList</source>
          <target state="translated">-ArgumentList</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Specifies an array of arguments to a method call.</source>
          <target state="translated">指定方法呼叫的引數陣列。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This parameter was introduced in Windows PowerShell 3.0.</source>
          <target state="translated">此參數是在 Windows PowerShell 3.0 引進。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>-Begin</source>
          <target state="translated">-開始</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Specifies a script block that runs before this cmdlet processes any input objects.</source>
          <target state="translated">指定執行此指令程式會處理輸入的任何物件之前執行的指令碼區塊。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>-Confirm</source>
          <target state="translated">-Confirm</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Prompts you for confirmation before running the cmdlet.Prompts you for confirmation before running the cmdlet.</source>
          <target state="translated">會提示您進行確認，然後再執行此指令程式。會提示您進行確認，然後再執行此指令程式。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>-End</source>
          <target state="translated">-結束</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Specifies a script block that runs after this cmdlet processes all input objects.</source>
          <target state="translated">指定此指令程式會處理所有輸入的物件後執行的指令碼區塊。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>-InputObject</source>
          <target state="translated">-InputObject</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Specifies the input objects.</source>
          <target state="translated">指定輸入物件。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>ForEach-Object<ept id="p1">*</ept> runs the script block or operation statement on each input object.</source>
          <target state="translated"><bpt id="p1">*</bpt>Foreach-object<ept id="p1">*</ept> 每個輸入物件上執行指令碼區塊或操作陳述式。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Enter a variable that contains the objects, or type a command or expression that gets the objects.</source>
          <target state="translated">輸入包含物件的變數，或輸入可取得物件的命令或運算式。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When you use the <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parameter with <bpt id="p2">**</bpt>ForEach-Object<ept id="p2">**</ept>, instead of piping command results to <bpt id="p3">**</bpt>ForEach-Object<ept id="p3">**</ept>, the <bpt id="p4">*</bpt>InputObject<ept id="p4">*</ept> value is treated as a single object.</source>
          <target state="translated">當您使用 <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> 參數 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept>, ，而不是管道命令結果輸出至 <bpt id="p3">**</bpt>Foreach-object<ept id="p3">**</ept>, 、 <bpt id="p4">*</bpt>InputObject<ept id="p4">*</ept> 值會被視為單一物件。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This is true even if the value is a collection that is the result of a command, such as <ph id="ph1">`-InputObject (Get-Process)`</ph>.</source>
          <target state="translated">這是 true，即使值集合之結果的命令，例如 <ph id="ph1">`-InputObject (Get-Process)`</ph>。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Because <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> cannot return individual properties from an array or collection of objects, we recommend that if you use <bpt id="p2">**</bpt>ForEach-Object<ept id="p2">**</ept> to perform operations on a collection of objects for those objects that have specific values in defined properties, you use <bpt id="p3">**</bpt>ForEach-Object<ept id="p3">**</ept> in the pipeline, as shown in the examples in this topic.</source>
          <target state="translated">因為 <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> 無法傳回個別屬性從陣列或物件的集合，我們建議，如果您使用 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> 上執行作業的物件集合中定義的屬性具有特定值的物件，使用 <bpt id="p3">**</bpt>Foreach-object<ept id="p3">**</ept> 在管線中，如本主題中的範例所示。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>-MemberName</source>
          <target state="translated">-MemberName</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Specifies the property to get or the method to call.</source>
          <target state="translated">指定要取得的屬性或要呼叫的方法。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Wildcard characters are permitted, but work only if the resulting string resolves to a unique value.</source>
          <target state="translated">萬用字元所允許的但產生的字串會解析為唯一的值時，才有作用。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>If, for example, you run <ph id="ph1">`Get-Process | ForEach -MemberName *Name`</ph>, and more than one member exists with a name that contains the string Name, such as the <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Name<ept id="p2">**</ept> properties, the command fails.</source>
          <target state="translated">如果您在執行，例如 <ph id="ph1">`Get-Process | ForEach -MemberName *Name`</ph>, ，並以名稱包含字串的名稱，例如存在多個成員 <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> 和 <bpt id="p2">**</bpt>名稱<ept id="p2">**</ept> 屬性，則命令會失敗。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This parameter was introduced in Windows PowerShell 3.0.</source>
          <target state="translated">此參數是在 Windows PowerShell 3.0 引進。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>-Process</source>
          <target state="translated">同處理序</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Specifies the operation that is performed on each input object.</source>
          <target state="translated">指定在每個輸入物件上執行的操作。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Enter a script block that describes the operation.</source>
          <target state="translated">輸入描述操作的指令碼區塊。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>-RemainingScripts</source>
          <target state="translated">-RemainingScripts</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Specifies all script blocks that are not taken by the <bpt id="p1">*</bpt>Process<ept id="p1">*</ept> parameter.</source>
          <target state="translated">指定不採取的所有指令碼區塊 <bpt id="p1">*</bpt>程序<ept id="p1">*</ept> 參數。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This parameter was introduced in Windows PowerShell 3.0.</source>
          <target state="translated">此參數是在 Windows PowerShell 3.0 引進。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>-WhatIf</source>
          <target state="translated">-WhatIf</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Shows what would happen if the cmdlet runs.</source>
          <target state="translated">顯示執行 Cmdlet 後會發生的情況。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The cmdlet is not run.Shows what would happen if the cmdlet runs.</source>
          <target state="translated">無法執行此指令程式。顯示執行此指令程式會發生什麼事。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The cmdlet is not run.</source>
          <target state="translated">未執行 Cmdlet。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>CommonParameters</source>
          <target state="translated">CommonParameters</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable.</source>
          <target state="translated">這個 cmdlet 支援一般參數:-偵錯、-ErrorAction、-ErrorVariable、-InformationAction-InformationVariable、-OutVariable、-OutBuffer、-PipelineVariable、-Verbose、-WarningAction 以及-WarningVariable。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>For more information, see about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216).</source>
          <target state="translated">如需詳細資訊，請參閱 about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216)。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>INPUTS</source>
          <target state="translated">輸入</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>System.Management.Automation.PSObject</source>
          <target state="translated">System.Management.Automation.PSObject</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>You can pipe any object to this cmdlet.</source>
          <target state="translated">您可以透過管道傳送到此指令程式的任何物件。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>OUTPUTS</source>
          <target state="translated">輸出</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>System.Management.Automation.PSObject</source>
          <target state="translated">System.Management.Automation.PSObject</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>This cmdlet returns objects that are determined by the input.</source>
          <target state="translated">此 cmdlet 會傳回由輸入的物件。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>NOTES</source>
          <target state="translated">附註</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet works much like the <bpt id="p2">**</bpt>Foreach<ept id="p2">**</ept> statement, except that you cannot pipe input to a <bpt id="p3">**</bpt>Foreach<ept id="p3">**</ept> statement.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet 的運作方式很像 <bpt id="p2">**</bpt>Foreach<ept id="p2">**</ept> 陳述式中，不同之處在於您無法透過管道傳送輸入 <bpt id="p3">**</bpt>Foreach<ept id="p3">**</ept> 陳述式。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For more information about the <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> statement, see about_Foreach (http://go.microsoft.com/fwlink/?LinkID=113229) in the Microsoft TechNet library.</source>
          <target state="translated">如需詳細資訊 <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> 陳述式，請參閱在 Microsoft TechNet library 中 about_Foreach (http://go.microsoft.com/fwlink/?LinkID=113229)。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>RELATED LINKS</source>
          <target state="translated">相關的連結</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables</source>
          <target state="translated">about_Automatic_Variables</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>about_Script_Blocks</source>
          <target state="translated">about_Script_Blocks</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Get-ItemProperty</source>
          <target state="translated">Get-itemproperty</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Get-Member</source>
          <target state="translated">Get-Member</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Select-Object</source>
          <target state="translated">Select-Object</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Set-ItemProperty</source>
          <target state="translated">Set-ItemProperty</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>