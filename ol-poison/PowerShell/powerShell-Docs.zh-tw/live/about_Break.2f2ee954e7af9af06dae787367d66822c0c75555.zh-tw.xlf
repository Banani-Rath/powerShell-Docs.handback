<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c4d8744b7ba25a9089d6806ea23676ecf5509cc3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_Break.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bdd18a954ccdd9fb76bce2f707eafe1e5294810b</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa0dba048828eed5dd6a6486a27d382a58d84af6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell 指令程式</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Break</source>
          <target state="translated">關於中斷</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>TOPIC</source>
          <target state="translated">主題</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">簡短描述</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Describes a statement you can use to immediately exit Foreach, For, While, Do, or Switch statements.</source>
          <target state="translated">描述可用來立即結束 Foreach、，陳述式時，執行動作，或切換陳述式。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細描述</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When a Break statement appears in a loop, such as a Foreach, For, Switch, or While loop, the Break statement causes Windows PowerShell to immediately exit the loop.</source>
          <target state="translated">當 Break 陳述式會出現在迴圈中，「 Foreach，例如，參數，或雖然迴圈，Break 陳述式，讓 Windows PowerShell 立即結束迴圈。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In a Switch construct that does not loop, Break causes Windows PowerShell to exit the Switch code block.</source>
          <target state="translated">在未送切換建構，中斷原因結束交換器的 Windows PowerShell 程式碼區塊中。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label that lets you exit embedded loops.</source>
          <target state="translated">Break 陳述式可以加上標籤，可讓您結束內嵌的迴圈。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A label can specify any loop keyword, such as Foreach, For, or While, in a script.</source>
          <target state="translated">標籤可以指定任何 loop 關鍵字，例如 Foreach、，或同時，在指令碼。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When you use a label, Break exits the specified loop.</source>
          <target state="translated">當您使用標籤時，中斷離開指定的迴圈。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Break exits the specified loop, regardless of which loop the Break statement is in.</source>
          <target state="translated">Break 會跳指定的迴圈時，不論哪一個迴圈 Break 陳述式是在中。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following example shows how to use a Break statement to exit a For statement:</source>
          <target state="translated">下列範例示範如何使用 Break 陳述式 exit For 陳述式︰</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>for($i=1; $i -le 10; $i++) { Write-Host $i break }</source>
          <target state="translated">針對 ($i = 1; $i-le 10; $i + +) {Write-host $i 中斷}</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In this example, the Break statement exits the For loop when the $i variable equals 1.</source>
          <target state="translated">在此範例中，Break 陳述式結束 For 迴圈的 $i 變數等於 1 時。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Even though the For statement evaluates to True until $i is greater than 10, Windows PowerShell reaches the break statement the first time the For loop is run.</source>
          <target state="translated">雖然除非 $i 大於 10，For 陳述式會評估為 True，Windows PowerShell 會到達 For 迴圈會執行 break 陳述式第一個階段。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It is more common to use the Break statement in a loop where an inner condition must be met.</source>
          <target state="translated">就更常使用 Break 陳述式在迴圈內部的條件必須符合其中。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Consider the following Foreach statement example:</source>
          <target state="translated">請考慮下列 Foreach 陳述式範例︰</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>$i=0 $varB = 10,20,30,40 foreach ($val in $varB) { $i++ if ($val -eq 30) { break } } Write-Host "30 was found in array position $i"</source>
          <target state="translated">$i = 0 $varB = 10,20,30,40 foreach (在 $varB $val) {$i + + 如果 ($val-eq 30) {中斷}} Write-host 「 陣列位置 $i 找 30 」</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach statement iterates the $varB array.</source>
          <target state="translated">在此範例中，Foreach 陳述式會逐一查看 $varB 陣列。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Each time the code block is run, the $i variable is incremented by 1.</source>
          <target state="translated">每次執行的程式碼區塊，$i 變數遞增 1。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The If statement evaluates to False the first two times the loop is run.</source>
          <target state="translated">如果陳述式會執行兩次迴圈的第一個評估為 False。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The third time the loop is run, $i equals 3, and the $val variable equals 30.</source>
          <target state="translated">第三次執行迴圈時，$i 等於 3，並 $val 變數等於 30。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>At this point, the Break statement runs, and the Foreach loop exits.</source>
          <target state="translated">此時，Break 陳述式執行時和 Foreach 迴圈便會結束。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You break out of the other looping statements in the same way you break out of the Foreach loop.</source>
          <target state="translated">打破 Foreach 迴圈的方式相同破壞其他迴圈陳述式。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In the following example, the Break statement exits a While statement when a DivideByZeroException exception is trapped using the Trap statement.</source>
          <target state="translated">在下列範例中，Break 陳述式結束 While 陳述式時使用 Trap 陳述式來截獲 DivideByZeroException 例外狀況。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>$i = 3 while ($true) { trap [DivideByZeroException] { Write-Host "divide by zero trapped" break } 1 / $i-- }</source>
          <target state="translated">$i = 3 時 ($true) {設陷 [DivideByZeroException] {Write-host 「 除以零截獲 」 中斷} 1 / $i}</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label.</source>
          <target state="translated">Break 陳述式可以加上標籤。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If you use the Break keyword with a label, Windows PowerShell exits the labeled loop instead of exiting the current loop.</source>
          <target state="translated">如果您使用 Break 關鍵字的標籤時，Windows PowerShell 結束標記的迴圈，而不離開目前的迴圈。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The syntax for a label is as follows (this example shows a label in a While loop):</source>
          <target state="translated">標籤的語法為，如下所示 (此範例顯示在一段時間的標籤迴圈):</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>:myLabel while (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</source>
          <target state="translated">: myLabel 時 (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The label is a colon followed by a name that you assign.</source>
          <target state="translated">標籤是冒號，後面加上您指派名稱。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The label must be the first token in a statement, and it must be followed by the looping keyword, such as While.</source>
          <target state="translated">標籤必須是陳述式中的第一個語彙基元，而且它必須後面迴圈的關鍵字，例如時。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, only loop keywords, such as Foreach, For, and While can have a label.</source>
          <target state="translated">在 Windows PowerShell 中，只有迴圈關鍵字，例如 Foreach、，然後同時可以有標籤。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Break moves execution out of the labeled loop.</source>
          <target state="translated">中斷移動執行加上標籤的迴圈外。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In embedded loops, this has a different result than the Break keyword has when it is used by itself.</source>
          <target state="translated">內嵌在迴圈中，這會有不同於中斷關鍵字有單獨使用時的結果。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This schematic example has a While statement with a For statement:</source>
          <target state="translated">此圖解的範例有一段時間的 For 陳述式的陳述式︰</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>:myLabel while (&lt;condition 1&gt;) { for ($item in $items) { if (&lt;condition 2&gt;) { break myLabel } $item = $x   # A statement inside the For-loop } } $a = $c  # A statement after the labeled While-loop</source>
          <target state="translated">: myLabel 時 （&lt; 條件 1 &gt;） {($item $items 中) 的 {如果 （&lt; 條件 2 &gt;） {中斷 myLabel} $item = $x For 迴圈內的 # A 陳述式}} $ = $c # 的陳述式之後加上標籤的 While 迴圈</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If condition 2 evaluates to True, the execution of the script skips down to the statement after the labeled loop.</source>
          <target state="translated">如果條件 2 評估為 True，執行指令碼會略過下加上標籤的迴圈之後的陳述式。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the example, execution starts again with the statement "$a = $c".</source>
          <target state="translated">在範例中，開始執行一次的陳述式"$ = $c 」。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can nest many labeled loops, as shown in the following schematic example.</source>
          <target state="translated">您可以巢狀多加上標籤的迴圈，如下列圖解範例所示。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>:red while (<ph id="ph1">&lt;condition1&gt;</ph>) { :yellow while (<ph id="ph2">&lt;condition2&gt;</ph>) { while (<ph id="ph3">&lt;condition3&gt;</ph>) { if ($a) {break} if ($b) {break red} if ($c) {break yellow} } After innermost loop } After "yellow" loop } After "red" loop</source>
          <target state="translated">︰ 紅色時 (<ph id="ph1">&lt;condition1&gt;</ph>) {: 黃色時 (<ph id="ph2">&lt;condition2&gt;</ph>) {時 (<ph id="ph3">&lt;condition3&gt;</ph>) {如果 ($) {中斷} 如果 ($b) {中斷紅色} 如果 ($c) {中斷黃色}} 最內層的迴圈之後} 「 黃色 」 迴圈後}"red"迴圈後</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If the $b variable evaluates to True, execution of the script resumes after the loop that is labeled "red".</source>
          <target state="translated">$B 變數評估為 True，如果執行指令碼會標示為 「 紅色 」 迴圈之後繼續。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the $c variable evaluates to True, execution of the script control resumes after the loop that is labeled "yellow".</source>
          <target state="translated">如果 $c 變數評估為 True，指令碼控制項的執行會繼續迴圈標示為 「 黃色 」 之後。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If the $a variable evaluates to True, execution resumes after the innermost loop.</source>
          <target state="translated">如果 $ 變數評估為 True，則會在最內層的迴圈之後繼續執行。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>No label is needed.</source>
          <target state="translated">不需要使用任何標籤。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Windows PowerShell does not limit how far labels can resume execution.</source>
          <target state="translated">Windows PowerShell 不會限制多遠的距離標籤可以繼續執行。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The label can even pass control across script and function call boundaries.</source>
          <target state="translated">標籤可以甚至傳遞控制指令碼和函式呼叫的界限。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The Break keyword is used to leave the Switch construct.</source>
          <target state="translated">Break 關鍵字用來保留切換建構。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, the following Switch statement uses Break statements to test for the most specific condition:</source>
          <target state="translated">例如，下列 Switch 陳述式會使用 Break 陳述式來測試最特定的條件︰</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>$var = "word2" switch -regex ($var) { "word2" { Write-Host "Exact" $_ break }</source>
          <target state="translated">$var ="word2"交換器 regex ($var) {"word2"{Write-host"Exact"$_ 符號}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>"word.*" { Write-Host "Match on the prefix" $_ break }</source>
          <target state="translated">"word.*"{Write-host"比對的前置詞"$_ 符號}</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>"w.*" { Write-Host "Match on at least the first letter" $_ break }</source>
          <target state="translated">"w.*"{Write-host"比對至少的第一個字母"$_ 符號}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>default { Write-Host "No match" $_ break } }</source>
          <target state="translated">預設 {Write-host"沒有相符項目"$_ 中斷}}</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In this example, the $var variable is created and initialized to a string value of "word2".</source>
          <target state="translated">在此範例中，$var 變數是建立並初始化為 「 word2 」 的字串值。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The Switch statement uses the Regex class to match the variable value first with the term "word2".</source>
          <target state="translated">Switch 陳述式會使用 Regex 類別變數的值符合第一次 「 word2 」 一詞。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>(The Regex class is a regular expression Microsoft .NET Framework class.) Because the variable value and the first test in the Switch statement match, the first code block in the Switch statement runs.</source>
          <target state="translated">（Regex 類別是 Microsoft.NET Framework 類別的規則運算式）。由於變數的值，第一項測試在 Switch 陳述式比對區塊的第一個程式碼會執行 Switch 陳述式。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When Windows PowerShell reaches the first Break statement, the Switch statement exits.</source>
          <target state="translated">當 Windows PowerShell 到達第一個 Break 陳述式時，Switch 陳述式會結束。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If the four Break statements are removed from the example, all four conditions are met.</source>
          <target state="translated">四個 Break 陳述式會移除範例中，如果符合所有的四個條件。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This example uses the break statement to display results when the most specific condition is met.</source>
          <target state="translated">此範例會使用 break 陳述式，以符合最特定的條件時，顯示結果。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>about_Comparison_Operators about_Continue about_For about_Foreach about_Switch about_Throw about_Trap about_Try_Catch_Finally about_While</source>
          <target state="translated">about_Comparison_Operators about_Continue about_For about_Foreach about_Switch about_Throw about_Trap about_Try_Catch_Finally about_While</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>