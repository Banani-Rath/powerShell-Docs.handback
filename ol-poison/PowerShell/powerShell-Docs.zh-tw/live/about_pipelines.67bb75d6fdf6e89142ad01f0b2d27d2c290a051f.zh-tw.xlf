<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3154647bb6f7f37e9f428cf3f822ebcf7466f425</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_pipelines.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ade1b7a643ef9ffde1e8804e570cb62d5aeb7612</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d8327ea469f7eb12fa1f0450258f6248348467a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell 指令程式</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_Pipelines</source>
          <target state="translated">about_Pipelines</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Pipelines</source>
          <target state="translated">關於管線</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Pipelines</source>
          <target state="translated">about_Pipelines</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_pipelines</source>
          <target state="translated">about_pipelines</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">簡短描述</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Combining commands into pipelines in the Windows PowerShell</source>
          <target state="translated">結合命令放在 Windows PowerShell 中的管線</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細描述</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A pipeline is a series of commands connected by pipeline operators (|)(ASCII 124).</source>
          <target state="translated">管線是一系列的管線運算子 (|) 所連接的命令(ASCII 124)。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Each pipeline operator sends the results of the preceding command to the next command.</source>
          <target state="translated">每個管線運算子會將上述命令的結果傳送給下一個命令。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can use pipelines to send the objects that are output by one command to be used as input to another command for processing.</source>
          <target state="translated">您可以使用管線傳送的物件，一個用於做為輸入到另一個命令處理命令的輸出。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>And you can send the output of that command to yet another command.</source>
          <target state="translated">您可以將該命令的輸出傳送至另一個命令。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The result is a very powerful command chain or "pipeline" that is comprised of a series of simple commands.</source>
          <target state="translated">結果是非常強大的命令鏈結或 「 管線 」 所組成的一系列簡單的命令。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如，</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Command-1 | Command-2 | Command-3</source>
          <target state="translated">命令 1 |指令 2 |命令 3</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In this example, the objects that Command-1 emits are sent to Command-2.</source>
          <target state="translated">在此範例中，會發出命令 1 的物件會傳送至命令-2。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Command-2 processes the objects and sends them to Command-3.</source>
          <target state="translated">命令 2 處理物件，並將它們傳送到命令 3。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Command-3 processes the objects and send them down the pipeline.</source>
          <target state="translated">命令 3 處理物件，並將它們傳送到管線。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Because there are no more commands in the pipeline, the results are displayed at the console.</source>
          <target state="translated">因為管線中有沒有更多的命令，結果會顯示在主控台上。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In a pipeline, the commands are processed from left to right in the order that they appear.</source>
          <target state="translated">在管線中，處理命令從左到右的順序出現。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The processing is handled as a single operation and output is displayed as it is generated.</source>
          <target state="translated">處理是以單一作業，並產生就會顯示輸出。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Here is a simple example.</source>
          <target state="translated">以下是簡單的範例。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The following command gets the Notepad process and then stops it.</source>
          <target state="translated">下列命令會取得 「 記事本 」 處理程序，，然後停止它。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>get-process notepad | stop-process</source>
          <target state="translated">取得處理程序 [記事本] |停止處理程序</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The first command uses the Get-Process cmdlet to get an object representing the Notepad process.</source>
          <target state="translated">第一個命令使用 Get-process cmdlet 取得代表 「 記事本 」 處理程序的物件。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>It uses a pipeline operator (|) to send the process object to the Stop-Process cmdlet, which stops the Notepad process.</source>
          <target state="translated">它使用管線運算子 (|) 將處理程序物件傳送至 Stop-process cmdlet，這會停止記事本處理程序。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Notice that the Stop-Process command does not have a Name or ID parameter to specify the process, because the specified process is submitted through the pipeline.</source>
          <target state="translated">請注意，停止處理命令並沒有名稱或 ID 參數，以指定程序，因為指定的處理序提交透過管線。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Here is a practical example.</source>
          <target state="translated">以下是實用的範例。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This command pipeline gets the text files in the current directory, selects only the files that are more than 10,000 bytes long, sorts them by length, and displays the name and length of each file in a table.</source>
          <target state="translated">此命令管線取得目前目錄中的文字檔案、 選取所 10000 位元組長的檔案、 依長度，和在資料表中顯示的名稱和每個檔案的長度。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Get-ChildItem -path *.txt | Where-Object {$_.length -gt 10000} | Sort-Object -property Length | Format-Table -property name, length</source>
          <target state="translated">Get-childitem-路徑 *.txt |Where-object {$_.length-gt 10000} |排序物件的內容長度 |格式化表格的屬性名稱、 長度</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This pipeline is comprised of four commands in the specified order.</source>
          <target state="translated">此管線是由四個命令中指定的順序所組成。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The command is written horizontally, but we will show the process vertically in the following graphic.</source>
          <target state="translated">水平寫入命令，但我們將在下圖以垂直方式顯示的程序。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Get-ChildItem -path *.txt</source>
          <target state="translated">Get-childitem-路徑 *.txt</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects ) |   (    .txt         )</source>
          <target state="translated">|  （FileInfo 物件） |  (    .txt         )</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Where-Object {$_.length -gt 10000}</source>
          <target state="translated">Where-object {$_.length-gt 10000}</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects ) |   (    .txt         ) |   ( Length &gt; 10000  )</source>
          <target state="translated">|  （FileInfo 物件） |  (    .txt         ) |  (長度 &gt; 10000)</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Sort-Object -property Length</source>
          <target state="translated">排序物件的內容長度</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects  ) |   (    .txt          ) |   ( Length &gt; 10000   ) |   ( Sorted by length )</source>
          <target state="translated">|  （FileInfo 物件） |  (    .txt          ) |  (長度 &gt; 10000) |  （依長度排序）</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Format-Table -property name, length</source>
          <target state="translated">格式化表格的屬性名稱、 長度</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects     ) |   (    .txt             ) |   ( Length &gt; 10000      ) |   ( Sorted by length    ) |   (Formatted in a table )</source>
          <target state="translated">|  （FileInfo 物件） |  (    .txt             ) |  (長度 &gt; 10000) |  （依長度排序） |  （在資料表中的格式）</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Name                       Length</source>
          <target state="translated">名稱長度</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>tmp1.txt                    82920 tmp2.txt                   114000 tmp3.txt                   114000</source>
          <target state="translated">tmp1.txt 82920 tmp2.txt 114000 tmp3.txt 114000</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>USING PIPELINES</source>
          <target state="translated">使用管線</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell cmdlets were designed to be used in pipelines.</source>
          <target state="translated">Windows PowerShell 指令程式可在管線中使用。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For example, you can usually pipe the results of a Get cmdlet to an action cmdlet (such as a Set, Start, Stop, or Rename cmdlet) for the same noun.</source>
          <target state="translated">例如，您通常管線相同名詞的一個動作的 cmdlet （例如集合、 開始、 停止或重新命名指令程式） 來取得 cmdlet 的結果。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, you can pipe any service from the Get-Service cmdlet to the Start-Service or Stop-Service cmdlets (although disabled services cannot be restarted in this way).</source>
          <target state="translated">例如，您可以透過管道傳送 Get-service cmdlet 從任何服務，以啟動服務或停止服務的 cmdlet （雖然停用的服務無法以這種方式重新啟動）。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This command pipeline starts the WMI service on the computer:</source>
          <target state="translated">此命令管線的電腦上啟動 WMI 服務︰</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>get-service wmi | start-service</source>
          <target state="translated">取得服務 wmi |啟動服務</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The cmdlets that get and set objects of the Windows PowerShell providers, such as the Item and ItemProperty cmdlets, are also designed to be used in pipelines.</source>
          <target state="translated">取得和設定的 Windows PowerShell 提供者的項目和 ItemProperty cmdlet，例如物件的指令程式也可在管線中使用。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For example, you can pipe the results of a Get-Item or Get-ChildItem command in the Windows PowerShell registry provider to the New-ItemProperty cmdlet.</source>
          <target state="translated">例如，您可以使用 Get-item 或 Get-childitem 命令的結果管線在 Windows PowerShell 登錄提供者給 New-itemproperty cmdlet。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This command adds a new registry entry, NoOfEmployees, with a value of 8124, to the MyCompany registry key.</source>
          <target state="translated">此命令會將新登錄項目 NoOfEmployees 值是 8124，MyCompany 登錄機碼。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>get-item -path HKLM:\Software\MyCompany | new-Itemproperty -name NoOfEmployees -value 8124</source>
          <target state="translated">取得項目-路徑 HKLM:\Software\MyCompany |New-itemproperty-NoOfEmployees 的名稱-值 8124</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Many of the utility cmdlets, such as Get-Member, Where-Object, Sort-Object, Group-Object, and Measure-Object are used almost exclusively in pipelines.</source>
          <target state="translated">許多公用程式 cmdlet，Get-member，Where-object，排序物件，例如群組物件，以及量值物件會以幾乎全部都在管線中使用。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can pipe any objects to these cmdlets.</source>
          <target state="translated">您可以透過管道傳送至這些 cmdlet 的任何物件。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For example, you can pipe all of the processes on the computer to the Sort-Object command and have them sorted by the number of handles in the process.</source>
          <target state="translated">例如，您可以使用所有的處理序管線傳送要排序物件命令的電腦上，並讓它們依照程序中的控制代碼數目。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>get-process | sort-object -property handles</source>
          <target state="translated">取得處理序 |排序物件的屬性處理常式</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Also, you can pipe any objects to the formatting cmdlets, such as Format-List and Format-Table, the Export cmdlets, such as Export-Clixml and Export-CSV, and the Out cmdlets, such as Out-Printer.</source>
          <target state="translated">此外，您可以透過管道傳送到格式化 cmdlet，如 Format-list 和 Format-table、 匯出指令程式，例如 Export-clixml 和 CSV 匯出 Out cmdlet，例如 Out-printer 的任何物件。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, you can pipe the Winlogon process to the Format-List cmdlet to display all of the properties of the process in a list.</source>
          <target state="translated">比方說，您可以透過管道傳送至 Format-list cmdlet，以顯示所有的程序的屬性清單中，Winlogon 處理程序。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>get-process winlogon | format-list -property *</source>
          <target state="translated">取得處理序 winlogon |格式清單-屬性 *</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>With a bit of practice, you'll find that combining simple commands into pipelines saves time and typing, and makes your scripting more efficient.</source>
          <target state="translated">24 位元的作法，您會發現，將簡單的命令結合成管線可以節省時間與型別，並可讓您的指令碼更有效率。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>HOW PIPELINES WORK</source>
          <target state="translated">管線的運作方式</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>When you "pipe" objects, that is send the objects in the output of one command to another command, Windows PowerShell tries to associate the piped objects with one of the parameters of the receiving cmdlet.</source>
          <target state="translated">當您 「 」 所傳送的物件中的物件傳送至另一個命令的一個命令的輸出時，Windows PowerShell 會嘗試管線的物件關聯的其中一個接收 cmdlet 的參數。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To do so, the Windows PowerShell "parameter binding" component, which associates input objects with cmdlet parameters, tries to find a parameter that meets the following criteria:</source>
          <target state="translated">若要這樣做，Windows PowerShell 「 參數繫結 」 元件，其會將輸入的物件的 cmdlet 參數，會嘗試尋找符合下列準則的參數︰</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>-- The parameter must accept input from a pipeline (not all do) -- The parameter must accept the type of object being sent or a type that the object can be converted to.</source>
          <target state="translated">--參數必須接受來自管線 （不是所有執行） 的輸入--正在傳送的物件型別或物件可以轉換為型別，必須接受參數。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>-- The parameter must not already be used in the command.</source>
          <target state="translated">--參數必須不使用過命令。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, the Start-Service cmdlet has many parameters, but only two of them, Name and InputObject accept pipeline input.</source>
          <target state="translated">比方說，Start-service cmdlet 有許多參數，但只有其中兩個，名稱和 InputObject 接受管線輸入。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The Name parameter takes strings and the InputObject parameter takes service objects.</source>
          <target state="translated">Name 參數使用字串，方法 InputObject 參數使用的服務物件。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Therefore, you can pipe strings and service objects (and objects with properties that can be converted to string and service objects) to Start-Service.</source>
          <target state="translated">因此，您可以透過管道傳送字串和服務物件 （和物件可以轉換成字串和服務物件的屬性） 來啟動服務。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If the parameter binding component of Windows PowerShell cannot associate the piped objects with a parameter of the receiving cmdlet, the command fails and Windows PowerShell prompts you for the missing parameter values.</source>
          <target state="translated">如果 Windows PowerShell 的參數繫結元件無法將管線的物件與接收 cmdlet 的參數，則命令會失敗，Windows PowerShell 會提示您輸入遺漏的參數值。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You cannot force the parameter binding component to associate the piped objects with a particular parameter -- you cannot even suggest a parameter.</source>
          <target state="translated">您無法強制管線的物件關聯的特定參數的參數繫結元件--即使無法建議參數。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Instead, the logic of the component manages the piping as efficiently as possible.</source>
          <target state="translated">相反地，元件的邏輯會管理管線盡可能有效率。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>ONE-AT-A-TIME PROCESSING</source>
          <target state="translated">一個在-A 時間處理</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Piping objects to a command is much like using a parameter of the command to submit the objects.</source>
          <target state="translated">使用命令物件極為類似使用命令的參數來送出的物件。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For example, piping objects representing the services on the computer to a Format-Table command, such as:</source>
          <target state="translated">例如，透過管道傳送物件，例如 Format-table 命令，代表電腦上的服務︰</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>get-service | format-table -property name, dependentservices</source>
          <target state="translated">取得服務 |格式化表格的屬性名稱、 dependentservices</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>is much like saving the service objects in a variable and using the InputObject parameter of Format-Table to submit the service object.</source>
          <target state="translated">就像儲存在變數中的服務物件，並使用格式化表格的 InputObject 參數送出服務物件。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>$services = get-service format-table -inputobject $services -property name, dependentservices</source>
          <target state="translated">$services = get 服務格式資料表-inputobject $services-屬性名稱、 dependentservices</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>or imbedding the command in the parameter value</source>
          <target state="translated">或內嵌的參數值的命令</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>format-table -inputobject (get-service wmi) -property name, dependentservices</source>
          <target state="translated">格式化表格-inputobject (get 服務 wmi) 的屬性名稱、 dependentservices</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>However, there is an important difference.</source>
          <target state="translated">不過，是一項重要差異。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When you pipe multiple objects to a command, Windows PowerShell sends the objects to the command one at a time.</source>
          <target state="translated">當您使用管線傳送給某命令的多個物件時，Windows PowerShell 會將物件傳送至其中一個命令一次。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When you use a command parameter, the objects are sent as a single array object.</source>
          <target state="translated">當您使用命令參數時，這些物件會當做單一陣列物件。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This seemingly technical difference can have interesting, and sometimes useful, consequences.</source>
          <target state="translated">這看似技術的差異可能會造成有趣，且有時會很有用，後果。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>For example, if you pipe multiple process objects from the Get-Process cmdlet to the Get-Member cmdlet, Windows PowerShell sends each process object, one at a time, to Get-Member.</source>
          <target state="translated">例如，如果您使用管線傳送多個處理程序物件從 Get-process cmdlet 給 Get-member cmdlet，Windows PowerShell 會將每個處理程序物件，一次傳送給 Get 成員。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Get-Member displays the .NET class (type) of the process objects, and their properties and methods.</source>
          <target state="translated">Get-member 會顯示處理程序物件，其屬性和方法的.NET 類別 （型別）。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>(Get-Member eliminates duplicates, so if the objects are all of the same type, it displays only one object type.)</source>
          <target state="translated">(Get 成員，以排除重複，因此如果物件是所有相同的型別，則會顯示只有一個物件類型。)</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In this case, Get-Member displays the properties and methods of each process object, that is, a System.Diagnostics.Process object.</source>
          <target state="translated">在此情況下，Get-member 即會顯示的屬性和方法的每個處理程序的物件，也就是 System.Diagnostics.Process 物件。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>get-process | get-member</source>
          <target state="translated">取得處理序 |取得成員</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>TypeName: System.Diagnostics.Process</source>
          <target state="translated">TypeName: System.Diagnostics.Process</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Name                           MemberType     Definition</source>
          <target state="translated">名稱 MemberType 定義</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Handles                        AliasProperty  Handles = Handlecount Name                           AliasProperty  Name = ProcessName NPM                            AliasProperty  NPM = NonpagedSystemMemorySize</source>
          <target state="translated">處理 AliasProperty 控制代碼 = Handlecount AliasProperty 名稱 = ProcessName NPM AliasProperty NPM = NonpagedSystemMemorySize</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>However, if you use the InputObject parameter of Get-Member, then Get-Member receives an array of System.Diagnostics.Process objects as a single unit, and it displays the properties of an array of objects.</source>
          <target state="translated">如果您使用 Get-member 的 InputObject 參數，Get-member 會收到 System.Diagnostics.Process 物件的陣列視為單一單位，但它會顯示物件的陣列的屬性。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>(Note the array symbol ([]) after the System.Object type name.)</source>
          <target state="translated">（請注意陣列符號 ([]) 之後 System.Object 的型別名稱）。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>get-member -inputobject (get-process)</source>
          <target state="translated">get-member inputobject （取得處理序）</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>TypeName: System.Object[]</source>
          <target state="translated">類型名稱︰ System.Object]</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Name               MemberType    Definition</source>
          <target state="translated">名稱 MemberType 定義</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Count              AliasProperty Count = Length Address            Method        System.Object&amp; Address(Int32 ) Clone              Method        System.Object Clone()</source>
          <target state="translated">計數 AliasProperty 計數 = 長度位址方法 System.Object &amp; 位址 (Int32) 複製方法 System.Object clone （）</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This result might not be what you intended, but after you understand it, you can use it.</source>
          <target state="translated">此結果可能不是您想要的結果，但您了解之後，您可以使用它。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For example, an array of process objects has a Count property that you can use to count the number of processes on the computer.</source>
          <target state="translated">比方說，處理程序物件的陣列具有一個 Count 屬性，您可以使用計算的電腦上的處理序數目。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>(get-process).count</source>
          <target state="translated">.count （取得處理序）</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This distinction can be important, so remember that when you pipe objects to a cmdlet, they are delivered one at a time.</source>
          <target state="translated">這個差別非常重要，因此請記得，當您使用管線傳送至 cmdlet 的物件，它們會傳遞一次。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>ACCEPTS PIPELINE INPUT</source>
          <target state="translated">接受管線輸入</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In order to receive objects in a pipeline, the receiving cmdlet must have a parameter that accepts pipeline input.</source>
          <target state="translated">若要接收管線中的物件，接收指令程式必須接受管線輸入的參數。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You can use a Get-Help command with the Full or Parameter parameters to determine which, if any, of a cmdlet's parameters accepts pipeline input.</source>
          <target state="translated">您可以使用完整或參數的參數使用 Get-help 命令，來判斷，如果有的話，指令程式參數的接受管線輸入。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In the Get-Help default display, the "Accepts pipeline input" item appears in a table of parameter attributes.</source>
          <target state="translated">取得說明預設的顯示，在 「 接受管線輸入 」 項目會出現在 [參數屬性的表格。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>This table is displayed only when you use the Full or Parameter parameters of the Get-Help cmdlet.</source>
          <target state="translated">只有在使用 Get-help cmdlet 的完整或參數參數時，會顯示此資料表。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For example, to determine which of the parameters of the Start-Service cmdlet accepts pipeline input, type:</source>
          <target state="translated">例如，若要判斷哪些 Start-service cmdlet 的參數接受管線輸入，型別︰</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>get-help start-service -full</source>
          <target state="translated">取得說明啟動服務-完整</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>get-help start-service -parameter *</source>
          <target state="translated">取得說明啟動服務-參數 *</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For example, the help for the Start-Service cmdlet shows that the Name and InputObject parameters accept pipeline input ("true").</source>
          <target state="translated">例如，啟動服務 cmdlet 的說明顯示的名稱和 InputObject 參數接受管線輸入 ("true")。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>All other parameters have a value of "false" in the "Accept pipeline input?"</source>
          <target state="translated">所有其他參數值為"false"的 「 接受管線輸入？ 」</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>row.</source>
          <target state="translated">資料列。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>-name &lt;string[]&gt; Specifies the service names for the service to be started.</source>
          <target state="translated">-名稱 &lt; string [] &gt; 指定要啟動服務的服務名稱。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The parameter name is optional.</source>
          <target state="translated">參數名稱為選擇性。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You can use "-Name" or its alias, "-ServiceName", or you can omit the parameter name.</source>
          <target state="translated">您可以使用 "-Name" 或其別名 "-ServiceName"，也可以省略參數名稱。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Required?</source>
          <target state="translated">必要？</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>true Position?</source>
          <target state="translated">真正的位置？</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>1 Default value --&gt;  Accept pipeline input?</source>
          <target state="translated">1 的預設值--&gt; 接受管線輸入？</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>true (ByValue, ByPropertyName) Accept wildcard characters?</source>
          <target state="translated">true （ByValue、 ByPropertyName） 接受萬用字元？</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>-inputObject &lt;ServiceController[]&gt; Specifies ServiceController objects representing the services to be started.</source>
          <target state="translated">-inputObject &lt; ServiceController [] &gt; 指定的 ServiceController 物件，代表要啟動服務。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Enter a variable that contains the objects or type a command or expression that gets the objects.</source>
          <target state="translated">輸入包含物件的變數，或輸入可取得物件的命令或運算式。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Required?</source>
          <target state="translated">必要？</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>false Position?</source>
          <target state="translated">false 位置？</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>named Default value --&gt;  Accept pipeline input?</source>
          <target state="translated">具名的預設值--&gt; 接受管線輸入？</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>true (ByValue) Accept wildcard characters?</source>
          <target state="translated">true (ByValue) 接受萬用字元？</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>false</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This means that you can send objects (PsObjects) through the pipeline to the Where-Object cmdlet and Windows PowerShell will associate the object with the InputObject parameter.</source>
          <target state="translated">這表示您可以傳送物件 (PsObjects) 透過 Where-object 指令程式的管線和 Windows PowerShell 會將物件與關聯的 InputObject 參數。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>METHODS OF ACCEPTING PIPELINE INPUT</source>
          <target state="translated">接受管線輸入的方法</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Cmdlets parameters can accept pipeline input in one of two different ways:</source>
          <target state="translated">Cmdlet 參數可以接受管線輸入，在兩個不同的方式之一︰</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>-- ByValue: Parameters that accept input "by value" can accept piped objects that have the same .NET type as their parameter value or objects that can be converted to that type.</source>
          <target state="translated">-ByValue︰ 接受輸入 「 值 」 可以接受的參數傳送出的物件具有相同的.NET 型別，它們的參數值或可以轉換為該類型的物件。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>For example, the Name parameter of Start-Service accepts pipeline input by value.</source>
          <target state="translated">例如，啟動服務的 Name 參數會接受管線輸入值。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>It can accept string objects or objects that can be converted to strings.</source>
          <target state="translated">它可以接受字串或可以轉換成字串的物件。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>-- ByPropertyName: Parameters that accept input "by property name" can accept piped objects only when a property of the object has the same name as the parameter.</source>
          <target state="translated">-ByPropertyName︰ 物件的屬性具有相同名稱做為參數時，才接受 「 依屬性名稱 」 輸入可接受的參數傳送出的物件。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For example, the Name parameter of Start-Service can accept objects that have a Name property.</source>
          <target state="translated">例如，啟動服務的 Name 參數可以接受的 Name 屬性的物件。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>(To list the properties of an object, pipe it to Get-Member.)</source>
          <target state="translated">（若要列出物件的屬性，將它傳送至 Get-member。）</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Some parameters can accept objects by value or by property name.</source>
          <target state="translated">某些參數可以接受物件，透過值或屬性名稱。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>These parameters are designed to take input from the pipeline easily.</source>
          <target state="translated">這些參數被設計來輕鬆地採取從管線輸入。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>INVESTIGATING PIPELINE ERRORS</source>
          <target state="translated">調查管線錯誤</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If a command fails because of a pipeline error, you can investigate the failure and rewrite the command.</source>
          <target state="translated">如果命令失敗，因為管線錯誤，您可以調查失敗且重寫命令。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For example, the following command tries to move a registry entry from one registry key to another by using the Get-Item cmdlet to get the destination path and then piping the path to the Move-ItemProperty cmdlet.</source>
          <target state="translated">例如，下列命令會嘗試將登錄項目從一個登錄機碼移至另一個，使用 Get-item cmdlet 來取得的目的地路徑，然後使用管線傳送至 Move-itemproperty cmdlet 的路徑。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Specifically, the command uses the Get-Item cmdlet to get the destination path.</source>
          <target state="translated">具體而言，命令會使用 Get-item cmdlet 來取得的目的地路徑。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>It uses a pipeline operator to send the result to the Move-ItemProperty cmdlet.</source>
          <target state="translated">它使用管線運算子將結果傳送至 Move-itemproperty cmdlet。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The Move-ItemProperty command specifies the current path and name of the registry entry to be moved.</source>
          <target state="translated">Move-itemproperty 命令指定目前的路徑和名稱要移動的登錄項目。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>get-item -path hklm:\software\mycompany\sales | move-itemproperty -path hklm:\software\mycompany\design -name product</source>
          <target state="translated">取得項目-路徑 hklm:\software\mycompany\sales |移動 itemproperty-路徑 hklm:\software\mycompany\design-產品名稱</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The command fails and Windows PowerShell displays the following error message:</source>
          <target state="translated">此命令會失敗，Windows PowerShell 會顯示下列錯誤訊息︰</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Move-ItemProperty : The input object cannot be bound to any parameters for the command either because the command does not take pipeline input or the input and its properties do not match any of the parameters that take pipeline input.</source>
          <target state="translated">Move-itemproperty︰ 輸入的物件無法繫結至任何命令的參數可能是因為命令不接受管線輸入，或輸入和其內容不符合任何接受管線輸入的參數。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>At line:1 char:23</source>
          <target state="translated">在 [行︰ 1 char: 23</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>$a | move-itemproperty &lt;&lt;&lt;&lt;  -path hklm:\software\mycompany\design -name product</source>
          <target state="translated">$ |移動 itemproperty &lt;&lt;&lt;&lt;-路徑 hklm:\software\mycompany\design-產品名稱</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>To investigate, use the Trace-Command cmdlet to trace the Parameter Binding component of Windows PowerShell.</source>
          <target state="translated">若要調查，使用 Trace-command cmdlet 追蹤 Windows PowerShell 的參數繫結元件。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following command traces the Parameter Binding component while the command is processing.</source>
          <target state="translated">命令正在處理時，下列命令將追蹤參數繫結的元件。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>It uses the -pshost parameter to display the results at the console and the -filepath command to send them to the debug.txt file for later reference.</source>
          <target state="translated">它使用-pshost 參數將結果顯示在主控台和-filepath 命令，將他們傳送至 debug.txt 檔案，以便日後參考。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>trace-command -name parameterbinding -expression {get-item -path hklm:\software\mycompany\sales | move-itemproperty -path hklm:\software\mycompany\design -name product} -pshost -filepath debug.txt</source>
          <target state="translated">追蹤命令-名稱 parameterbinding-運算式 {get 項目-路徑 hklm:\software\mycompany\sales | 移動 itemproperty-路徑 hklm:\software\mycompany\design-名稱產品}-pshost-filepath debug.txt</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The results of the trace are lengthy, but they show the values being bound to the Get-Item cmdlet and then the named values being bound to the Move-ItemProperty cmdlet.</source>
          <target state="translated">追蹤的結果很長，但它們會顯示未繫結至 Get-item cmdlet 的值，然後繫結至 Move-itemproperty cmdlet 名稱的值。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>BIND NAMED cmd line args [Move-ItemProperty] BIND arg [hklm:\software\mycompany\design] to parameter [Path]</source>
          <target state="translated">繫結名為 cmd 行引數 [Move-itemproperty] 繫結引數 [hklm:\software\mycompany\design] 參數 [Path]</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>BIND arg [product] to parameter [Name]</source>
          <target state="translated">將 [product] 引數繫結至參數 [名稱]</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>....</source>
          <target state="translated">....</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>BIND POSITIONAL cmd line args [Move-ItemProperty]</source>
          <target state="translated">繫結位置的命令列引數 [Move-itemproperty]</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Finally, it shows that the attempt to bind the path to the Destination parameter of Move-ItemProperty failed.</source>
          <target state="translated">最後，它會顯示，嘗試繫結至 Move-itemproperty 失敗的目的參數的路徑。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>BIND PIPELINE object to parameters: [Move-ItemProperty] PIPELINE object TYPE = [Microsoft.Win32.RegistryKey] RESTORING pipeline parameter's original values Parameter [Destination] PIPELINE INPUT ValueFromPipelineByPropertyName NO COERCION Parameter [Credential] PIPELINE INPUT ValueFromPipelineByPropertyName NO COERCION</source>
          <target state="translated">參數繫結的管線物件: [Move-itemproperty] 管線物件型別 = [Microsoft.Win32.RegistryKey] 還原管線參數的原始值參數 [目的地] 管線輸入 ValueFromPipelineByPropertyName NO 強制型轉參數 [認證] 管線輸入 ValueFromPipelineByPropertyName 沒有強制</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>To investigate the failure, use the Get-Help cmdlet to view the attributes of the Destination parameter.</source>
          <target state="translated">若要調查失敗，請使用 Get-help cmdlet 檢視 Destination 參數的屬性。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The following command gets detailed information about the Destination parameter.</source>
          <target state="translated">下列命令會取得 [目的地] 參數的詳細的資訊。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>get-help move-itemproperty -parameter destination</source>
          <target state="translated">取得說明移動 itemproperty-參數目的地</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The results show that Destination takes pipeline input only "by property name".</source>
          <target state="translated">結果會顯示目的接受管線輸入，只有 「 依屬性名稱 」。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>That is, the piped object must have a property named Destination.</source>
          <target state="translated">也就是管線的物件必須有一個名為目的地屬性。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>-destination <ph id="ph1">&lt;string&gt;</ph> Specifies the path to the destination location.</source>
          <target state="translated">-目的地 <ph id="ph1">&lt;string&gt;</ph> 指定目的地位置的路徑。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Required?</source>
          <target state="translated">必要？</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>true Position?</source>
          <target state="translated">真正的位置？</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>2 Default value Accept pipeline input?</source>
          <target state="translated">2 的預設值接受管線輸入？</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>true (ByPropertyName) Accept wildcard characters?</source>
          <target state="translated">true (ByPropertyName) 接受萬用字元？</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>To see the properties of the object being piped to the Move-ItemProperty cmdlet, pipe it to the Get-Member cmdlet.</source>
          <target state="translated">正在傳送至 Move-itemproperty cmdlet 物件的屬性，請將它傳送給 Get-member cmdlet。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The following command pipes the results of the first part of the command to the Get-Member cmdlet.</source>
          <target state="translated">下列命令使用管線傳送至 Get-member cmdlet 命令的第一個部分的結果。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>get-item -path hklm:\software\mycompany\sales | get-member</source>
          <target state="translated">取得項目-路徑 hklm:\software\mycompany\sales |取得成員</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The output shows that the item is a Microsoft.Win32.RegistryKey that does not have a Destination property.</source>
          <target state="translated">輸出會顯示在項目是不需要的目的地屬性 Microsoft.Win32.RegistryKey。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>That explains why the command failed.</source>
          <target state="translated">所說明的命令失敗的原因。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>To fix the command, we must specify the destination in the Move-ItemProperty cmdlet.</source>
          <target state="translated">若要修正此命令，我們必須 Move-itemproperty cmdlet 中指定的目的地。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>We can use a Get-ItemProperty command to get the path, but the name and destination must be specified in the Move-ItemProperty part of the command.</source>
          <target state="translated">我們可以使用 Get-itemproperty 命令取得路徑，但在 Move-itemproperty 命令的一部分，則必須指定名稱和目的地。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>get-item -path hklm:\software\mycompany\design | move-itemproperty -dest hklm:\software\mycompany\design -name product</source>
          <target state="translated">取得項目-路徑 hklm:\software\mycompany\design |移動 itemproperty-目的地 hklm:\software\mycompany\design-產品名稱</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>To verify that the command worked, use a Get-ItemProperty command:</source>
          <target state="translated">若要確認命令成功，使用 Get-itemproperty 命令︰</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>get-itemproperty hklm:\software\mycompany\sales</source>
          <target state="translated">之 get-itemproperty hklm:\software\mycompany\sales</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The results show that the Product registry entry was moved to the Sales key.</source>
          <target state="translated">結果會顯示產品的登錄項目已移至銷售索引鍵。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>PSPath       : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany\sales PSParentPath : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany PSChildName  : sales PSDrive      : HKLM PSProvider   : Microsoft.PowerShell.Core\Registry Product      : 18</source>
          <target state="translated">PSPath: Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany\sales PSParentPath: Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany PSChildName︰ 銷售 PSDrive: HKLM PSProvider: Microsoft.PowerShell.Core\Registry 產品︰ 18</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>about_objects about_parameters about_command_syntax about_foreach</source>
          <target state="translated">about_objects about_parameters about_command_syntax about_foreach</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>