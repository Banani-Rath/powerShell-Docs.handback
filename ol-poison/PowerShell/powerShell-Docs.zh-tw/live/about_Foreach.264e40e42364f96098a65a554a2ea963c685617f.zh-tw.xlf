<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f31f43a46b7310525bae25f8c51c138d3ae0a7cf</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_Foreach.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a4052ae04996c162cc37e7970e28e6f60409e9e9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29cff617b56a2c9d858ed6fd0fed891cd36e58fe</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell 指令程式</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About ForEach</source>
          <target state="translated">關於 ForEach</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Foreach</source>
          <target state="translated">about_Foreach</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">簡短描述</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes a language command you can use to traverse all the items in a collection of items.</source>
          <target state="translated">說明您可以周遊的項目集合中的所有項目使用的語言命令。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細描述</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Foreach statement (also known as a Foreach loop) is a language construct for stepping through (iterating) a series of values in a collection of items.</source>
          <target state="translated">Foreach 陳述式 （也稱為 Foreach 迴圈 」） 是一種語言建構來逐步執行 （反覆運算） 一系列的項目集合中的值。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The simplest and most typical type of collection to traverse is an array.</source>
          <target state="translated">周遊集合的最簡單且最一般型別是陣列。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Within a Foreach loop, it is common to run one or more commands against each item in an array.</source>
          <target state="translated">在 Foreach 迴圈內通常會對陣列中每個項目執行一或多個命令。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Syntax The following shows the ForEach syntax:</source>
          <target state="translated">下列語法顯示 ForEach 語法︰</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>foreach ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>){<ph id="ph3">&lt;statement list&gt;</ph>}</source>
          <target state="translated">foreach ($<ph id="ph1">&lt;item&gt;</ph> <ph id="ph2">&lt;collection&gt;</ph>) {<ph id="ph3">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Simplified syntax Starting in Windows PowerShell 3.0, syntax with language keywords such as Where and ForEach was simplified.</source>
          <target state="translated">簡化的語法啟動 Windows PowerShell 3.0，語法與語言關鍵字，例如位置和 ForEach 已簡化。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Comparison operators that work on the members of a collection are treated as parameters.</source>
          <target state="translated">在集合的成員運作的比較運算子會被視為參數。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can use a method on the members of a collection without containing it in a script block or adding the automatic variable "$_.".</source>
          <target state="translated">您可以使用集合的成員上的方法而不會包含在指令碼區塊或加入自動變數"$_"。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the following two examples:</source>
          <target state="translated">請考慮下列兩個範例︰</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>dir cert:\ -Recurse | foreach GetKeyAlgorithm dir cert:\ -Recurse | foreach {$_.GetKeyAlgorithm()}</source>
          <target state="translated">dir cert: \-Recurse |foreach GetKeyAlgorithm dir cert: \-Recurse |foreach {$_。GetKeyAlgorithm()}</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Although both commands work, the first returns results without using a script block or the $_.</source>
          <target state="translated">雖然這兩個命令，第一個會傳回結果，而不使用指令碼區塊或 $_。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>automatic variable.</source>
          <target state="translated">自動變數。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The method GetKeyAlgorithm is treated as a parameter of ForEach.</source>
          <target state="translated">方法 GetKeyAlgorithm 會被視為 ForEach 的參數。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The first command returns the same results, but without errors, because the simplified syntax does not attempt to return results for items for which the specified argument did not apply.</source>
          <target state="translated">第一個命令會傳回相同的結果，但沒有錯誤，因為簡化的語法並不會嘗試傳回結果的不套用指定的引數沒有項目。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Get-Process property Description is passed as a parameter argument of the ForEach statement.</source>
          <target state="translated">在此範例中，取得處理序屬性描述參數引數傳遞的 ForEach 陳述式。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The results are the descriptions of active processes.</source>
          <target state="translated">結果會是作用中處理序的說明。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Get-Process | ForEach Description</source>
          <target state="translated">Get-process |ForEach 描述</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The Foreach statement outside a command pipeline The part of the Foreach statement enclosed in parenthesis represents a variable and a collection to iterate.</source>
          <target state="translated">Foreach 陳述式外部命令管線 Foreach 陳述式的括號括住的部分表示變數，來逐一查看集合。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows PowerShell creates the variable ($<ph id="ph1">&lt;item&gt;</ph>) automatically when the Foreach loop runs.</source>
          <target state="translated">Windows PowerShell 會建立變數 ($<ph id="ph1">&lt;item&gt;</ph>) 自動 Foreach 迴圈執行時。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Prior to each iteration through the loop, the variable is set to a value in the collection.</source>
          <target state="translated">在每個反覆項目執行迴圈之前, 變數設定為集合中的值。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The block following a Foreach statement {<ph id="ph1">&lt;statement list&gt;</ph>} contains a set of commands to execute against each item in a collection.</source>
          <target state="translated">Foreach 陳述式之後的區塊 {<ph id="ph1">&lt;statement list&gt;</ph>} 包含一組要針對集合中每個項目執行的命令。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Examples For example, the Foreach loop in the following example displays the values in the $letterArray array.</source>
          <target state="translated">範例的範例中，「 Foreach 迴圈 」，在下列範例顯示 $letterArray 陣列中的值。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>$letterArray = "a","b","c","d" foreach ($letter in $letterArray) { Write-Host $letter }</source>
          <target state="translated">$letterArray ="a"、"b"、"c"，"d"foreach (在 $letterArray $letter) {Write-host $letter}</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In this example, the $letterArray array is created and initialized with the string values "a", "b", "c", and "d".</source>
          <target state="translated">在此範例中，建立和初始化的字串值 $letterArray 陣列"a"、"b"、"c"和"d"。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The first time the Foreach statement runs, it sets the $letter variable equal to the first item in $letterArray ("a").</source>
          <target state="translated">第一次 Foreach 陳述式執行時，會設定 $letter 變數等於第一個項目中 $letterArray ("a")。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Then, it uses the Write-Host cmdlet to display the letter a.</source>
          <target state="translated">然後，它會使用 Write-host cmdlet 顯示的字母。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The next time through the loop, $letter is set to "b", and so on.</source>
          <target state="translated">在下一次執行迴圈時，$letter 設為"b"，等等。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>After the Foreach loop displays the letter d, Windows PowerShell exits the loop.</source>
          <target state="translated">「 Foreach 迴圈 」 顯示的字母 d 之後，Windows PowerShell 就會結束迴圈。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement must appear on a single line to run it as a command at the Windows PowerShell command prompt.</source>
          <target state="translated">整個 Foreach 陳述式必須出現在單行命令在 Windows PowerShell 命令提示字元執行它。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement does not have to appear on a single line if you place the command in a .ps1 script file instead.</source>
          <target state="translated">如果您將命令放.ps1 指令碼檔案，而是出現在同一行上沒有整個 Foreach 陳述式。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Foreach statements can also be used together with cmdlets that return a collection of items.</source>
          <target state="translated">Foreach 陳述式也可以搭配 cmdlet 會傳回集合的項目。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement steps through the list of items that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">在下列範例中，Get-childitem cmdlet 所傳回之項目的清單，Foreach 陳述式逐步。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { Write-Host $file }</source>
          <target state="translated">foreach (在 Get-childitem $file) {Write-host $file}</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can refine the example by using an If statement to limit the results that are returned.</source>
          <target state="translated">您可以修改此範例使用 If 陳述式來限制所傳回的結果。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement performs the same looping operation as the previous example, but it adds an If statement to limit the results to files that are greater than 100 kilobytes (KB):</source>
          <target state="translated">下列範例中，在 Foreach 陳述式會執行與前一個範例中，相同的迴圈作業，但會增加 If 陳述式來將結果限制為大於 100 kb 的檔案︰</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file } }</source>
          <target state="translated">foreach (在 Get-childitem $file) {如果 ($file.length-gt 100 KB) {Write-host $file}}</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach loop uses a property of the $file variable to perform a comparison operation ($file.length -gt 100KB).</source>
          <target state="translated">在此範例中，Foreach 迴圈會使用 $file 變數的屬性，來執行比對作業 ($file.length-gt 100 KB)。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The $file variable contains all the properties in the object that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">$File 變數包含 Get-childitem cmdlet 所傳回的物件中的所有屬性。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Therefore, you can return more than just a file name.</source>
          <target state="translated">因此，您可以傳回不只是檔案名稱。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In the next example, Windows PowerShell returns the length and the last access time inside the statement list:</source>
          <target state="translated">在下一個範例中，Windows PowerShell 會傳回長度與上次存取時間內的陳述式清單︰</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file Write-Host $file.length Write-Host $file.lastaccesstime } }</source>
          <target state="translated">foreach (在 Get-childitem $file) {如果 ($file.length-gt 100 KB) {Write-host $file Write-host $file.length Write-host $file.lastaccesstime}}</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In this example, you are not limited to running a single command in a statement list.</source>
          <target state="translated">在此範例中，您不一定要執行單一命令陳述式清單中。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can also use a variable outside a Foreach loop and increment the variable inside the loop.</source>
          <target state="translated">您也可以使用 Foreach 迴圈以外的變數，並遞增迴圈變數。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following example counts files over 100 KB in size:</source>
          <target state="translated">下列範例會計算檔案超過 100 KB 的大小︰</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>$i = 0 foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file "file size:" ($file.length / 1024).ToString("F0") KB $i = $i + 1 } }</source>
          <target state="translated">$i = 0 foreach (在 Get-childitem $file) {如果 ($file.length-gt 100 KB) {Write-host $file 」 檔案大小: 」 ($file.length / 1024年)。ToString("F0") KB $i = $i + 1}}</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>if ($i -ne 0) { Write-Host Write-Host $i " file(s) over 100 KB in the current directory."}</source>
          <target state="translated">如果 ($i-ne 0) {Write-host Write-host $i 」 檔案超過 100 KB 目前目錄中。"}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>else { Write-Host "No files greater than 100 KB in the current directory."</source>
          <target state="translated">else {Write-host"沒有檔案大於 100 KB，目前的目錄中。 」</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the preceding example, the $i variable is set to 0 outside the loop, and the variable is incremented inside the loop for each file that is found that is larger than 100 KB.</source>
          <target state="translated">在上述範例中，$i 變數設定為 0，外部迴圈，並在變數遞增迴圈的每個檔案位於大於 100 KB。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When the loop exits, an If statement evaluates the value of $i to display a count of all the files over 100 KB.</source>
          <target state="translated">迴圈結束時，If 陳述式會評估 $i 以顯示所有檔案計數超過 100 KB 的值。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Or, it displays a message stating that no files over 100 KB were found.</source>
          <target state="translated">或者，它會顯示訊息，指出沒有超過 100 KB 的檔案找不到。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The previous example also demonstrates how to format the file length results:</source>
          <target state="translated">前一個範例也示範如何設定檔案長度結果的格式︰</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>($file.length / 1024).ToString("F0")</source>
          <target state="translated">($file.length / 1024年)。ToString("F0")</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The value is divided by 1,024 to show the results in kilobytes rather than bytes, and the resulting value is then formatted using the fixed-point format specifier to remove any decimal values from the result.</source>
          <target state="translated">值除以 1024 kb，而不是位元組為單位顯示的結果，並使用定點格式規範來從結果中移除任何十進位值然後格式化產生的值。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The 0 makes the format specifier show no decimal places.</source>
          <target state="translated">0 會顯示任何小數位數的格式規範。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The Foreach Statement Inside a Command Pipeline When Foreach appears in a command pipeline, Windows PowerShell uses the foreach alias, which calls the ForEach-Object command.</source>
          <target state="translated">Foreach 陳述式內命令管線時 Foreach 會出現在命令管線中，Windows PowerShell 會使用 foreach 別名，它會呼叫 Foreach 命令。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When you use the foreach alias in a command pipeline, you do not include the ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>) syntax as you do with the Foreach statement.</source>
          <target state="translated">當您在命令管線中使用 foreach 別名時，您不包含 ($<ph id="ph1">&lt;item&gt;</ph> <ph id="ph2">&lt;collection&gt;</ph>) 語法，為您處理 Foreach 陳述式。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is because the prior command in the pipeline provides this information.</source>
          <target state="translated">這是因為管線中的前一個命令會提供這項資訊。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline is as follows:</source>
          <target state="translated">Foreach 別名時在命令管線中使用的語法如下所示︰</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>| foreach {&lt;command_block&gt;}</source>
          <target state="translated">|foreach {&lt; command_block &gt;}</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, the Foreach loop in the following command displays processes whose working set (memory usage) is greater than 20 megabytes (MB).</source>
          <target state="translated">例如，Foreach 迴圈，下列命令會顯示處理程序的工作集 （記憶體使用量） 大於 20 mb。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The Get-Process command gets all of the processes on the computer.</source>
          <target state="translated">Get-Process 命令會取得電腦上的所有處理程序。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The Foreach alias performs the commands in the script block on each process in sequence.</source>
          <target state="translated">Foreach 別名會依順序執行命令指令碼區塊，在每個處理序中。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The IF statement selects processes with a working set (WS) greater than 20 megabytes.</source>
          <target state="translated">IF 陳述式選取處理程序與工作集 (WS) 大於 20 mb。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Write-Host cmdlet writes the name of the process followed by a colon.</source>
          <target state="translated">Write-host cmdlet 寫入程序後面接著冒號的名稱。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It divides the working set value, which is stored in bytes by 1 megabyte to get the working set value in megabytes.</source>
          <target state="translated">它會將工作設定值，以位元組為單位儲存由 1 mb，以取得工作集值，以 mb 為單位。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Then it converts the result from a double to a string.</source>
          <target state="translated">然後它將結果從雙精度浮點數的字串。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It displays the value as a fixed point number with zero decimals (F0), a space separator (" "), and then "MB".</source>
          <target state="translated">其值顯示成具有零個小數位數 (F0)，空格分隔符號的固定的點數 ("")，並接著 「 MB 」。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Write-Host "Processes with working sets greater than 20 MB."</source>
          <target state="translated">寫入主機 」 處理序工作集大於 20 MB 」。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Get-Process | foreach { if ($_.WS -gt 20MB) { Write-Host $.name ": " ($.WS/1MB).ToString("F0") MB -Separator ""} }</source>
          <target state="translated">Get-process |foreach {如果 ($_。WS-gt 20 MB) {Write-host $.name":"（$。WS/1MB)。ToString("F0") MB-分隔符號""}}</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks.</source>
          <target state="translated">Foreach 別名也支援開頭命令區塊中, 介的命令區塊，並結束命令區塊。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.</source>
          <target state="translated">開始和結束命令區塊，執行一次和中間的命令區塊執行每當 Foreach 迴圈逐一集合或陣列。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline with a beginning, middle, and ending set of command blocks is as follows:</source>
          <target state="translated">Foreach 別名與命令區塊一開頭、 中間名和結束組命令管線中使用時的語法如下所示︰</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>| foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>}{<ph id="ph2">&lt;middle
command_block&gt;</ph>}{<ph id="ph3">&lt;ending command_block&gt;</ph>}</source>
          <target state="translated">|foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>} {<ph id="ph2">&lt;middle
command_block&gt;</ph>} {<ph id="ph3">&lt;ending command_block&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of the beginning, middle, and end command blocks.</source>
          <target state="translated">下列範例示範使用開頭、 中間色彩與結束命令區塊。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach { $fileCount = $directoryCount = 0}{ if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}{ "$directoryCount directories and $fileCount files"}</source>
          <target state="translated">Get-childitem |foreach {$fileCount = $directoryCount = 0} {如果 ($_。PsIsContainer) {$directoryCount + +} else {$fileCount + +}} {"$directoryCount 目錄和 $fileCount 檔案"}</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The beginning block creates and initializes two variables to 0:</source>
          <target state="translated">開頭區塊會建立並初始化為 0 的兩個變數︰</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>{$fileCount = $directoryCount = 0}</source>
          <target state="translated">{$fileCount = $directoryCount = 0}</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The middle block evaluates whether each item returned by Get-ChildItem is a directory or a file:</source>
          <target state="translated">中間的區塊都會評估 Get-childitem 所傳回的每個項目是否是目錄或檔案︰</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>{if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}</source>
          <target state="translated">{如果 ($_。PsIsContainer) {$directoryCount + +} else {$fileCount + +}}</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If the item that is returned is a directory, the $directoryCount variable is incremented by 1.</source>
          <target state="translated">如果傳回的項目是目錄，$directoryCount 變數就會遞增 1。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If the item is not a directory, the $fileCount variable is incremented by 1.</source>
          <target state="translated">如果項目不是目錄，$fileCount 變數就會遞增 1。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The ending block runs after the middle block completes its looping operation and then returns the results of the operation:</source>
          <target state="translated">中介區塊完成其迴圈作業，然後傳回作業的結果後，就會執行結束區塊︰</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>{"$directoryCount directories and $fileCount files"}</source>
          <target state="translated">{"$directoryCount 目錄和 $fileCount 檔案"}</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By using the beginning, middle, and ending command block structure and the pipeline operator, you can rewrite the earlier example to find any files that are greater than 100 KB, as follows:</source>
          <target state="translated">開頭、 中間名和結束命令區塊結構，並使用管線運算子使用，您可以重新撰寫稍早的範例，若要尋找的檔案超過 100 KB，，如下所示︰</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach{ $i = 0}{ if ($_.length -gt 100KB) { Write-Host $.name "file size:" ($.length / 1024).ToString("F0") KB $i++ } }{ if ($i -ne 0) { Write-Host Write-Host "$i file(s) over 100 KB in the current directory."</source>
          <target state="translated">Get-childitem |foreach {$i = 0} {如果 ($_.length-gt 100 KB) {Write-host $.name 」 檔案大小:"($.length / 1024年)。ToString("F0") KB $i + +}} {如果 ($i-ne 0) {Write-host Write-host"$i 檔案超過 100 KB 目前目錄中。 」</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>} else { Write-Host "No files greater than 100 KB in the current directory."}</source>
          <target state="translated">} else {Write-host [沒有檔案大於 100 KB，目前的目錄中。]}</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example, a function which returns the functions that are used in scripts and script modules, demonstrates how to use the MoveNext method (which works similarly to "skip X" on a For loop) and the Current property of the $foreach variable inside of a foreach script block, even if there are unusually- or inconsistently-spaced function definitions that span multiple lines to declare the function name.</source>
          <target state="translated">下列範例中，傳回的函式，以供指令碼和指令碼模組中的函式會示範如何使用 MoveNext 方法 （其運作方式類似 For 迴圈上的 「 略過 X 」） 和目前在 foreach 指令碼區塊，$foreach 變數的屬性，即使有異常或不一致-間距函式定義跨越多行程式碼來宣告函式名稱。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The example also works if there are comments in the functions used in a script or script module.</source>
          <target state="translated">此範例也適用於指令碼或指令碼] 模組的函式中的註解時。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>function Get-FunctionPosition { [CmdletBinding()] [OutputType('FunctionPosition')] param( [Parameter(Position=0, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String[]] $Path</source>
          <target state="translated">函式取得 FunctionPosition {param [CmdletBinding()] [OutputType('FunctionPosition')] ([參數 (位置 = 0 時，強制，ValueFromPipeline，ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String []] $Path</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">)</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>process { try { $filesToProcess = if ($_ -is [System.IO.FileSystemInfo]) {</source>
          <target state="translated">處理序 {嘗試 {$filesToProcess = if ($_-是 [System.IO.FileSystemInfo]) {</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>} else { Get-Item -Path $Path } foreach ($item in $filesToProcess) { if ($item.PSIsContainer -or $item.Extension -notin @('.ps1','.psm1')) { continue } $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile($item.FullName,([REF]$tokens),([REF]$errors)) if ($errors) { Write-Warning "File '$($item.FullName)' has $($errors.Count) parser errors."</source>
          <target state="translated">} else {Get-item-路徑 $Path} foreach (在 $filesToProcess $item) {如果 ($item。PSIsContainer-或 $item。擴充功能-notin @('.ps1','.psm1')) {繼續} $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile ($item。FullName,([REF]$tokens),([REF]$errors)) 如果 ($errors) {Write-warning 」 檔案 ' $($item.FullName)' 有 $($errors.計數） 剖析器錯誤。 」</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>} :tokenLoop foreach ($token in $tokens) { if ($token.Kind -ne 'Function') { continue } $position = $token.Extent.StartLineNumber do { if (-not $foreach.MoveNext()) { break tokenLoop } $token = $foreach.Current } until ($token.Kind -in @('Generic','Identifier')) $functionPosition = [pscustomobject]@{ Name = $token.Text LineNumber = $position Path = $item.FullName } Add-Member -InputObject $functionPosition -TypeName FunctionPosition -PassThru } } } catch { throw } } }</source>
          <target state="translated">}: tokenLoop foreach (在 $tokens $token) {如果 ($token。類型-ne 'Function') {繼續} $position = $token。請勿 Extent.StartLineNumber {如果 (-不 $foreach。MoveNext()) {中斷 tokenLoop} $token = $foreach。目前} 直到 ($token。類型-在 @('Generic','Identifier')) $functionPosition = [pscustomobject] @{名稱 = $token。文字 LineNumber = $position 路徑 = $item。FullName} Add-member-InputObject $functionPosition-TypeName FunctionPosition-PassThru}}} catch {throw}}}</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables about_If Foreach-Object</source>
          <target state="translated">about_Automatic_Variables about_If Foreach-object</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>