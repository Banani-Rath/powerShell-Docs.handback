<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5b8e579930c6ff20a32be902992a0774b5ebfe89</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Functions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c28d666461edba01bcdd7b7831302554d8583c6d</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cde7cb1dca8bcc02b87d8648daa30265095a6c75</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Functions</source>
          <target state="translated">about_Functions</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell 指令程式</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Functions</source>
          <target state="translated">函式</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Functions</source>
          <target state="translated">about_Functions</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Functions</source>
          <target state="translated">about_Functions</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">簡短描述</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how to create and use functions in Windows PowerShell.</source>
          <target state="translated">描述如何建立和使用 Windows PowerShell 中的函式。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細描述</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A function is a list of Windows PowerShell statements that has a name that you assign.</source>
          <target state="translated">函式是 Windows PowerShell 陳述式具有指定名稱的清單。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When you run a function, you type the function name.</source>
          <target state="translated">當您執行的函式時，您會輸入函數名稱。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The statements in the list run as if you had typed them at the command prompt.</source>
          <target state="translated">在清單中的陳述式執行，如果您已在命令提示字元中輸入它們。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Functions can be as simple as:</source>
          <target state="translated">函式可以是一樣簡單︰</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>function Get-PowerShellProcess {Get-Process PowerShell}</source>
          <target state="translated">函式取得 PowerShellProcess {Get-process PowerShell}</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>or as complex as a cmdlet or an application program.</source>
          <target state="translated">或複雜的指令程式或應用程式。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Like cmdlets, functions can have parameters.</source>
          <target state="translated">指令程式，像是函式的參數。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The parameters can be named, positional, switch, or dynamic parameters.</source>
          <target state="translated">參數可以是具名的位置，開關或將動態參數。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Function parameters can be read from the command line or from the pipeline.</source>
          <target state="translated">可以讀取函式參數，從命令列或管線。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Functions can return values that can be displayed, assigned to variables, or passed to other functions or cmdlets.</source>
          <target state="translated">函式可以傳回值可以顯示、 指派給變數，或傳遞至其他函式或指令程式。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The function's statement list can contain different types of statement lists with the keywords Begin, Process, and End.</source>
          <target state="translated">函式的陳述式清單可以包含不同類型的關鍵字 Begin、 Process 和 End 陳述式清單。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>These statement lists handle input from the pipeline differently.</source>
          <target state="translated">這些陳述式清單以不同方式處理來自管線的輸入。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>A filter is a special kind of function that uses the Filter keyword.</source>
          <target state="translated">篩選是一種特殊的函式使用關鍵字篩選器。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Functions can also act like cmdlets.</source>
          <target state="translated">函式也可以像是指令程式。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can create a function that works just like a cmdlet without using C# programming.</source>
          <target state="translated">您可以建立不使用 C# 程式設計的運作方式類似 cmdlet 的函式。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For more information, see about_Functions_Advanced (http://go.microsoft.com/fwlink/?LinkID=144511).</source>
          <target state="translated">如需詳細資訊，請參閱 about_Functions_Advanced (http://go.microsoft.com/fwlink/?LinkID=144511)。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Syntax The following is the syntax for a function:</source>
          <target state="translated">下列語法是函式的語法︰</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>function [&lt;scope:&gt;]<ph id="ph1">&lt;name&gt;</ph> [([type]$parameter1[,[type]$parameter2])] { param([type]$parameter1 [,[type]$parameter2])</source>
          <target state="translated">函式 [&lt; 範圍︰ &gt;]<ph id="ph1">&lt;name&gt;</ph> [([type]$parameter1[,[type]$parameter2])] {param ([type] $parameter1 [，[type] $parameter2])</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>dynamicparam {<ph id="ph1">&lt;statement list&gt;</ph>}</source>
          <target state="translated">dynamicparam {<ph id="ph1">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>begin {<ph id="ph1">&lt;statement list&gt;</ph>} process {<ph id="ph2">&lt;statement list&gt;</ph>} end {<ph id="ph3">&lt;statement list&gt;</ph>} }</source>
          <target state="translated">開始 {<ph id="ph1">&lt;statement list&gt;</ph>} 處理序 {<ph id="ph2">&lt;statement list&gt;</ph>} 結束 {<ph id="ph3">&lt;statement list&gt;</ph>}}</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>A function includes the following items:</source>
          <target state="translated">函式會包含下列項目︰</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>A Function keyword</source>
          <target state="translated">函式關鍵字</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A scope (optional)</source>
          <target state="translated">（選擇性） 在範圍</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A name that you select</source>
          <target state="translated">您選取的名稱</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Any number of named parameters (optional)</source>
          <target state="translated">任何數目的具名參數 （選擇性）</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>One or more Windows PowerShell commands enclosed in braces ({})</source>
          <target state="translated">括號 （{}） 括住的一或多個 Windows PowerShell 命令</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For more information about the Dynamicparam keyword and dynamic parameters in functions, see about_Functions_Advanced_Parameters.</source>
          <target state="translated">如需 Dynamicparam 關鍵字和函式中的動態參數的詳細資訊，請參閱 about_Functions_Advanced_Parameters。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Simple Functions Functions do not have to be complicated to be useful.</source>
          <target state="translated">簡單的函式函數並沒有太複雜，才能發揮作用。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The simplest functions have the following format:</source>
          <target state="translated">最簡單的函式具有下列格式︰</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>function &lt;function-name&gt; {statements}</source>
          <target state="translated">函式 &lt; 函式名稱 &gt; {陳述式。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For example, the following function starts Windows PowerShell with the Run as Administrator option.</source>
          <target state="translated">例如，下列函式會啟動 Windows PowerShell 與執行系統管理員身分。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>function Start-PSAdmin {Start-Process PowerShell -Verb RunAs}</source>
          <target state="translated">函式開始 PSAdmin {Start-process PowerShell-Verb RunAs}</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>To use the function, type: Start-PSAdmin</source>
          <target state="translated">若要使用函數，請輸入︰ 開始 PSAdmin</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To add statements to the function, use a semi-colon (;) to separate the statements, or type each statement on a separate line.</source>
          <target state="translated">要加入函式的陳述式，請使用分號 （;） 分隔，陳述式或個別行上輸入每個陳述式。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For example, the following function finds all .jpg files in the current user's directories that were changed after the start date.</source>
          <target state="translated">例如，下列函式會尋找所有.jpg 檔案開始日期之後已變更的目前使用者的目錄中。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>function Get-NewPix { $start = Get-Date -Month 1 -Day 1 -Year 2010 $allpix = Get-ChildItem -Path $env:UserProfile<ph id="ph1">\*</ph>.jpg -Recurse $allpix | where {$_.LastWriteTime -gt $Start} }</source>
          <target state="translated">函式取得 NewPix {$start = Get-date-Month 1-天 1-2010 年 $allpix = Get-childitem-路徑 $env: UserProfile<ph id="ph1">\*</ph>.jpg-Recurse $allpix | 其中 {$_。LastWriteTime-gt $Start}}</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can create a toolbox of useful small functions.</source>
          <target state="translated">您可以建立實用的小函式的工具箱。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Add these functions to your Windows PowerShell profile, as described in about_Profiles and later in this topic.</source>
          <target state="translated">如在 about_Profiles，本主題稍後所述，則您可以加入您的 Windows PowerShell 設定檔，這些函式。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Function Names You can assign any name to a function, but functions that you share with others should follow the naming rules that have been established for all Windows PowerShell commands.</source>
          <target state="translated">函式名稱您可以指派任何名稱為函式，但您與其他人共用的函數應該遵循所有的 Windows PowerShell 命令所建立的命名規則。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Functions names should consist of a verb-noun pair in which the verb identifies the action that the function performs and the noun identifies the item on which the cmdlet performs its action.</source>
          <target state="translated">動詞-名詞 」 配對，動詞命令識別函式執行的動作，而名詞，才能識別此 cmdlet 會在其執行其動作的項目應該包含函式名稱。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Functions should use the standard verbs that have been approved for all Windows PowerShell commands.</source>
          <target state="translated">函式應使用標準已核准的動詞命令的所有 Windows PowerShell 命令。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>These verbs help us to keep our command names simple, consistent, and easy for users to understand.</source>
          <target state="translated">這些動詞命令可協助我們簡單、 一致且方便使用者了解，讓我們的命令名稱。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For more information about the standard Windows PowerShell verbs, see "Cmdlet Verbs" on MSDN at http://go.microsoft.com/fwlink/?LinkID=160773.</source>
          <target state="translated">如需標準 Windows PowerShell 動詞命令的詳細資訊，請參閱 &lt; Cmdlet 動詞命令"MSDN 在 http://go.microsoft.com/fwlink/?LinkID=160773。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Functions with Parameters You can use parameters with functions, including named parameters, positional parameters, switch parameters, and dynamic parameters.</source>
          <target state="translated">使用參數的函式可以使用參數的函數，包括具名的參數、 位置參數、 切換參數，以及動態參數。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For more information about dynamic parameters in functions, see about_Functions_Advanced_Parameters (http://go.microsoft.com/fwlink/?LinkID=135173).</source>
          <target state="translated">如需函式中的動態參數的詳細資訊，請參閱 about_Functions_Advanced_Parameters (http://go.microsoft.com/fwlink/?LinkID=135173)。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Named Parameters You can define any number of named parameters.</source>
          <target state="translated">具名參數您可以定義任意數目的具名參數。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can include a default value for named parameters, as described later in this topic.</source>
          <target state="translated">本主題稍後所述，您可以包含具名參數的預設值。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can define parameters inside the braces using the Param keyword, as shown in the following sample syntax:</source>
          <target state="translated">您可以定義使用 Param 關鍵字，在括號內的參數，如下列範例語法所示︰</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>function <ph id="ph1">&lt;name&gt;</ph> { param ([type]$parameter1[,[type]$parameter2]) <ph id="ph2">&lt;statement list&gt;</ph> }</source>
          <target state="translated">函式 <ph id="ph1">&lt;name&gt;</ph> {param ([type]$parameter1[,[type]$parameter2]) <ph id="ph2">&lt;statement list&gt;</ph> }</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can also define parameters outside the braces without the Param keyword, as shown in the following sample syntax:</source>
          <target state="translated">下列範例語法所示，您也可以定義 Param 關鍵字，大括號外面的參數︰</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>function <ph id="ph1">&lt;name&gt;</ph> [([type]$parameter1[,[type]$parameter2])] { <ph id="ph2">&lt;statement list&gt;</ph> }</source>
          <target state="translated">函式 <ph id="ph1">&lt;name&gt;</ph> [([type]$parameter1[,[type]$parameter2])] { <ph id="ph2">&lt;statement list&gt;</ph> }</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>There is no difference between these two methods.</source>
          <target state="translated">沒有任何這兩個方法之間的差異。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Use the method that you prefer.</source>
          <target state="translated">使用您偏好的方法。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>When you run the function, the value you supply for a parameter is assigned to a variable that contains the parameter name.</source>
          <target state="translated">當您執行的函式時，您提供參數的值被指派給變數，其中包含參數名稱。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The value of that variable can be used in the function.</source>
          <target state="translated">函式中可用變數的值。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The following example is a function called Get-SmallFiles.</source>
          <target state="translated">下列範例會呼叫 Get SmallFiles 函式。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This function has a $size parameter.</source>
          <target state="translated">此函式具有 $size 參數。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The function displays all the files that are smaller than the value of the $size parameter, and it excludes directories:</source>
          <target state="translated">函式會顯示所有檔案小於 $size 參數的值，它會排除目錄︰</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>function Get-SmallFiles { param ($size) Get-ChildItem c:\ | where {$.Length -lt $Size -and !$.PSIsContainer} }</source>
          <target state="translated">函式取得 SmallFiles {param ($size) Get-childitem c:\ | 其中 {$。長度-lt $Size-和 ！ $。PSIsContainer}}</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>In the function, you can use the $size variable, which is the name defined for the parameter.</source>
          <target state="translated">在函數中，您可以使用 $size 變數，即為參數所定義的名稱。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>To use this function, type the following command:</source>
          <target state="translated">若要使用此函式，輸入下列命令︰</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; function Get-SmallFiles –Size 50</source>
          <target state="translated">C:\PS&amp;GT; &gt; 函式取得 SmallFiles – 大小 50</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>You can also enter a value for a named parameter without the parameter name.</source>
          <target state="translated">您也可以為不含參數名稱的具名參數輸入值。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For example, the following command gives the same result as a command that names the Size parameter:</source>
          <target state="translated">例如，下列命令會指定相同名稱的大小參數的命令結果︰</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; function Get-SmallFiles 50</source>
          <target state="translated">C:\PS&amp;GT; &gt; 函式取得 SmallFiles 50</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>To define a default value for a parameter, type an equal sign and the value after the parameter name, as shown in the following variation of the Get-SmallFiles example:</source>
          <target state="translated">若要定義參數的預設值，輸入等號和值的參數名稱，後面以下變化 Get SmallFiles 範例所示︰</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>function Get-SmallFiles ($size = 100) { Get-ChildItem c:\ | where {$.Length -lt $Size -and !$.PSIsContainer} }</source>
          <target state="translated">函式取得 SmallFiles ($size = 100) {Get-childitem c:\ | 其中 {$。長度-lt $Size-和 ！ $。PSIsContainer}}</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If you type "Get-SmallFiles" without a value, the function assigns 100 to $size.</source>
          <target state="translated">如果您輸入 「 Get SmallFiles 」 沒有值時，函式會指派 100 到 $size。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If you provide a value, the function uses that value.</source>
          <target state="translated">如果您提供的值，此函數會使用該值。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a brief help string that describes the default value of your parameter, by adding the PSDefaultValue attribute to the description of your parameter, and specifying the Help property of PSDefaultValue.</source>
          <target state="translated">或者，您可以提供簡短說明字串，描述您的參數的預設值將 PSDefaultValue 屬性加入至您的參數的描述，並指定 PSDefaultValue 的 [說明] 屬性。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>To provide a help string that describes the default value (100) of the Size parameter in the Get-SmallFiles function, add the PSDefaultValue attribute as shown in the following example.</source>
          <target state="translated">若要提供描述 Get SmallFiles 函式中的 Size 參數的預設值 (100) 的說明字串，請新增 PSDefaultValue 屬性，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>function Get-SmallFiles { param ( [PSDefaultValue(Help = '100')] $size = 100</source>
          <target state="translated">函式取得 SmallFiles {param ([PSDefaultValue (說明 = '100')] $size = 100</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more information about the PSDefaultValue attribute class, see PSDefaultValue Attribute Members on MSDN.</source>
          <target state="translated">如需 PSDefaultValue 屬性類別的詳細資訊，請參閱 MSDN 上的 PSDefaultValue 屬性成員。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>(http://msdn.microsoft.com/library/windows/desktop/system.management.automation.psdefaultvalueattribute_members(v=vs.85).aspx</source>
          <target state="translated">(http://msdn.microsoft.com/library/windows/desktop/system.management.automation.psdefaultvalueattribute_members (vs.85</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Positional Parameters A positional parameter is a parameter without a parameter name.</source>
          <target state="translated">位置參數的位置參數是不含參數名稱的參數。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Windows PowerShell uses the parameter value order to associate each parameter value with a parameter in the function.</source>
          <target state="translated">Windows PowerShell 會使用參數值的順序，將每個參數值與函式中的參數產生關聯。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When you use positional parameters, type one or more values after the function name.</source>
          <target state="translated">當您使用位置參數時，請函式名稱後面輸入一個或多個值。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Positional parameter values are assigned to the $args array variable.</source>
          <target state="translated">位置參數值會指派給 $args 陣列變數。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The value that follows the function name is assigned to the first position in the $args array, $args[0].</source>
          <target state="translated">在函式名稱的值會指派給 $args 陣列 $args [0] 中的第一個位置。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The following Get-Extension function adds the .txt file name extension to a file name that you supply:</source>
          <target state="translated">下列 Get 擴充函式會將您提供的檔案名稱.txt 副檔名︰</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>function Get-Extension { $name = $args[0] + ".txt" $name }</source>
          <target state="translated">函式取得延伸 {$name = $args [0] +".txt"$name}</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Get-Extension myTextFile myTextFile.txt</source>
          <target state="translated">C:\PS&amp;GT; &gt; 取得延伸 myTextFile myTextFile.txt</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Switch Parameters A switch is a parameter that does not require a value.</source>
          <target state="translated">切換參數的參數是不需要值的參數。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Instead, you type the function name followed by the name of the switch parameter.</source>
          <target state="translated">相反地，您輸入函數名稱後面加上切換參數的名稱。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>To define a switch parameter, specify the type [switch] before the parameter name, as shown in the following example:</source>
          <target state="translated">若要切換參數，指定的參數名稱前面的型別 [參數]，如下列範例所示︰</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>function Switch-Item { param ([switch]$on) if ($on) { "Switch on" } else { "Switch off" } }</source>
          <target state="translated">函式參數項目 {param （在 [參數] $） 如果 （$） {「 切換 」} else {「 關閉 」}}</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>When you type the On switch parameter after the function name, the function displays "Switch on".</source>
          <target state="translated">當您在函式名稱後面輸入 On 切換參數時，函式會顯示 「 切換 」。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Without the switch parameter, it displays "Switch off".</source>
          <target state="translated">不含參數的參數，它會顯示 「 關閉 」。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Switch-Item -on Switch on</source>
          <target state="translated">C:\PS&amp;GT; &gt; 切換項目位在交換器上</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Switch-Item Switch off</source>
          <target state="translated">C:\PS&amp;GT; &gt; 關閉切換項目</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>You can also assign a Boolean value to a switch when you run the function, as shown in the following example:</source>
          <target state="translated">您也可以切換至指派的布林值，當您執行函式，就如下列範例所示︰</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Switch-Item -on:$true Switch on</source>
          <target state="translated">C:\PS&amp;GT; &gt; 切換項目位在︰ $true 切換成開啟</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; Switch-Item -on:$false Switch off</source>
          <target state="translated">C:\PS&amp;GT; &gt; 切換項目位在︰ $false 關閉</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Using Splatting to Represent Command Parameters You can use splatting to represent the parameters of a command.</source>
          <target state="translated">使用 Splatting 来代表命令參數，可以使用 splatting 來代表命令的參數。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This feature is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">這項功能是在 Windows PowerShell 3.0 引進。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Use this technique in functions that call commands in the session.</source>
          <target state="translated">工作階段中呼叫命令的函式中使用這項技術。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>You do not need to declare or enumerate the command parameters, or change the function when command parameters change.</source>
          <target state="translated">您不需要宣告或列舉的命令參數，或變更函式命令參數變更時。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The following sample function calls the Get-Command cmdlet.</source>
          <target state="translated">下列範例函數會呼叫 Get 命令的指令程式。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The command uses @Args to represent the parameters of Get-Command.</source>
          <target state="translated">此命令會使用 @Args 代表 Get 命令的參數。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>function Get-MyCommand { Get-Command @Args }</source>
          <target state="translated">函式取得 MyCommand {Get 命令 @Args}</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You can use all of the parameters of Get-Command when you call the Get-MyCommand function.</source>
          <target state="translated">當您呼叫 Get MyCommand 函式時，您可以使用的所有 Get 命令參數。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The parameters and parameter values are passed to the command using @Args.</source>
          <target state="translated">參數和參數值會傳遞給使用 @Args 命令。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>PS C:&gt;Get-MyCommand -Name Get-ChildItem CommandType     Name                ModuleName</source>
          <target state="translated">PS C: &gt; Get MyCommand-名稱-Get-childitem CommandType 名稱 ModuleName</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Cmdlet          Get-ChildItem       Microsoft.PowerShell.Management</source>
          <target state="translated">Cmdlet Get-childitem Microsoft.PowerShell.Management</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The @Args feature uses the $Args automatic parameter, which represents undeclared cmdlet parameters and values from remaining arguments.</source>
          <target state="translated">@Args 功能會使用 $Args 自動參數，表示未宣告的 cmdlet 參數值從剩餘的引數。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For more information about splatting, see about_Splatting (http://go.microsoft.com/fwlink/?LinkId=262720).</source>
          <target state="translated">如需 splatting 的詳細資訊，請參閱 about_Splatting (http://go.microsoft.com/fwlink/?LinkId=262720)。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Piping Objects to Functions Any function can take input from the pipeline.</source>
          <target state="translated">任何函式可以接受從管線輸入函式的管線物件。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>You can control how a function processes input from the pipeline using Begin, Process, and End keywords.</source>
          <target state="translated">您可以控制函式如何處理來自使用 Begin、 Process 及 End 關鍵字管線的輸入。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following sample syntax shows the three keywords:</source>
          <target state="translated">下列範例語法顯示三個關鍵字︰</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>function <ph id="ph1">&lt;name&gt;</ph> { begin {<ph id="ph2">&lt;statement list&gt;</ph>} process {<ph id="ph3">&lt;statement list&gt;</ph>} end {<ph id="ph4">&lt;statement list&gt;</ph>} }</source>
          <target state="translated">函式 <ph id="ph1">&lt;name&gt;</ph> {開始 {<ph id="ph2">&lt;statement list&gt;</ph>} 處理序 {<ph id="ph3">&lt;statement list&gt;</ph>} 結束 {<ph id="ph4">&lt;statement list&gt;</ph>}}</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The Begin statement list runs one time only, at the beginning of the function.</source>
          <target state="translated">Begin 陳述式清單只執行一次，在函式的開頭。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The Process statement list runs one time for each object in the pipeline.</source>
          <target state="translated">處理程序陳述式清單會在管線中執行一次，每個物件。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>While the Process block is running, each pipeline object is assigned to the $_ automatic variable, one pipeline object at a time.</source>
          <target state="translated">執行程序區塊時，每個管線物件會指派給 $_ 自動變數，一次一個的管線物件。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>After the function receives all the objects in the pipeline, the End statement list runs one time.</source>
          <target state="translated">函式接收管線中的所有物件之後，結束陳述式清單就會執行一次。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>If no Begin, Process, or End keywords are used, all the statements are treated like an End statement list.</source>
          <target state="translated">如果沒有 Begin、 程序或 End 關鍵字，所有陳述式會視為結束陳述式清單。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>The following function uses the Process keyword.</source>
          <target state="translated">下列函式會使用處理序關鍵字。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The function displays examples from the pipeline:</source>
          <target state="translated">函式會顯示來自管線的範例︰</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>function Get-Pipeline { process {"The value is: $_"} }</source>
          <target state="translated">函式取得管線 {程序 {"的值: $_"}}</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>To demonstrate this function, enter an list of numbers separated by commas, as shown in the following example:</source>
          <target state="translated">為了示範這個函式，請輸入以逗號分隔的數字的清單，如下列範例所示︰</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; 1,2,4 | Get-Pipeline The value is: 1 The value is: 2 The value is: 4</source>
          <target state="translated">C:\PS&amp;GT; &gt; 1,2,4 |取得管線的值是︰ 1 的值是︰ 2 的值︰ 4</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>When you use a function in a pipeline, the objects piped to the function are assigned to the $input automatic variable.</source>
          <target state="translated">當您在管線中使用函式時，使用管線傳送至函式的物件會指派給 $input 自動變數。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The function runs statements with the Begin keyword before any objects come from the pipeline.</source>
          <target state="translated">來自管線的任何物件之前，函數會執行陳述式開始關鍵字。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The function runs statements with the End keyword after all the objects have been received from the pipeline.</source>
          <target state="translated">函式會執行陳述式與 End 關鍵字之後尚未收到來自管線的所有物件。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The following example shows the $input automatic variable with Begin and End keywords.</source>
          <target state="translated">下列範例使用 Begin 和 End 關鍵字 $input 自動變數。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>function Get-PipelineBeginEnd { begin {"Begin: The input is $input"} end {"End:   The input is $input" } }</source>
          <target state="translated">函式取得 PipelineBeginEnd {開始 {」 開始︰ 輸入是 $input"} 結束 {"結束︰ 輸入是 $input"}}</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If this function is run by using the pipeline, it displays the following results:</source>
          <target state="translated">如果此函式由使用管線中執行，則會顯示下列結果︰</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; 1,2,4 | Get-PipelineBeginEnd Begin: The input is End:   The input is 1 2 4</source>
          <target state="translated">C:\PS&amp;GT; &gt; 1,2,4 |Get PipelineBeginEnd 開始︰ 輸入是結束︰ 輸入為 1 2 4</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>When the Begin statement runs, the function does not have the input from the pipeline.</source>
          <target state="translated">Begin 陳述式執行時，此函式並沒有來自管線的輸入。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The End statement runs after the function has the values.</source>
          <target state="translated">End 陳述式會執行函式後的值。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>If the function has a Process keyword, the function reads the data in $input.</source>
          <target state="translated">如果函式的處理序關鍵字，函式會讀取 $input 中的資料。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The following example has a Process statement list:</source>
          <target state="translated">下列範例具有處理程序陳述式清單︰</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>function Get-PipelineInput { process {"Processing:  $_ " } end {"End:   The input is: $input" } }</source>
          <target state="translated">函式取得 PipelineInput {程序 {」 處理: $_"} 結束 {"結束︰ 輸入是︰ $input"}}</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>In this example, each object that is piped to the function is sent to the Process statement list.</source>
          <target state="translated">在此範例中，會被輸送到函數的每個物件傳送至處理程序陳述式清單。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The Process statements run on each object, one object at a time.</source>
          <target state="translated">每一個物件上執行的程序陳述式一次一個物件。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The $input automatic variable is empty when the function reaches the End keyword.</source>
          <target state="translated">當函式到達 End 關鍵字 $input 自動變數是空的。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; 1,2,4 | Get-PipelineInput Processing:  1 Processing:  2 Processing:  4 End:   The input is:</source>
          <target state="translated">C:\PS&amp;GT; &gt; 1,2,4 |Get PipelineInput 處理︰ 1 的處理︰ 2 處理︰ 4 結束︰ 輸入是︰</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Filters A filter is a type of function that runs on each object in the pipeline.</source>
          <target state="translated">篩選條件的篩選器是一種在管線中的每個物件執行的函式。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>A filter resembles a function with all its statements in a Process block.</source>
          <target state="translated">篩選條件類似 Process 區塊中所有的陳述式的函式。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The syntax of a filter is as follows:</source>
          <target state="translated">篩選條件的語法如下所示︰</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>filter [&lt;scope:&gt;]<ph id="ph1">&lt;name&gt;</ph> {<ph id="ph2">&lt;statement list&gt;</ph>}</source>
          <target state="translated">篩選 [&lt; 範圍︰ &gt;]<ph id="ph1">&lt;name&gt;</ph> {<ph id="ph2">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The following filter takes log entries from the pipeline and then displays either the whole entry or only the message portion of the entry:</source>
          <target state="translated">下列篩選條件會接受來自管線的記錄項目，並接著會顯示整個項目或只有訊息部分的項目︰</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>filter Get-ErrorLog ([switch]$message) { if ($message) { out-host -inputobject $<bpt id="p1">_</bpt>.Message } else { $<ept id="p1">_</ept> } }</source>
          <target state="translated">篩選取得錯誤記錄檔 （[參數] $message） {如果 ($message) {out-host-inputobject $<bpt id="p1">_</bpt>。訊息} else {$<ept id="p1">_</ept> }}</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>Function Scope A function exists in the scope in which it was created.</source>
          <target state="translated">函式範圍的函式存在於建立所在的範圍。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>If a function is part of a script, the function is available to statements within that script.</source>
          <target state="translated">函式是指令碼的一部分，此函式可使用該指令碼內的陳述式。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>By default, a function in a script is not available at the command prompt.</source>
          <target state="translated">根據預設，指令碼中的函式沒有在命令提示字元。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>You can specify the scope of a function.</source>
          <target state="translated">您可以指定函式的範圍。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For example, the function is added to the global scope in the following example:</source>
          <target state="translated">例如，函式會加入至全域範圍，在下列範例中︰</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>function global:Get-DependentSvs { Get-Service | where {$_.DependentServices} }</source>
          <target state="translated">全域函式︰ Get DependentSvs {Get-service | 其中 {$_。DependentServices}}</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>When a function is in the global scope, you can use the function in scripts, in functions, and at the command line.</source>
          <target state="translated">在全域範圍中函式時，您可以使用指令碼，在函數中，並在命令列中的函式。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Functions normally create a scope.</source>
          <target state="translated">函式通常會建立一個領域。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The items created in a function, such as variables, exist only in the function scope.</source>
          <target state="translated">建立函式，例如變數中的項目只存在於函式範圍。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For more information about scope in Windows PowerShell, see about_Scopes (http://go.microsoft.com/fwlink/?LinkID=113260).</source>
          <target state="translated">如需 Windows PowerShell 中範圍的詳細資訊，請參閱 about_Scopes (http://go.microsoft.com/fwlink/?LinkID=113260)。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Finding and Managing Functions Using the Function: Drive All the functions and filters in Windows PowerShell are automatically stored in the Function: drive.</source>
          <target state="translated">尋找並管理函式使用的函式︰ 磁碟機所有函式和在 Windows PowerShell 中的篩選器會自動儲存在函式︰ 磁碟機。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>This drive is exposed by the Windows PowerShell Function provider.</source>
          <target state="translated">此磁碟機是由 Windows PowerShell 函式提供者公開的。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>When referring to the Function: drive, type a colon after Function, just as you would do when referencing the C or D drive of a computer.</source>
          <target state="translated">參考的函式時︰ 磁碟機，請輸入函式，後面的冒號，就像您一樣參考 C 或 D 磁碟機的電腦時。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The following command displays all the functions in the current session of Windows PowerShell:</source>
          <target state="translated">下列命令會顯示目前的工作階段的 Windows PowerShell 中的所有函式︰</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Get-ChildItem function:</source>
          <target state="translated">Get-childitem 函式︰</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The commands in the function are stored as a script block in the definition property of the function.</source>
          <target state="translated">函式中的命令會儲存為定義屬性的函式中的指令碼區塊。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>For example, to display the commands in the Help function that comes with Windows PowerShell, type:</source>
          <target state="translated">例如，若要命令顯示隨附於 Windows PowerShell 說明函式，請輸入︰</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>(Get-ChildItem function:help).Definition</source>
          <target state="translated">（Get-childitem 函式︰ 說明）。定義</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>For more information about the Function: drive, see the help topic for the Function provider.</source>
          <target state="translated">如需函式的詳細資訊︰ 磁碟機，請如函式提供者，請參閱 [說明] 主題。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Type "Get-Help Function" or view it in the TechNet Library at http://go.microsoft.com/fwlink/?LinkID=113436.</source>
          <target state="translated">輸入 「 取得說明函式 」 或 http://go.microsoft.com/fwlink/?LinkID=113436 在 TechNet Library 中檢視它。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Reusing Functions in New Sessions When you type a function at the Windows PowerShell command prompt, the function becomes part of the current session.</source>
          <target state="translated">當您在 Windows PowerShell 命令提示字元中輸入函式的新工作階段中，重複使用函式，函式會成為目前的工作階段的一部分。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>It is available until the session ends.</source>
          <target state="translated">此功能使用，直到工作階段結束為止。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>To use your function in all Windows PowerShell sessions, add the function to your Windows PowerShell profile.</source>
          <target state="translated">若要使用您的函式，所有的 Windows PowerShell 工作階段中，加入至您的 Windows PowerShell 設定檔的函式。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>For more information about profiles, see about_Profiles (http://go.microsoft.com/fwlink/?LinkID=113729).</source>
          <target state="translated">如需有關設定檔的詳細資訊，請參閱 about_Profiles (http://go.microsoft.com/fwlink/?LinkID=113729)。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>You can also save your function in a Windows PowerShell script file.</source>
          <target state="translated">您也可以在 Windows PowerShell 指令碼檔案中儲存您的函式。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Type your function in a text file, and then save the file with the .ps1 file name extension.</source>
          <target state="translated">在文字檔案中，輸入您的函式，然後以.ps1 副檔名儲存檔案。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Writing Help for Functions The Get-Help cmdlet gets help for functions, as well as for cmdlets, providers, and scripts.</source>
          <target state="translated">說明撰寫函式取得說明 cmdlet 取得說明函式，以及 cmdlet、 提供者和指令碼。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>To get help for a function, type Get-Help followed by the function name.</source>
          <target state="translated">若要取得函式的說明，請輸入 Get-help 後面接著函數名稱。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>For example, to get help for the Get-MyDisks function, type:</source>
          <target state="translated">例如，若要取得 Get MyDisks 函式的說明，請輸入︰</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Get-Help Get-MyDisks</source>
          <target state="translated">取得說明 Get MyDisks</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>You can write help for a function by using either of the two following methods:</source>
          <target state="translated">您可以撰寫函數的說明，使用下列兩種方法之一︰</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>--  Comment-Based Help  for Functions</source>
          <target state="translated">-註解式函數的說明</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Create a help topic by using special keywords in the comments.</source>
          <target state="translated">註解中使用特殊關鍵字，以建立 「 說明 」 主題。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>To create comment-based help for a function, the comments must be placed at the beginning or end of the function body or on the lines preceding the function keyword.</source>
          <target state="translated">若要建立註解說明函式，必須開頭或結尾的函式主體或前面 function 關鍵字的程式行上放置註解。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>For more information about comment-based help, see about_Comment_Based_Help.</source>
          <target state="translated">如需有關註解式說明的詳細資訊，請參閱 about_Comment_Based_Help。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>--  XML-Based Help  for Functions</source>
          <target state="translated">-XML 架構函數的說明</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Create an XML-based help topic, such as the type that is typically created for cmdlets.</source>
          <target state="translated">建立以 XML 為基礎的說明主題，例如通常 cmdlet 所建立的類型。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>XML-based help is required if you are localizing help topics into multiple languages.</source>
          <target state="translated">如果您在進行當地語系化成多個語言的說明主題需要以 XML 為基礎的說明。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>To associate the function with the XML-based help topic, use the .ExternalHelp comment-based help keyword.</source>
          <target state="translated">若要以 XML 為基礎的 [說明] 主題關聯的函式，使用。ExternalHelp 註解式說明關鍵字。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Without this keyword, Get-Help cannot find the function help topic and calls to Get-Help for the function return only auto-generated help.</source>
          <target state="translated">此關鍵字，取得說明找不到函式的 [說明] 主題，並取得說明函式呼叫會傳回只自動產生的說明。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>For more information about the ExternalHelp keyword, see about_Comment_Based_Help.</source>
          <target state="translated">如需 ExternalHelp 關鍵字的詳細資訊，請參閱 about_Comment_Based_Help。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>For more information about XML-based help, see "How to Write Cmdlet Help" in MSDN.</source>
          <target state="translated">如需以 XML 為基礎的說明，請參閱 「 如何撰寫 Cmdlet 說明 「 MSDN 中。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables about_Comment_Based_Help about_Functions_Advanced about_Functions_Advanced_Methods about_Functions_Advanced_Parameters about_Functions_CmdletBindingAttribute about_Functions_OutputTypeAttribute about_Parameters about_Profiles about_Scopes about_Script_Blocks Function (provider)</source>
          <target state="translated">about_Automatic_Variables about_Comment_Based_Help about_Functions_Advanced about_Functions_Advanced_Methods about_Functions_Advanced_Parameters about_Functions_CmdletBindingAttribute about_Functions_OutputTypeAttribute about_Parameters about_Profiles about_Scopes about_Script_Blocks 函式 （提供者）</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>