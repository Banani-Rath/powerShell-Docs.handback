<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">34e841a089b283126a77bc2f852a5064cc7d276d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_Command_Precedence.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3d4cf30f97f0e396525757e3a7d4093604358733</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff216515ee10fbdc6f1053f80852fa01f0958004</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell 指令程式</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Command Precedence</source>
          <target state="translated">有關命令優先順序</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">簡短描述</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how Windows PowerShell determines which command to run.</source>
          <target state="translated">描述 Windows PowerShell 如何決定要執行哪個命令。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細描述</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic explains how Windows PowerShell determines which command to run, especially when a session contains more than one command with the same name.</source>
          <target state="translated">本主題說明 Windows PowerShell 如何判斷哪些命令來執行，尤其是當工作階段包含一個以上具有相同名稱的命令。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It also explains how to run commands that do not run by default, and it explains how to avoid command-name conflicts in your session.</source>
          <target state="translated">它也會說明如何執行命令，根據預設，不會執行，並且說明如何避免在您的工作階段中的命令名稱衝突。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>COMMAND PRECEDENCE</source>
          <target state="translated">命令優先順序</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When a session includes commands that have the same name, Windows PowerShell uses the following rules to decide which command to run.</source>
          <target state="translated">當工作階段包含具有相同名稱的命令時，Windows PowerShell 會使用下列規則來決定要執行哪個命令。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>These rules become very important when you add commands to your session from modules, snap-ins, and other sessions.</source>
          <target state="translated">將命令加入至您的工作階段的模組、 嵌入式管理單元和其他工作階段時，這些規則變得非常重要。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>-- If you specify the path to a command, Windows PowerShell runs the command at the location specified by the path.</source>
          <target state="translated">--如果您指定命令的路徑時，Windows PowerShell 會執行的命令路徑所指定的位置。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the following command runs the FindDocs.ps1 script in the C:\TechDocs directory:</source>
          <target state="translated">例如，下列命令來執行 FindDocs.ps1 指令碼 C:\TechDocs 目錄中︰</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>C:\TechDocs\FindDocs.ps1</source>
          <target state="translated">C:\TechDocs\FindDocs.ps1</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>As a security feature, Windows PowerShell does not run executable (native) commands, including Windows PowerShell scripts, unless the command is located in a path that is listed in the Path environment variable ($env:path) or unless you specify the path to the script file.</source>
          <target state="translated">做為安全性功能，Windows PowerShell 不會執行可執行檔 （原生） 的命令，包括 Windows PowerShell 指令碼，除非命令位於 Path 環境變數中所列的路徑 ($env︰ 路徑)，或您指定的指令碼檔案的路徑。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>To run a script that is in the current directory, specify the full path, or type a dot (.) to represent the current directory.</source>
          <target state="translated">若要執行的指令碼，是目前目錄中，指定完整路徑，或輸入一個點 （.） 來表示目前的目錄。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example, to run the FindDocs.ps1 file in the current directory, type:</source>
          <target state="translated">例如，若要在目前的目錄執行 FindDocs.ps1 檔案，請輸入︰</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>.\FindDocs.ps1</source>
          <target state="translated">.\FindDocs.ps1</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>-- If you do not specify a path, Windows PowerShell uses the following precedence order when it runs commands:</source>
          <target state="translated">--如果您未指定路徑，Windows PowerShell 執行命令時，就會使用下列優先順序︰</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">別名</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">函式</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Cmdlet</source>
          <target state="translated">Cmdlet</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Native Windows commands</source>
          <target state="translated">原生的 Windows 命令</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Therefore, if you type "help", Windows PowerShell first looks for an alias named "help", then a function named "Help", and finally a cmdlet named "Help".</source>
          <target state="translated">因此，如果您輸入 「 說明 」，Windows PowerShell 會先尋找名為 「 說明 」，則函式名為 「 說明 」，並在最後 cmdlet 名為 「 說明 」 的別名。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It runs the first "help" item that it finds.</source>
          <target state="translated">它會執行第一個 [說明] 項目所找到。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, if you have a Get-Map function in the session and you import a cmdlet named Get-Map.</source>
          <target state="translated">例如，如果您有工作階段中的 Get 對應函式，而您匯入名為 Get 對應 cmdlet。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>By default, when you type "Get-Map", Windows PowerShell runs the Get-Map function.</source>
          <target state="translated">根據預設，當您輸入 「 Get-對應 」，Windows PowerShell 會執行 Get Map 函式。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-- When the session contains items of the same type that have the same name, such as two cmdlets with the same name, Windows PowerShell runs the item that was added to the session most recently.</source>
          <target state="translated">--當工作階段包含具有相同的名稱，例如具有相同名稱的兩個 cmdlet 相同型別的項目 Windows PowerShell 會執行到最近的工作階段已加入的項目。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, if you have a cmdlet named Get-Date and you import another cmdlet named Get-Date, by default, Windows PowerShell runs the most-recently imported cmdlet when you type "Get-Date".</source>
          <target state="translated">比方說，如果您擁有名為 Get-date 指令程式，並匯入另一個 cmdlet 的名稱取得日期，根據預設，Windows PowerShell 會執行最近匯入的 cmdlet 時輸入"Get-date"。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>HIDDEN and REPLACED ITEMS As a result of these rules, items can be replaced or hidden by items with the same name.</source>
          <target state="translated">隱藏和 REPLACED 的項目，因為這些規則，項目可以取代或隱藏具有相同名稱的項目。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>--  Items are "hidden" or "shadowed" if you can still access the original item, such as by qualifying the item name with a module or snap-in name.</source>
          <target state="translated">-項目 「 隱藏 」 或者 「 遮蔽 」 如果仍然可以存取原始的項目，例如來限定項目名稱與模組或嵌入式管理單元名稱。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, if you import a function that has the same name as a cmdlet in the session, the cmdlet is hidden (but not replaced) because it was imported from a snap-in or module.</source>
          <target state="translated">比方說，如果您匯入工作階段中具有相同的名稱為指令程式的函式，此指令程式會隱藏 （但不是會被取代） 因為它從嵌入式管理單元或模組匯入。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>--  Items are "replaced" or "overwritten" if you can no longer access the original item.</source>
          <target state="translated">-項目 「 取代 」 或者 「 覆寫 「 如果您將無法再存取原始的項目。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, if you import a variable that has the same name as a a variable in the session, the original variable is replaced and is no longer accessible.</source>
          <target state="translated">例如，如果您匯入具有相同名稱的變數中工作階段的變數，原始變數取代，且已無法存取。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You cannot qualify a variable with a module name.</source>
          <target state="translated">您不能限制具有模組名稱的變數。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Also, if you type a function at the command line and then import a function with the same name, the original function is replaced and is no longer accessible.</source>
          <target state="translated">此外，如果您在命令列中輸入函式，然後匯入具有相同名稱的函式，原始函式會被取代，而且已無法存取。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>FINDING HIDDEN COMMANDS</source>
          <target state="translated">尋找隱藏命令</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The All parameter of the Get-Command cmdlet gets all commands with the specified name, even if they are hidden or replaced.</source>
          <target state="translated">Get 命令指令程式的所有參數都取得具有指定名稱的所有命令，即使它們是隱藏或取代。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, by default, Get-Command gets only the commands that run when you type the command name.</source>
          <target state="translated">根據預設，Windows PowerShell 3.0 中，從 Get 命令取得您輸入命令名稱時執行的命令。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In the following examples, the session includes a Get-Date function and a Get-Date cmdlet.</source>
          <target state="translated">在下列範例中，工作階段包含 Get-date 函式和 Get-date 指令程式。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following command gets the Get-Date command that runs when you type "Get-Date".</source>
          <target state="translated">下列命令會取得您輸入"Get-date 」 時執行的 Get-date 命令。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-Command Get-Date</source>
          <target state="translated">PS C: &gt; Get 命令取得日期</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>CommandType     Name                                               ModuleName</source>
          <target state="translated">CommandType 名稱 ModuleName</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Function        get-date</source>
          <target state="translated">函式取得日期</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following command uses the All parameter to get all Get-Date commands.</source>
          <target state="translated">下列命令會使用所有的參數，取得所有 Get-date 命令。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-Command Get-Date -All</source>
          <target state="translated">PS C: &gt; Get-command Get-date-所有</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>CommandType     Name                                               ModuleName</source>
          <target state="translated">CommandType 名稱 ModuleName</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Function        get-date Cmdlet          Get-Date                                           Microsoft.PowerShell.Utility</source>
          <target state="translated">函式取得日期 Cmdlet 取得日期 Microsoft.PowerShell.Utility</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>RUNNING HIDDEN COMMANDS</source>
          <target state="translated">執行隱藏的命令</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can run particular commands by specifying item properties that distinguish the command from other commands that might have the same name.</source>
          <target state="translated">您可以藉由指定命令區別其他命令，可能會具有相同名稱的項目內容中執行特定命令。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can use this method to run any command, but it is especially useful for running hidden commands.</source>
          <target state="translated">您可以使用這個方法來執行任何命令，但執行隱藏的命令特別有用。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Use this method as a best practice when writing scripts that you intend to distribute because you cannot predict which commands might be present in the session in which the script runs.</source>
          <target state="translated">撰寫您想要發佈，因為您無法預測哪些命令可能會出現在其中執行指令碼工作階段中的指令碼時，最佳作法是使用這個方法。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>QUALIFIED NAMES</source>
          <target state="translated">限定的名稱</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can run commands that have been imported from a Windows PowerShell snap-in or module or from another session by qualifying the command name with the name of the module or snap-in in which it originated.</source>
          <target state="translated">您可以執行已匯入從 Windows PowerShell 嵌入式管理單元或模組，或從另一個工作階段來限定命令名稱的模組名稱的命令或嵌入式管理單元起源自。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can qualify commands, but you cannot qualify variables or aliases.</source>
          <target state="translated">您可以命令，但您無法將變數或別名限定。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For example, if the Get-Date cmdlet from the Microsoft.PowerShell.Utility snap-in is hidden by an alias, function, or cmdlet with the same name, you can run it by using the snap-in-qualified name of the cmdlet:</source>
          <target state="translated">比方說，如果 Microsoft.PowerShell.Utility 嵌入式管理單元從 Get-date 指令程式隱藏的別名、 函式或具有相同名稱的指令程式，您可以執行它使用 cmdlet 的嵌入式管理單元限定名稱︰</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Microsoft.PowerShell.Utility\Get-Date</source>
          <target state="translated">Microsoft.PowerShell.Utility\Get-Date</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To run a New-Map command that was added by the MapFunctions module, use its module-qualified name:</source>
          <target state="translated">若要執行 MapFunctions 模組所加入的新對應命令，使用模組完整名稱︰</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>MapFunctions\New-Map</source>
          <target state="translated">MapFunctions\New 對應</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To find the snap-in or module from which a command was imported, use the ModuleName property of commands.</source>
          <target state="translated">若要尋找的嵌入式管理單元或命令匯入的模組，使用 ModuleName 屬性的命令。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>(Get-Command &lt;command-name&gt;).ModuleName</source>
          <target state="translated">(Get-command &lt; 命令名稱 &gt;)。ModuleName</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, to find the source of the Get-Date cmdlet, type:</source>
          <target state="translated">例如，若要尋找 Get-date 指令程式的來源，請輸入︰</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>PS C:&gt;(Get-Command Get-Date).ModuleName Microsoft.PowerShell.Utility</source>
          <target state="translated">PS C: &gt; (Get 命令取得日期)。ModuleName Microsoft.PowerShell.Utility</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>CALL OPERATOR</source>
          <target state="translated">呼叫運算子</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can also use the Call operator (&amp;) to run any command that you can get by using a Get-ChildItem (the alias is "dir"), Get-Command, or Get-Module command.</source>
          <target state="translated">您也可以使用呼叫運算子 (&amp;) 來執行任何命令，您可以藉由使用 Get-childitem （別名是"dir"）、 Get 命令或取得模組命令。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>To run a command, enclose the Get-Command command in parentheses, and use the Call operator (&amp;) to run the command.</source>
          <target state="translated">若要執行命令、 括號括住 Get 命令，並使用呼叫運算子 (&amp;) 來執行命令。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>&amp;(Get-Command ...)</source>
          <target state="translated">&amp; (Get-command...)</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>or -</source>
          <target state="translated">或-</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>&amp;(dir ... )</source>
          <target state="translated">&amp;(dir...)</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For example, if you have a function named Map that is hidden by an alias named Map, use the following command to run the function.</source>
          <target state="translated">例如，如果您擁有名為隱藏的別名名稱的對應的對應函式，請使用下列命令來執行該函數。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>&amp;(Get-Command -Name Map -Type function)</source>
          <target state="translated">&amp; (Get-command-名稱對應的類型函式)</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>or -</source>
          <target state="translated">或-</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>&amp;(dir function:\map)</source>
          <target state="translated">&amp; (dir 函式︰ \map)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can also save your hidden command in a variable to make it easier to run.</source>
          <target state="translated">您也可以在變數中以方便執行儲存在隱藏的命令。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For example, the following command saves the Map function in the $myMap variable and then uses the Call operator to run it.</source>
          <target state="translated">比方說，下列命令 $myMap 變數中儲存的對應函式，然後使用呼叫運算子來執行它。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>$myMap = (Get-Command -Name map -Type function)</source>
          <target state="translated">$myMap = (Get-command-名稱對應的型別函式)</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>&amp;($myMap)</source>
          <target state="translated">&amp;($myMap)</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If a command originated in a module, you can use the following format to run it.</source>
          <target state="translated">如果在模組中產生的命令，您可以使用下列格式來執行它。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>&amp; &lt;PSModuleInfo-object&gt;</source>
          <target state="translated">&amp; &lt; PSModuleInfo 物件 &gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For example, to run the Add-File cmdlet in the FileCommands module, use the following command sequence.</source>
          <target state="translated">例如，若要執行 FileCommands 模組加入檔案的指令程式，使用下列命令序列。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>$FileCommands = get-module -name FileCommands</source>
          <target state="translated">$FileCommands = 取得模組-名稱 FileCommands</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>&amp; $FileCommands Add-File</source>
          <target state="translated">&amp; $FileCommands 新增的檔案</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>REPLACED ITEMS</source>
          <target state="translated">取代項目</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Items that have not been imported from a module or snap-in, such as functions, variables, and aliases that you create in your session or that you add by using a profile can be replaced by commands that have the same name.</source>
          <target state="translated">無法從模組或嵌入式管理單元，例如函式、 變數和別名，在您的工作階段中建立或使用設定檔新增已匯入的項目可以取代由具有相同名稱的命令。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If they are replaced, you cannot access them.</source>
          <target state="translated">如果這些值會取代，您無法存取它們。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Variables and aliases are always replaced even if they have been imported from a module or snap-in because you cannot use a call operator or a qualified name to run them.</source>
          <target state="translated">即使它們已匯入從模組或嵌入式管理單元因為您無法使用呼叫運算子或限定的名稱，並執行，一律會取代變數和別名。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, if you type a Get-Map function in your session, and you import a function called Get-Map, the original function is replaced.</source>
          <target state="translated">例如，如果 Get 對應函式在您的工作階段，而您匯入函式，呼叫 Get 對應，會取代原始函式。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You cannot retrieve it in the current session.</source>
          <target state="translated">您無法擷取目前的工作階段中。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>AVOIDING NAME CONFLICTS</source>
          <target state="translated">避免名稱衝突</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The best way to manage command name conflicts is to prevent them.</source>
          <target state="translated">若要管理命令名稱衝突，最好是為了防止它們。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When you name your commands, use a name that is very specific or is likely to be unique.</source>
          <target state="translated">當您命名您的命令時，使用非常明確，或可能是唯一的名稱。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For example, add your initials or company name acronym to the nouns in your commands.</source>
          <target state="translated">例如，加入在命令中的名詞中您的公司名稱的縮寫。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Also, when you import commands into your session from a Windows PowerShell module or from another session, use the Prefix parameter of the Import-Module or Import-PSSession cmdlet to add a prefix to the nouns in the names of commands.</source>
          <target state="translated">此外，當您匯入到您的工作階段從 Windows PowerShell 模組，或從另一個工作階段的命令，使用前置詞的匯入模組或 Import-pssession cmdlet 的參數加入前置詞的名詞中命令的名稱。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, the following command avoids any conflict with the Get-Date and Set-Date cmdlets that come with Windows PowerShell when you import the DateFunctions module.</source>
          <target state="translated">例如，下列命令可避免使用 Windows PowerShell 隨附當您匯入 DateFunctions 模組取得日期和 Set-date cmdlet 的任何衝突。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Import-Module -Name DateFunctions -Prefix ZZ</source>
          <target state="translated">匯入模組的名稱 DateFunctions-前置詞 ZZ</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For more information, see Import-Module and Import-PSSession.</source>
          <target state="translated">如需詳細資訊，請參閱匯入模組和 Import-pssession。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>about_Path_Syntax about_Aliases about_Functions Alias (provider) Function (provider) Get-Command Import-Module Import-PSSession</source>
          <target state="translated">about_Path_Syntax about_Aliases about_Functions 別名 （提供者） （提供者） Get 命令匯入模組 Import-pssession 函式</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>