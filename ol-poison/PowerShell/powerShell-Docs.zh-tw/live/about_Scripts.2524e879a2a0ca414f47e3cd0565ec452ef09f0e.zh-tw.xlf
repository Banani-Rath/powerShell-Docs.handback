<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">652ddd2eebf056fa983b4bfe64ef2085f5a9649f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_Scripts.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1b6c807e43c60bc5e015267aa4448f43187d8080</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2bedc30b0d0f5ea6e05f9d5e2540591c9006c90e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Scripts</source>
          <target state="translated">about_Scripts</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell 指令程式</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Scripts</source>
          <target state="translated">關於指令碼</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Scripts</source>
          <target state="translated">about_Scripts</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Scripts</source>
          <target state="translated">about_Scripts</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">簡短描述</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how to run and write scripts in  Windows PowerShell�.</source>
          <target state="translated">描述如何執行，並在 Windows PowerShell 撰寫指令碼。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細描述</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A script is a plain text file that contains one or more  Windows PowerShell commands.</source>
          <target state="translated">指令碼是包含一或多個 Windows PowerShell 命令的純文字檔案。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Windows PowerShell scripts have a .ps1 file name extension.</source>
          <target state="translated">Windows PowerShell 指令碼有.ps1 副檔名。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Running a script is a lot like running cmdlet.</source>
          <target state="translated">執行指令碼很像執行 cmdlet。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You type the path and file name of the script and use parameters to submit data and set options.</source>
          <target state="translated">您輸入指令碼的路徑和檔案名稱，並使用參數來送出資料和設定選項。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can run scripts on your computer or in a remote session on a different computer.</source>
          <target state="translated">您可以在不同電腦上電腦或遠端工作階段中執行指令碼。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Writing a script saves a command for later use and makes it easy to share with others.</source>
          <target state="translated">撰寫指令碼儲存命令，以供稍後使用，並輕鬆地與其他人共用。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Most importantly, it lets you run the commands simply by typing the script path and the file name.</source>
          <target state="translated">最重要的是，它可讓您執行命令，只要輸入指令碼的路徑和檔案名稱。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Scripts can be as simple as a single command in a file or as extensive as a complex program.</source>
          <target state="translated">指令碼可以是檔案中的單一命令的簡單或複雜的程式為廣泛。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Scripts have additional features, such as the <ph id="ph1">\#</ph>Requires special comment, the use of parameters, support for data sections, and digital signing for security.</source>
          <target state="translated">指令碼中具有其他功能，例如 <ph id="ph1">\#</ph>需要特殊的註解，使用參數、 支援的資料區段與安全性的數位簽章。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can also write Help topics for scripts and for any functions in the script.</source>
          <target state="translated">您也可以撰寫指令碼中的指令碼和任何功能的說明主題。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>HOW TO RUN A SCRIPT</source>
          <target state="translated">如何執行指令碼</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Before you can run a script, you need to change the default  Windows PowerShell execution policy.</source>
          <target state="translated">您可以執行指令碼之前，您需要變更預設的 Windows PowerShell 執行原則。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The default execution policy, "Restricted", prevents all scripts from running, including scripts that you write on the local computer.</source>
          <target state="translated">預設的執行原則，「 限制 」，可防止所有指令碼無法執行，包括您在本機電腦撰寫的指令碼。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>For more information, see about_Execution_Policies.</source>
          <target state="translated">如需詳細資訊，請參閱 about_Execution_Policies。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The execution policy is saved in the registry, so you need to change it only once on each computer.</source>
          <target state="translated">執行原則會儲存在登錄中，因此您必須變更一次只能在每一部電腦上。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>To change the execution policy, use the following procedure.</source>
          <target state="translated">若要變更執行原則，請使用下列程序。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Start Windows PowerShell with the "Run  as administrator" option.</source>
          <target state="translated">使用 [以系統管理員身分執行] 選項啟動 Windows PowerShell。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>At the command prompt, type:</source>
          <target state="translated">在命令提示字元中，輸入：</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Set-ExecutionPolicy AllSigned</source>
          <target state="translated">Set-executionpolicy AllSigned</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>-or-</source>
          <target state="translated">- 或者 -</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Set-ExecutionPolicy RemoteSigned</source>
          <target state="translated">Set-executionpolicy RemoteSigned</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The change is effective immediately</source>
          <target state="translated">變更會立即生效</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To run a script, type the full name and the full path to the script file.</source>
          <target state="translated">若要執行指令碼，請輸入完整名稱和指令碼檔案的完整路徑。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For example, to run the Get-ServiceLog.ps1 script in the C:\Scripts directory, type:</source>
          <target state="translated">例如，若要執行 Get ServiceLog.ps1 指令碼 C:\Scripts 目錄中，輸入︰</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>To run a script in the current directory, type the path to the current directory, or use a dot to represent the current directory, followed by a path backslash (.<ph id="ph1">\)</ph>.</source>
          <target state="translated">目前目錄中執行的指令碼、 輸入目前的目錄路徑或使用句點來表示目前的目錄，以及路徑反斜線 (。<ph id="ph1">\)</ph>。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, to run the ServicesLog.ps1 script in the local directory, type:</source>
          <target state="translated">例如，若要執行 ServicesLog.ps1 指令碼的本機目錄中，輸入︰</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If the script has parameters, type the parameters and parameter values after the script file name.</source>
          <target state="translated">如果指令碼參數，請指令碼檔案名稱後面輸入參數和參數值。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, the following command uses the ServiceName parameter of the Get-ServiceLog script to request a log of WinRM service activity.</source>
          <target state="translated">例如，下列命令會使用 Get Log 指令碼的 ServiceName 參數要求 WinRM 服務活動的記錄。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>As a security feature,  Windows PowerShell does not run scripts when you double-click the script icon in File Explorer or when you type the script name without a full path, even when the script is in the current directory.</source>
          <target state="translated">Windows PowerShell 當做安全性功能，它不會執行指令碼時按兩下指令碼中的圖示檔案總管] 中，或當您輸入的指令碼名稱，而不需要完整的路徑，即使是目前目錄中的指令碼。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For more information about running commands and scripts in Windows PowerShell, see about_Command_Precedence.</source>
          <target state="translated">如需在 Windows PowerShell 中執行命令和指令碼的詳細資訊，請參閱 about_Command_Precedence。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>RUN WITH POWERSHELL</source>
          <target state="translated">使用 POWERSHELL 執行</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Beginning in  Windows PowerShell 3.0, you can run scripts from File Explorer (or Windows Explorer, in earlier versions of Windows).</source>
          <target state="translated">從 Windows PowerShell 3.0 開始，您可以從檔案總管] （或 Windows 檔案總管，在舊版 Windows 中） 執行指令碼。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>To use the "Run with PowerShell" feature:</source>
          <target state="translated">若要使用 「 使用 PowerShell 執行 」 功能︰</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The "Run with PowerShell" feature is designed to run scripts that do not have required parameters and do not return output to the command prompt.</source>
          <target state="translated">「 使用 PowerShell 執行 」 功能被設計來執行指令碼，並沒有必要的參數，並不會傳回輸出到命令提示字元。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For more information, see about_Run_With_PowerShell</source>
          <target state="translated">如需詳細資訊，請參閱 about_Run_With_PowerShell</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>RUNNING SCRIPTS ON OTHER COMPUTERS</source>
          <target state="translated">在其他電腦上執行指令碼</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>To run a script on one or more remote computers, use the FilePath parameter of the Invoke-Command cmdlet.</source>
          <target state="translated">若要在一或多個遠端電腦上執行指令碼，使用 Invoke-command cmdlet 的 FilePath 參數。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Enter the path and file name of the script as the value of the FilePath parameter.</source>
          <target state="translated">輸入指令碼的路徑和檔案名稱做為 FilePath 參數的值。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The script must reside on the local computer or in a directory that the local computer can access.</source>
          <target state="translated">指令碼必須位於本機電腦上，或在本機電腦可以存取的目錄中。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following command runs the Get-ServiceLog.ps1 script on the Server01 and Server02 remote computers.</source>
          <target state="translated">下列命令在 Server01 與 Server02 遠端電腦上執行 Get ServiceLog.ps1 指令碼。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>GET HELP FOR SCRIPTS</source>
          <target state="translated">取得指令碼的說明</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The Get-Help cmdlet gets the help topics for scripts as well as for cmdlets and other types of commands.</source>
          <target state="translated">取得說明 cmdlet 會取得 [說明] 主題，以及指令碼與指令程式和其他類型的命令。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To get the help topic for a script, type "Get-Help" followed by the path and file name of the script.</source>
          <target state="translated">若要取得指令碼 [說明] 主題，請輸入"Get-help"後面的指令碼的路徑和檔案名稱。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If the script path is in your Path environment variable, you can omit the path.</source>
          <target state="translated">如果指令碼路徑在 Path 環境變數，您可以省略路徑。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, to get help for the ServicesLog.ps1 script, type:</source>
          <target state="translated">例如，若要取得 ServicesLog.ps1 指令碼的說明，請輸入︰</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>HOW TO WRITE A SCRIPT</source>
          <target state="translated">如何撰寫指令碼</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>A script can contain any valid  Windows PowerShell commands, including single commands, commands that use the pipeline, functions, and control structures such as If statements and For loops.</source>
          <target state="translated">指令碼可以包含任何有效的 Windows PowerShell 命令，包括單一命令，命令使用管線、 函式，以及控制結構，例如，如果陳述式與 For 迴圈。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>To write a script, start a text editor (such as Notepad) or a script editor (such as the  Windows PowerShell Integrated Scripting Environment [ISE]).</source>
          <target state="translated">若要撰寫指令碼，啟動文字編輯器 （例如 [記事本]) 或指令碼編輯器 （例如 Windows PowerShell 整合式指令碼環境 [ISE]）。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Type the commands and save them in a file with a valid file name and the .ps1 file name extension.</source>
          <target state="translated">輸入命令，並將它們儲存在具有有效的檔名和副檔名.ps1 的檔案。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The following example is a simple script that gets the services that are running on the current system and saves them to a log file.</source>
          <target state="translated">下列範例會取得目前的系統執行的服務的簡單指令碼，並將它們儲存到記錄檔。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The log file name is created from the current date.</source>
          <target state="translated">從目前的日期建立記錄檔名稱。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To create this script, open a text editor or a script editor, type these commands, and then save them in a file named ServiceLog.ps1.</source>
          <target state="translated">若要建立此指令碼，開啟文字編輯器] 或 [指令碼編輯器、 輸入這些命令，然後將它們儲存在名為 ServiceLog.ps1。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>PARAMETERS IN SCRIPTS</source>
          <target state="translated">參數中的指令碼</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To define parameters in a script, use a Param statement.</source>
          <target state="translated">若要在指令碼中定義參數，使用 Param 陳述式。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The Param statement must be the first statement in a script, except for comments and any <ph id="ph1">\#</ph>Requires statements.</source>
          <target state="translated">Param 陳述式必須是第一個陳述式，在指令碼，除了註解和任何 <ph id="ph1">\#</ph>需要陳述式。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Script parameters work like function parameters.</source>
          <target state="translated">像是函式參數使用的指令碼參數。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The parameter values are available to all of the commands in the script.</source>
          <target state="translated">參數值可用於所有的指令碼中的命令。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>All of the features of function parameters, including the Parameter attribute and its named arguments, are also valid in scripts.</source>
          <target state="translated">所有功能的函式參數，包括參數屬性和指定的引數，也是有效的指令碼中。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>When running the script, script users type the parameters after the script name.</source>
          <target state="translated">當執行指令碼，指令碼使用者會輸入參數之後的指令碼名稱。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following example shows a Test-Remote.ps1 script that has a ComputerName parameter.</source>
          <target state="translated">下列範例會顯示具有 ComputerName 參數的測試 Remote.ps1 指令碼。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Both of the script functions can access the ComputerName parameter value.</source>
          <target state="translated">這兩個指令碼函式可以存取 ComputerName 參數值。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>To run this script, type the parameter name after the script name.</source>
          <target state="translated">若要執行此指令碼，請在指令碼名稱後面輸入參數名稱。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For more information about the Param statement and the function parameters, see about_Functions and about_Functions_Advanced_Parameters.</source>
          <target state="translated">如需有關 Param 陳述式和函式參數的詳細資訊，請參閱 about_Functions 和 about_Functions_Advanced_Parameters。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>WRITING HELP FOR SCRIPTS</source>
          <target state="translated">指令碼的撰寫說明</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You can write a help topic for a script by using either of the two following methods:</source>
          <target state="translated">您可以使用下列兩種方法之一來撰寫指令碼 [說明] 主題︰</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>--  Comment-Based Help for Scripts</source>
          <target state="translated">-註解式說明的指令碼</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Create a Help topic by using special keywords in the comments.</source>
          <target state="translated">註解中使用特殊關鍵字，以建立 「 說明 」 主題。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>To create comment-based Help for a script, the comments must be placed at the beginning or end of the script file.</source>
          <target state="translated">若要建立指令碼的註解說明，必須放置註解的開頭或結尾的指令碼檔案。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For more information about comment-based Help, see about_Comment_Based_Help.</source>
          <target state="translated">如需有關註解式說明的詳細資訊，請參閱 about_Comment_Based_Help。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>--  XML-Based Help  for Scripts</source>
          <target state="translated">-以 XML 為基礎的指令碼的說明</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Create an XML-based Help topic, such as the type that is typically created for cmdlets.</source>
          <target state="translated">建立以 XML 為基礎的說明主題，例如通常 cmdlet 所建立的類型。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>XML-based Help is required if you are translating Help topics into multiple languages.</source>
          <target state="translated">如果您將 [說明] 主題轉譯成多種語言需要以 XML 為基礎的說明。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>To associate the script with the XML-based Help topic, use the .ExternalHelp Help comment keyword.</source>
          <target state="translated">若要以 XML 為基礎的 [說明] 主題關聯的指令碼，使用。ExternalHelp 說明註解的關鍵字。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For more information about the ExternalHelp keyword, see about_Comment_Based_Help.</source>
          <target state="translated">如需 ExternalHelp 關鍵字的詳細資訊，請參閱 about_Comment_Based_Help。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For more information about XML-based help, see "How to Write Cmdlet Help" in the MSDN (Microsoft Developer Network) library at http:<ph id="ph1">\/\/</ph>go.microsoft.com<ph id="ph2">\/</ph>fwlink<ph id="ph3">\/</ph>?LinkID<ph id="ph4">\=</ph>123415.</source>
          <target state="translated">多個 XML 為基礎的說明的詳細資訊，請參閱 「 如何撰寫 Cmdlet 說明 「 http MSDN (Microsoft Developer Network) 文件庫中︰<ph id="ph1">\/\/</ph>go.microsoft.com 通訊<ph id="ph2">\/</ph>fwlink<ph id="ph3">\/</ph>嗎？LinkID<ph id="ph4">\=</ph>123415。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>SCRIPT SCOPE AND DOT SOURCING</source>
          <target state="translated">指令碼範圍和點執行</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Each script runs in its own scope.</source>
          <target state="translated">每個指令碼會執行自己的範圍。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The functions, variables, aliases, and drives that are created in the script exist only in the script scope.</source>
          <target state="translated">函式、 變數、 別名及指令碼中建立的磁碟機只存在於指令碼範圍。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You cannot access these items or their values in the scope in which the script runs.</source>
          <target state="translated">您無法存取這些項目或其值在範圍內的指令碼會執行。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>To run a script in a different scope, you can specify a scope, such as Global or Local, or you can dot source the script.</source>
          <target state="translated">若要執行指令碼不同範圍中，您可以指定範圍，例如全域或本機，或點來源指令碼。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The dot sourcing feature lets you run a script in the current scope instead of in the script scope.</source>
          <target state="translated">點來源功能，可讓您執行指令碼，而不是目前範圍中的指令碼範圍。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>When you run a script that is dot sourced, the commands in the script run as though you had typed them at the command prompt.</source>
          <target state="translated">當您執行的指令碼，是取得資料來源的點時，就好像您在命令提示字元中輸入它們，也會執行指令碼中的命令。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The functions, variables, aliases, and drives that the script creates are created in the scope in which you are working.</source>
          <target state="translated">您使用的範圍內建立函式、 變數、 別名及磁碟機，指令碼會建立。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>After the script runs, you can use the created items and access their values in your session.</source>
          <target state="translated">指令碼執行之後，您可以使用建立的項目，並在您的工作階段中存取它們的值。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>To dot source a script, type a dot (.) and a space before the script path.</source>
          <target state="translated">若要點來源指令碼，輸入一個點 （.） 和指令碼路徑前面加上的空格。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>After the UtilityFunctions script runs, the functions and variables that the script creates are added to the current scope.</source>
          <target state="translated">UtilityFunctions 指令碼執行之後，函式和指令碼會建立的變數新增至目前的範圍。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>For example, the UtilityFunctions.ps1 script creates the New-Profile function and the $ProfileName variable.</source>
          <target state="translated">例如，UtilityFunctions.ps1 指令碼會建立新設定檔函式和 $ProfileName 變數。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If you run the UtilityFunctions.ps1 script in its own script scope, the New-Profile function and the $ProfileName variable exist only while the script is running.</source>
          <target state="translated">如果您在自己的指令碼範圍中執行 UtilityFunctions.ps1 指令碼，新增設定檔函式和 $ProfileName 變數存在只有當指令碼執行時。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>When the script exits, the function and variable are removed, as shown in the following example.</source>
          <target state="translated">當指令碼結束時，此函式和變數會移除，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>When you dot source the script and run it, the script creates the New-Profile function and the $ProfileName variable in your session in your scope.</source>
          <target state="translated">您點來源指令碼，並執行，指令碼會建立新設定檔函式和 $ProfileName 變數在您的工作階段在範圍內。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>After the script runs, you can use the New-Profile function in your session, as shown in the following example.</source>
          <target state="translated">指令碼執行之後，您可以使用新設定檔函式，在您的工作階段，如下列範例所示即可。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>For more information about scope, see about_Scopes.</source>
          <target state="translated">如需有關範圍的詳細資訊，請參閱 about_Scopes。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>SCRIPTS IN MODULES</source>
          <target state="translated">在模組中的指令碼</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>A module is a set of related Windows PowerShell resources that can be distributed as a unit.</source>
          <target state="translated">模組是一組相關的 Windows PowerShell 資源可以發佈做為一個單位。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>You can use modules to organize your scripts, functions, and other resources.</source>
          <target state="translated">您可以使用模組來組織您的指令碼、 函數和其他資源。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>You can also use modules to distribute your code to others, and to get code from trusted sources.</source>
          <target state="translated">發佈給其他人，程式碼，並從受信任來源取得程式碼，您也可以使用模組。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>You can include scripts in your modules, or you can create a script module, which is a module that consists entirely or primarily of a script and supporting resources.</source>
          <target state="translated">您可以在模組中，包含指令碼，或者您可以建立指令碼] 模組，模組可包含完全或主要的指令碼和支援的資源。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>A script module is just a script with a .psm1 file name extension.</source>
          <target state="translated">指令碼模組是只包含.psm1 檔案的副檔名的指令碼。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>For more information about modules, see about_Modules.</source>
          <target state="translated">如需有關模組的詳細資訊，請參閱 about_Modules。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>OTHER SCRIPT FEATURES</source>
          <target state="translated">其他指令碼功能</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Windows PowerShell has many useful features that you can use in scripts.</source>
          <target state="translated">Windows PowerShell 有許多實用的功能，您可以使用指令碼中。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Requires</source>
          <target state="translated">需要</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>You can use a <ph id="ph1">\#</ph>Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of  Windows PowerShell.</source>
          <target state="translated">您可以使用 <ph id="ph1">\#</ph>需要陳述式，以避免執行，而不需要指定的模組或嵌入式管理單元和指定的版本的 Windows PowerShell 指令碼。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>For more information, see about_Requires.</source>
          <target state="translated">如需詳細資訊，請參閱 about_Requires。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>$PSCommandPath</source>
          <target state="translated">$PSCommandPath</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Contains the full path and name of the script that is being run.</source>
          <target state="translated">包含的完整路徑和正在執行的指令碼名稱。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This parameter is valid in all scripts.</source>
          <target state="translated">這個參數是有效的所有指令碼中。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>This automatic variable is introduced in  Windows PowerShell 3.0.</source>
          <target state="translated">此自動變數是在 Windows PowerShell 3.0 引進。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>$PSScriptRoot</source>
          <target state="translated">$PSScriptRoot</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Contains the directory from which a script is being run.</source>
          <target state="translated">包含要從中執行指令碼的目錄。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>In  Windows PowerShell 2.0, this variable is valid only in script modules (.psm1).</source>
          <target state="translated">在 Windows PowerShell 2.0 中，此變數是在指令碼模組 (.psm1) 中才有效。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Beginning in  Windows PowerShell 3.0, it is valid in all scripts.</source>
          <target state="translated">從 Windows PowerShell 3.0 開始，則所有的指令碼中。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>$MyInvocation</source>
          <target state="translated">$MyInvocation</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The $MyInvocation automatic variable contains information about the current script, including information about how it was started or "invoked."</source>
          <target state="translated">$MyInvocation 自動變數包含目前的指令碼，包括如何啟動或 「 叫用。 」 的相關資訊的相關資訊</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>You can use this variable and its properties to get information about the script while it is  running.</source>
          <target state="translated">若要取得指令碼的相關資訊，在執行時，您可以使用此變數，而且其屬性。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>For example, the $MyInvocation.MyCommand.Path variable contains the path and file name of the script.</source>
          <target state="translated">例如，$MyInvocation.MyCommand.Path 變數包含指令碼的路徑和檔案名稱。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>$MyInvocation.Line contains the command that started the script, including all parameters and values.</source>
          <target state="translated">$MyInvocation.Line 包含啟動指令碼，包括所有參數和值的命令。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Beginning in  Windows PowerShell 3.0, $MyInvocation has two new properties that provide information about the script that called or invoked the current script.</source>
          <target state="translated">從 Windows PowerShell 3.0 開始，$MyInvocation 有提供有關此指令碼會呼叫或叫用目前的指令碼的兩個新屬性。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The values of these properties are populated only when the invoker or caller is a script.</source>
          <target state="translated">這些屬性的值會填入時才啟動程式或呼叫端指令碼。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>-- PSCommandPath contains the full path and name of the script that called or invoked the current script.</source>
          <target state="translated">-PSCommandPath 包含完整路徑和指令碼的呼叫或叫用目前的指令碼名稱。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>-- PSScriptRoot contains the directory of the script that called or invoked the current script.</source>
          <target state="translated">-PSScriptRoot 包含指令碼呼叫或叫用目前的指令碼的目錄。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Unlike the $PSCommandPath and $PSScriptRoot automatic variables, which contain information about the current script, the PSCommandPath and PSScriptRoot properties of the $MyInvocation variable contain information about the script that called or invoke the current script.</source>
          <target state="translated">不同的 $PSCommandPath 和 $PSScriptRoot 自動變數，其中包含目前的指令碼的相關資訊，於 $MyInvocation 變數的 PSCommandPath 和 PSScriptRoot 屬性會包含呼叫或叫用目前的指令碼的指令碼的相關資訊。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Data sections</source>
          <target state="translated">資料區段</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>You can use the Data keyword to separate data from logic in scripts.</source>
          <target state="translated">您可以使用 Data 關鍵字將資料從指令碼中的邏輯。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Data sections can also make localization easier.</source>
          <target state="translated">資料區段也容易當地語系化。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For more information, see about_Data_Sections and about_Script_Localization.</source>
          <target state="translated">如需詳細資訊，請參閱 about_Data_Sections 和 about_Script_Localization。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Script Signing</source>
          <target state="translated">指令碼簽署</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>You can add a digital signature to a script.</source>
          <target state="translated">您可以將數位簽章加入指令碼。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Depending on the execution policy, you can use digital signatures to restrict the running of scripts that could include unsafe commands.</source>
          <target state="translated">根據執行原則，您可以使用數位簽章來限制執行指令碼，其中可能包含不安全的命令。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>For more information, see about_Execution_Policies and about_Signing.</source>
          <target state="translated">如需詳細資訊，請參閱 about_Execution_Policies 和 about_Signing。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>about_Comment_Based_Help</source>
          <target state="translated">about_Comment_Based_Help</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>about_Execution_Policies</source>
          <target state="translated">about_Execution_Policies</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>about_Functions</source>
          <target state="translated">about_Functions</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>about_Modules</source>
          <target state="translated">about_Modules</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>about_Profiles</source>
          <target state="translated">about_Profiles</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>about_Requires</source>
          <target state="translated">about_Requires</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>about_Run_With_PowerShell</source>
          <target state="translated">about_Run_With_PowerShell</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>about_Scopes</source>
          <target state="translated">about_Scopes</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>about_Script_Blocks</source>
          <target state="translated">about_Script_Blocks</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>about_Signing</source>
          <target state="translated">about_Signing</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Invoke-Command</source>
          <target state="translated">Invoke-Command</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>