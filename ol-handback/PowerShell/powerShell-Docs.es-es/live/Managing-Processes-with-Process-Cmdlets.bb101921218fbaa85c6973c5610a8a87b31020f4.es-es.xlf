<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="es-es">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3c0a8b3499f566e491c4bf72feea97ccd15a250</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04046aa" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Managing Processes with Process Cmdlets</source>
          <target state="translated">Administración de procesos con cmdlets de proceso</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Managing Processes with Process Cmdlets</source>
          <target state="translated">Administración de procesos con cmdlets de proceso</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>You can use the Process cmdlets in Windows PowerShell to manage local and remote processes in Windows PowerShell.</source>
          <target state="translated">Puede usar los cmdlets Process en Windows PowerShell para administrar procesos locales y remotos en Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Getting Processes (Get\-Process)</source>
          <target state="translated">Obtener procesos (Get-Process)</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>To get the processes running on the local computer, run a <bpt id="p1">**</bpt>Get\-Process<ept id="p1">**</ept> with no parameters.</source>
          <target state="translated">Para obtener los procesos que se están ejecutando en el equipo local, ejecute <bpt id="p1">**</bpt>Get-Process<ept id="p1">**</ept> sin parámetros.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can get particular processes by specifying their process names or process IDs.</source>
          <target state="translated">Puede obtener determinados procesos especificando sus nombres de proceso o identificadores de proceso.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The following command gets the Idle process:</source>
          <target state="translated">El siguiente comando obtiene el proceso inactivo:</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Although it is normal for cmdlets to return no data in some situations, when you specify a process by its ProcessId, <bpt id="p1">**</bpt>Get\-Process<ept id="p1">**</ept> generates an error if it finds no matches, because the usual intent is to retrieve a known running process.</source>
          <target state="translated">Aunque es normal que los cmdlets no devuelvan datos en algunas situaciones, cuando se especifica un proceso por su id. de proceso <bpt id="p1">**</bpt>Get-Process<ept id="p1">**</ept> genera un error si no encuentra ninguna coincidencia, porque la intención habitual consiste en recuperar un proceso en ejecución conocido.</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If there is no process with that Id, it is likely that the Id is incorrect or that the process of interest has already exited:</source>
          <target state="translated">Si no hay ningún proceso con ese identificador, es probable que el identificador sea incorrecto o que el proceso de interés haya terminado:</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can use the Name parameter of the Get\-Process cmdlet to specify a subset of processes based on the process name.</source>
          <target state="translated">Puede usar el parámetro Name del cmdlet Get-Process para especificar un subconjunto de procesos basado en el nombre del proceso.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The Name parameter can take multiple names in a comma\-separated list and it supports the use of wildcards, so you can type name patterns.</source>
          <target state="translated">El parámetro Name puede tomar varios nombres de una lista de nombres separados por comas y admite el uso de caracteres comodín, para que pueda escribir patrones de nombre.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For example, the following command gets process whose names begin with "ex."</source>
          <target state="translated">Por ejemplo, el siguiente comando obtiene el proceso cuyos nombres comienzan por "ex".</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Because the .NET System.Diagnostics.Process class is the foundation for Windows PowerShell processes, it follows some of the conventions used by System.Diagnostics.Process.</source>
          <target state="translated">Dado que la clase System.Diagnostics.Process de .NET es la base de los procesos de Windows PowerShell, sigue algunas de las convenciones usadas por System.Diagnostics.Process.</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>One of those conventions is that the process name for an executable never includes the ".exe" at the end of the executable name.</source>
          <target state="translated">Una de estas convenciones es que el nombre de proceso de un archivo ejecutable nunca incluya ".exe" al final del nombre del ejecutable.</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Get\-Process<ept id="p1">**</ept> also accepts multiple values for the Name parameter.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get-Process<ept id="p1">**</ept> también acepta varios valores para el parámetro Name.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can use the ComputerName parameter of Get\-Process to get processes on remote computers.</source>
          <target state="translated">Puede usar el parámetro ComputerName de Get-Process para obtener procesos en equipos remotos.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the PowerShell processes on the local computer (represented by "localhost") and on two remote computers.</source>
          <target state="translated">Por ejemplo, el comando siguiente obtiene los procesos de PowerShell en el equipo local (representado por "localhost") y en dos equipos remotos.</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The computer names are not evident in this display, but they are stored in the MachineName property of the process objects that Get\-Process returns.</source>
          <target state="translated">Los nombres de equipo no son evidentes en esta presentación, pero se almacenan en la propiedad MachineName de los objetos de proceso que devuelve Get-Process.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following command uses the Format\-Table cmdlet to display the process ID, ProcessName and MachineName (ComputerName) properties of the process objects.</source>
          <target state="translated">El siguiente comando usa el cmdlet Format-Table para mostrar el identificador de proceso y las propiedades ProcessName y MachineName (ComputerName) de los objetos de proceso.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This more complex command adds the MachineName property to the standard Get\-Process display.</source>
          <target state="translated">Este comando más complejo agrega la propiedad MachineName a la presentación estándar de Get-Process.</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The backtick (\`)(ASCII 96) is the Windows PowerShell continuation character.</source>
          <target state="translated">El acento grave (`) (ASCII 96) es el carácter de continuación de Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Stopping Processes (Stop\-Process)</source>
          <target state="translated">Detener procesos (Stop-Process)</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Windows PowerShell gives you flexibility for listing processes, but what about stopping a process?</source>
          <target state="translated">Windows PowerShell ofrece flexibilidad para enumerar procesos, pero ¿qué hay de detenerlos?</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Stop\-Process<ept id="p1">**</ept> cmdlet takes a Name or Id to specify a process you want to stop.</source>
          <target state="translated">El cmdlet <bpt id="p1">**</bpt>Stop-Process<ept id="p1">**</ept> toma un nombre o un identificador para especificar un proceso que quiere detener.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Your ability to stop processes depends on your permissions.</source>
          <target state="translated">Su capacidad para detener procesos dependerá de sus permisos.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Some processes cannot be stopped.</source>
          <target state="translated">Algunos procesos no se pueden detener.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, if you try to stop the idle process, you get an error:</source>
          <target state="translated">Por ejemplo, si intenta detener el proceso inactivo, obtendrá un error:</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You can also force prompting with the <bpt id="p1">**</bpt>Confirm<ept id="p1">**</ept> parameter.</source>
          <target state="translated">También puede forzar la solicitud con el parámetro <bpt id="p1">**</bpt>Confirm<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This parameter is particularly useful if you use a wildcard when specifying the process name, because you may accidentally match some processes you do not want to stop:</source>
          <target state="translated">Este parámetro es especialmente útil si se usa un carácter comodín al especificar el nombre del proceso, ya que accidentalmente podría coincidir con algunos procesos que no quiere detener:</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Complex process manipulation is possible by using some of the object filtering cmdlets.</source>
          <target state="translated">La manipulación de procesos complejos es posible si se usan algunos cmdlets de filtrado de objetos.</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Because a Process object has a Responding property that is true when it is no longer responding, you can stop all nonresponsive applications with the following command:</source>
          <target state="translated">Dado que un objeto Process tiene una propiedad Responding que es true cuando ya no responde, puede detener todas las aplicaciones que no respondan con el comando siguiente:</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You can use the same approach in other situations.</source>
          <target state="translated">Puede usar el mismo enfoque en otras situaciones.</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For example, suppose a secondary notification area application automatically runs when users start another application.</source>
          <target state="translated">Por ejemplo, supongamos que una aplicación de área de notificaciones secundaria se ejecuta automáticamente cuando los usuarios inician otra aplicación.</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You may find that this does not work correctly in Terminal Services sessions, but you still want to keep it in sessions that run on the physical computer console.</source>
          <target state="translated">Es posible que esto no funcione correctamente en las sesiones de Terminal Services, pero lo quiera seguir manteniendo en las sesiones que se ejecutan en la consola del equipo físico.</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Sessions connected to the physical computer desktop always have a session ID of 0, so you can stop all instances of the process that are in other sessions by using <bpt id="p1">**</bpt>Where\-Object<ept id="p1">**</ept> and the process, <bpt id="p2">**</bpt>SessionId<ept id="p2">**</ept>:</source>
          <target state="translated">Las sesiones conectadas en el escritorio del equipo físico siempre tienen un identificador de la sesión 0, por lo que puede detener todas las instancias del proceso que están en otras sesiones mediante <bpt id="p1">**</bpt>Where-Object<ept id="p1">**</ept> y el proceso, <bpt id="p2">**</bpt>SessionId<ept id="p2">**</ept>:</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The Stop\-Process cmdlet does not have a ComputerName parameter.</source>
          <target state="translated">El cmdlet Stop-Process no tiene un parámetro ComputerName.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Therefore, to run a stop process command on a remote computer, you need to use the Invoke\-Command cmdlet.</source>
          <target state="translated">Por lo tanto, para ejecutar un comando para detener un proceso en un equipo remoto, debe usar el cmdlet Invoke-Command.</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For example, to stop the PowerShell process on the Server01 remote computer, type:</source>
          <target state="translated">Por ejemplo, para detener el proceso de PowerShell en el equipo remoto Server01, escriba:</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Stopping All Other Windows PowerShell Sessions</source>
          <target state="translated">Detener todas las demás sesiones de Windows PowerShell</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It may occasionally be useful to be able to stop all running Windows PowerShell sessions other than the current session.</source>
          <target state="translated">En ocasiones puede ser útil poder detener todas las sesiones de Windows PowerShell que se están ejecutando, excepto la sesión actual.</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If a session is using too many resources or is inaccessible (it may be running remotely or in another desktop session), you may not be able to directly stop it.</source>
          <target state="translated">Si una sesión usa demasiados recursos o es inaccesible (quizás se esté ejecutando de forma remota o en otra sesión de escritorio), es posible que no pueda detenerla directamente.</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you try to stop all running sessions, however, the current session may be terminated instead.</source>
          <target state="translated">Si intenta detener todas las sesiones que se están ejecutando, la sesión actual podría finalizar en su lugar.</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Each Windows PowerShell session has an environment variable PID that contains the Id of the Windows PowerShell process.</source>
          <target state="translated">Cada sesión de Windows PowerShell tiene un PID de variable de entorno que contiene el identificador del proceso de Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can check the $PID against the Id of each session and terminate only Windows PowerShell sessions that have a different Id.</source>
          <target state="translated">Puede comprobar el $PID con el identificador de cada sesión y finalizar solo las sesiones de Windows PowerShell que tengan un identificador diferente.</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The following pipeline command does this and returns the list of terminated sessions (because of the use of the <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> parameter):</source>
          <target state="translated">El siguiente comando de canalización realiza esta acción y devuelve la lista de las sesiones finalizadas (debido al uso del parámetro <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept>):</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Starting, Debugging, and Waiting for Processes</source>
          <target state="translated">Iniciar, depurar y esperar procesos</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Windows PowerShell also comes with cmdlets to start (or restart), debug a process, and wait for a process to complete before running a command.</source>
          <target state="translated">Windows PowerShell también incluye cmdlets para iniciar (o reiniciar) y depurar un proceso, así como para esperar a que un proceso se complete antes de ejecutar un comando.</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For information about these cmdlets, see the cmdlet help topic for each cmdlet.</source>
          <target state="translated">Para obtener información acerca de estos cmdlets, vea el tema de ayuda de cada cmdlet.</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Consulte también</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Get-Process [m2]</source>
          <target state="translated">Get-Process [m2]</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Stop-Process [m2]</source>
          <target state="translated">Stop-Process [m2]</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Start-Process</source>
          <target state="translated">Start-Process</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Wait-Process</source>
          <target state="translated">Wait-Process</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Debug-Process</source>
          <target state="translated">Debug-Process</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Invoke-Command</source>
          <target state="translated">Invoke-Command</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>