<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">14a5473339913a93f4731578790c72f08ddac71f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Foreach.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e9374a96bbcc07aa9b5019b6f8d991fab190adf0</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">29cff617b56a2c9d858ed6fd0fed891cd36e58fe</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">cmdlet de PowerShell</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About ForEach</source>
          <target state="translated">Acerca de ForEach</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Foreach</source>
          <target state="translated">about_Foreach</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIPCIÓN BREVE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes a language command you can use to traverse all the items in a collection of items.</source>
          <target state="translated">Describe un comando de lenguaje que se puede utilizar para recorrer todos los elementos de una colección de elementos.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIPCIÓN LARGA</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Foreach statement (also known as a Foreach loop) is a language construct for stepping through (iterating) a series of values in a collection of items.</source>
          <target state="translated">La instrucción Foreach (también conocido como un bucle Foreach) es una construcción de lenguaje para recorrer (iteración) una serie de valores de una colección de elementos.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The simplest and most typical type of collection to traverse is an array.</source>
          <target state="translated">El tipo más sencillo y más habitual de colección para atravesar es una matriz.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Within a Foreach loop, it is common to run one or more commands against each item in an array.</source>
          <target state="translated">Dentro de un bucle Foreach, es frecuente ejecutar uno o más comandos en cada elemento de una matriz.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Syntax The following shows the ForEach syntax:</source>
          <target state="translated">La siguiente sintaxis muestran la sintaxis de ForEach:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>foreach ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>){<ph id="ph3">&lt;statement list&gt;</ph>}</source>
          <target state="translated">foreach ($<ph id="ph1">&lt;item&gt;</ph> en $<ph id="ph2">&lt;collection&gt;</ph>) {<ph id="ph3">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Simplified syntax Starting in Windows PowerShell 3.0, syntax with language keywords such as Where and ForEach was simplified.</source>
          <target state="translated">Una sintaxis simplificada a partir de Windows PowerShell 3.0, sintaxis con palabras clave del lenguaje, tales como Where y ForEach se ha simplificado.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Comparison operators that work on the members of a collection are treated as parameters.</source>
          <target state="translated">Operadores de comparación que funcionan en los miembros de una colección se tratan como parámetros.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can use a method on the members of a collection without containing it in a script block or adding the automatic variable "$_.".</source>
          <target state="translated">Puede utilizar un método en los miembros de una colección sin que lo contiene en un bloque de script o agregar la variable automática "$_.".</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Consider the following two examples:</source>
          <target state="translated">Tenga en cuenta los dos ejemplos siguientes:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>dir cert:\ -Recurse | foreach GetKeyAlgorithm dir cert:\ -Recurse | foreach {$_.GetKeyAlgorithm()}</source>
          <target state="translated">dir cert: \-Recurse | foreach GetKeyAlgorithm dir cert: \-Recurse | foreach {$_. GetKeyAlgorithm()}</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Although both commands work, the first returns results without using a script block or the $_.</source>
          <target state="translated">Aunque ambos comandos funcionan, el primero devuelve resultados sin usar un bloque de script o la $_.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>automatic variable.</source>
          <target state="translated">variable automática.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The method GetKeyAlgorithm is treated as a parameter of ForEach.</source>
          <target state="translated">El método GetKeyAlgorithm se trata como un parámetro de ForEach.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The first command returns the same results, but without errors, because the simplified syntax does not attempt to return results for items for which the specified argument did not apply.</source>
          <target state="translated">El primer comando devuelve los mismos resultados, pero sin errores, como la sintaxis simplificada intenta devolver resultados para los elementos para los que no se aplicó el argumento especificado.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Get-Process property Description is passed as a parameter argument of the ForEach statement.</source>
          <target state="translated">En este ejemplo, la propiedad Get-Process descripción se pasa como argumento de parámetro de la instrucción ForEach.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The results are the descriptions of active processes.</source>
          <target state="translated">Los resultados son las descripciones de los procesos activos.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Get-Process | ForEach Description</source>
          <target state="translated">Get-Process | Descripción de ForEach</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The Foreach statement outside a command pipeline The part of the Foreach statement enclosed in parenthesis represents a variable and a collection to iterate.</source>
          <target state="translated">La instrucción Foreach fuera de una canalización de comandos de la parte de la instrucción Foreach entre paréntesis representa una variable y una colección para recorrer en iteración.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Windows PowerShell creates the variable ($<ph id="ph1">&lt;item&gt;</ph>) automatically when the Foreach loop runs.</source>
          <target state="translated">Windows PowerShell se crea la variable ($<ph id="ph1">&lt;item&gt;</ph>) automáticamente cuando se ejecuta el bucle Foreach.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Prior to each iteration through the loop, the variable is set to a value in the collection.</source>
          <target state="translated">Antes de cada iteración del bucle, la variable se establece en un valor en la colección.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The block following a Foreach statement {<ph id="ph1">&lt;statement list&gt;</ph>} contains a set of commands to execute against each item in a collection.</source>
          <target state="translated">El bloque después de una instrucción Foreach {<ph id="ph1">&lt;statement list&gt;</ph>} contiene un conjunto de comandos que se ejecuta en cada elemento de una colección.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Examples For example, the Foreach loop in the following example displays the values in the $letterArray array.</source>
          <target state="translated">Ejemplos. por ejemplo, el bucle Foreach en el ejemplo siguiente muestra los valores de la matriz $letterArray.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>$letterArray = "a","b","c","d" foreach ($letter in $letterArray) { Write-Host $letter }</source>
          <target state="translated">$letterArray = "a", "b", "c", "d" foreach ($letter en $letterArray) {Write-Host $letter}</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In this example, the $letterArray array is created and initialized with the string values "a", "b", "c", and "d".</source>
          <target state="translated">En este ejemplo, la matriz $letterArray se crea e inicializa con los valores de cadena "a", "b", "c" y "d".</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The first time the Foreach statement runs, it sets the $letter variable equal to the first item in $letterArray ("a").</source>
          <target state="translated">La primera vez que se ejecuta la instrucción Foreach, Establece la variable $letter igual al primer elemento de $letterArray ("a").</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Then, it uses the Write-Host cmdlet to display the letter a.</source>
          <target state="translated">A continuación, usa el cmdlet Write-Host para mostrar la carta de una.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The next time through the loop, $letter is set to "b", and so on.</source>
          <target state="translated">La próxima vez que el bucle, $letter se establece en "b" y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>After the Foreach loop displays the letter d, Windows PowerShell exits the loop.</source>
          <target state="translated">Después de que el bucle Foreach muestra la letra d, Windows PowerShell sale del bucle.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement must appear on a single line to run it as a command at the Windows PowerShell command prompt.</source>
          <target state="translated">Toda la instrucción Foreach debe aparecer en una sola línea que ejecutarlo como un comando en el símbolo del sistema de Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The entire Foreach statement does not have to appear on a single line if you place the command in a .ps1 script file instead.</source>
          <target state="translated">Toda la instrucción Foreach no tiene que aparecer en una sola línea si el comando se coloca en un archivo de script. ps1 en su lugar.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Foreach statements can also be used together with cmdlets that return a collection of items.</source>
          <target state="translated">Instrucciones foreach también pueden utilizarse junto con los cmdlets que devuelven una colección de elementos.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement steps through the list of items that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">En el ejemplo siguiente, los pasos de la instrucción Foreach a través de la lista de elementos que se devuelve mediante el cmdlet Get-ChildItem.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { Write-Host $file }</source>
          <target state="translated">foreach ($file en Get-ChildItem) {Write-Host $file}</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can refine the example by using an If statement to limit the results that are returned.</source>
          <target state="translated">En el ejemplo se puede refinar utilizando If instrucción para limitar los resultados que se devuelven.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the following example, the Foreach statement performs the same looping operation as the previous example, but it adds an If statement to limit the results to files that are greater than 100 kilobytes (KB):</source>
          <target state="translated">En el ejemplo siguiente, la instrucción Foreach realiza la misma operación bucle como el ejemplo anterior, pero agrega If instrucción para limitar los resultados a los archivos que son mayores que 100 kilobytes (KB):</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file } }</source>
          <target state="translated">foreach ($file en Get-ChildItem) {si ($file.length - gt 100 KB) {Write-Host $file}}</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach loop uses a property of the $file variable to perform a comparison operation ($file.length -gt 100KB).</source>
          <target state="translated">En este ejemplo, el bucle Foreach usa una propiedad de la variable $file para realizar una operación de comparación ($file.length - gt 100 KB).</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The $file variable contains all the properties in the object that is returned by the Get-ChildItem cmdlet.</source>
          <target state="translated">La variable $file contiene todas las propiedades del objeto devuelto por el cmdlet Get-ChildItem.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Therefore, you can return more than just a file name.</source>
          <target state="translated">Por lo tanto, puede devolver más de un nombre de archivo.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In the next example, Windows PowerShell returns the length and the last access time inside the statement list:</source>
          <target state="translated">En el siguiente ejemplo, Windows PowerShell devuelve la longitud y la hora del último acceso dentro de la lista de instrucciones:</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file Write-Host $file.length Write-Host $file.lastaccesstime } }</source>
          <target state="translated">foreach ($file en Get-ChildItem) {si ($file.length - gt 100 KB) {Write-Host $file Write-Host $file.length Write-Host $file.lastaccesstime}}</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In this example, you are not limited to running a single command in a statement list.</source>
          <target state="translated">En este ejemplo, no está limitado a ejecutar un comando único en una lista de instrucciones.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can also use a variable outside a Foreach loop and increment the variable inside the loop.</source>
          <target state="translated">También puede utilizar una variable fuera de un bucle Foreach e incrementar la variable dentro del bucle.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The following example counts files over 100 KB in size:</source>
          <target state="translated">En el ejemplo siguiente se cuentan los archivos más de 100 KB de tamaño:</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>$i = 0 foreach ($file in Get-ChildItem) { if ($file.length -gt 100KB) { Write-Host $file "file size:" ($file.length / 1024).ToString("F0") KB $i = $i + 1 } }</source>
          <target state="translated">$i = 0 foreach ($file en Get-ChildItem) {si ($file.length - gt 100 KB) {Write-Host $file "tamaño de archivo:" ($file.length / 1024). ToString("F0") KB $i = $i + 1}}</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>if ($i -ne 0) { Write-Host Write-Host $i " file(s) over 100 KB in the current directory."}</source>
          <target state="translated">Si ($i - ne 0) {Write-Host Write-Host $i "archivos en 100 KB en el directorio actual."}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>else { Write-Host "No files greater than 100 KB in the current directory."</source>
          <target state="translated">Else {Write-Host "No archivos mayores de 100 KB en el directorio actual."</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the preceding example, the $i variable is set to 0 outside the loop, and the variable is incremented inside the loop for each file that is found that is larger than 100 KB.</source>
          <target state="translated">En el ejemplo anterior, la variable $i se establece en 0 fuera del bucle y se incrementa la variable dentro del bucle para cada archivo que se encuentra que es mayor que 100 KB.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>When the loop exits, an If statement evaluates the value of $i to display a count of all the files over 100 KB.</source>
          <target state="translated">Cuando se sale del bucle, If instrucción se evalúa como el valor de $i para mostrar un recuento de todos los archivos de más de 100 KB.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Or, it displays a message stating that no files over 100 KB were found.</source>
          <target state="translated">O bien, muestra un mensaje que indica que se encontraron archivos de más de 100 KB.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The previous example also demonstrates how to format the file length results:</source>
          <target state="translated">El ejemplo anterior también muestra cómo dar formato a los resultados de la longitud de archivo:</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>($file.length / 1024).ToString("F0")</source>
          <target state="translated">($file.length / 1024). ToString("F0")</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The value is divided by 1,024 to show the results in kilobytes rather than bytes, and the resulting value is then formatted using the fixed-point format specifier to remove any decimal values from the result.</source>
          <target state="translated">El valor se divide por 1024 para mostrar los resultados en kilobytes, en lugar de bytes y el valor resultante, a continuación, se da formato con el especificador de formato de punto fijo para quitar los valores decimales del resultado.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The 0 makes the format specifier show no decimal places.</source>
          <target state="translated">0 hace que el especificador de formato no mostrar ninguna posición decimal.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The Foreach Statement Inside a Command Pipeline When Foreach appears in a command pipeline, Windows PowerShell uses the foreach alias, which calls the ForEach-Object command.</source>
          <target state="translated">Foreach instrucción dentro de un comando de canalización cuando Foreach aparece en una canalización de comandos, Windows PowerShell usa el alias de foreach, que llama el comando ForEach-Object.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>When you use the foreach alias in a command pipeline, you do not include the ($<ph id="ph1">&lt;item&gt;</ph> in $<ph id="ph2">&lt;collection&gt;</ph>) syntax as you do with the Foreach statement.</source>
          <target state="translated">Cuando se utiliza el alias de foreach en una canalización de comandos, no incluya el ($<ph id="ph1">&lt;item&gt;</ph> en $<ph id="ph2">&lt;collection&gt;</ph>) sintaxis que hacer con la instrucción Foreach.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This is because the prior command in the pipeline provides this information.</source>
          <target state="translated">Esto es porque el comando anterior en la canalización proporciona esta información.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline is as follows:</source>
          <target state="translated">La sintaxis del alias de foreach cuando se utiliza en una canalización de comandos es como sigue:</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>| foreach {&lt;command_block&gt;}</source>
          <target state="translated">| foreach {&lt; command_block &gt;}</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example, the Foreach loop in the following command displays processes whose working set (memory usage) is greater than 20 megabytes (MB).</source>
          <target state="translated">Por ejemplo, el bucle Foreach en el siguiente comando muestra los procesos cuyo conjunto de trabajo (uso de memoria) es mayor que 20 megabytes (MB).</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The Get-Process command gets all of the processes on the computer.</source>
          <target state="translated">El comando Get-Process obtiene todos los procesos en el equipo.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The Foreach alias performs the commands in the script block on each process in sequence.</source>
          <target state="translated">Foreach alias realiza los comandos del bloque de script en todos los procesos en secuencia.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The IF statement selects processes with a working set (WS) greater than 20 megabytes.</source>
          <target state="translated">La instrucción IF selecciona procesos con un conjunto de trabajo (WS) mayor que 20 megabytes.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Write-Host cmdlet writes the name of the process followed by a colon.</source>
          <target state="translated">El cmdlet Write-Host escribe el nombre del proceso seguido de dos puntos.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>It divides the working set value, which is stored in bytes by 1 megabyte to get the working set value in megabytes.</source>
          <target state="translated">Divide el valor de conjunto de trabajo, que se almacena en bytes en 1 megabyte para obtener el valor del conjunto de trabajo en megabytes.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Then it converts the result from a double to a string.</source>
          <target state="translated">A continuación, convierte el resultado de double en una cadena.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It displays the value as a fixed point number with zero decimals (F0), a space separator (" "), and then "MB".</source>
          <target state="translated">Muestra el valor como un número de punto fijo con cero decimales (F0), un separador de espacio ("") y, a continuación, "MB".</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Write-Host "Processes with working sets greater than 20 MB."</source>
          <target state="translated">Write-Host "Procesos con espacios de trabajo mayores que 20 MB".</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Get-Process | foreach { if ($_.WS -gt 20MB) { Write-Host $.name ": " ($.WS/1MB).ToString("F0") MB -Separator ""} }</source>
          <target state="translated">Get-Process | foreach {si ($_. WS - gt 20 MB) {Write-Host $.nombre ":" ($. WS/1MB). ToString("F0") MB-separador ""}}</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks.</source>
          <target state="translated">Foreach alias también es compatible con bloques de comandos de inicio, bloques de comandos intermedio y bloques de comandos final.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.</source>
          <target state="translated">El principio y final bloques de comandos ejecutan una vez y se ejecuta el bloque de comandos intermedio cada vez que un bucle Foreach recorre una colección o matriz.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The syntax of the foreach alias when used in a command pipeline with a beginning, middle, and ending set of command blocks is as follows:</source>
          <target state="translated">La sintaxis del alias de foreach cuando se utiliza en una canalización de comandos con un conjunto de principio, intermedio y final de bloques de comandos es como sigue:</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>| foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>}{<ph id="ph2">&lt;middle
command_block&gt;</ph>}{<ph id="ph3">&lt;ending command_block&gt;</ph>}</source>
          <target state="translated">| foreach {<ph id="ph1">&lt;beginning command_block&gt;</ph>} {<ph id="ph2">&lt;middle
command_block&gt;</ph>} {<ph id="ph3">&lt;ending command_block&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the use of the beginning, middle, and end command blocks.</source>
          <target state="translated">En el ejemplo siguiente se muestra el uso del principio, medio y bloques de comandos final.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach { $fileCount = $directoryCount = 0}{ if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}{ "$directoryCount directories and $fileCount files"}</source>
          <target state="translated">Get-ChildItem | foreach {$fileCount = $directoryCount = 0} {si ($_. PsIsContainer) {$directoryCount ++} else {$fileCount ++}} {"$directoryCount directorios y archivos $fileCount"}</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The beginning block creates and initializes two variables to 0:</source>
          <target state="translated">El bloque inicial se crea e inicializa dos variables en 0:</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>{$fileCount = $directoryCount = 0}</source>
          <target state="translated">{$fileCount = $directoryCount = 0}</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The middle block evaluates whether each item returned by Get-ChildItem is a directory or a file:</source>
          <target state="translated">El bloque intermedio evalúa si cada elemento devuelto por Get-ChildItem es un directorio o un archivo:</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>{if ($_.PsIsContainer) {$directoryCount++} else {$fileCount++}}</source>
          <target state="translated">{Si ($_. PsIsContainer) {$directoryCount ++} else {$fileCount ++}}</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If the item that is returned is a directory, the $directoryCount variable is incremented by 1.</source>
          <target state="translated">Si el elemento que se devuelve es un directorio, la variable $directoryCount se incrementa en 1.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If the item is not a directory, the $fileCount variable is incremented by 1.</source>
          <target state="translated">Si el elemento no es un directorio, la variable $fileCount se incrementa en 1.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The ending block runs after the middle block completes its looping operation and then returns the results of the operation:</source>
          <target state="translated">El bloque final se ejecuta después de que el bloque intermedio completará bucle y, a continuación, devuelve los resultados de la operación:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>{"$directoryCount directories and $fileCount files"}</source>
          <target state="translated">{"$directoryCount directorios y archivos $fileCount"}</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>By using the beginning, middle, and ending command block structure and the pipeline operator, you can rewrite the earlier example to find any files that are greater than 100 KB, as follows:</source>
          <target state="translated">Mediante la estructura de bloque de comandos inicial, intermedio y final y el operador de canalización, puede volver a escribir el ejemplo anterior para buscar los archivos que son mayores que 100 KB, como sigue:</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Get-ChildItem | foreach{ $i = 0}{ if ($_.length -gt 100KB) { Write-Host $.name "file size:" ($.length / 1024).ToString("F0") KB $i++ } }{ if ($i -ne 0) { Write-Host Write-Host "$i file(s) over 100 KB in the current directory."</source>
          <target state="translated">Get-ChildItem | foreach {$i = 0} {si ($_.length - gt 100 KB) {Write-Host $.nombre "tamaño de archivo:" ($.length 1024). ToString("F0") KB $i ++}} {si ($i - ne 0) {Write-Host Write-Host "$i archivos más de 100 KB en el directorio actual."</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>} else { Write-Host "No files greater than 100 KB in the current directory."}</source>
          <target state="translated">} else {Write-Host "No archivos mayores de 100 KB en el directorio actual."}</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>}</source>
          <target state="translated">}</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following example, a function which returns the functions that are used in scripts and script modules, demonstrates how to use the MoveNext method (which works similarly to "skip X" on a For loop) and the Current property of the $foreach variable inside of a foreach script block, even if there are unusually- or inconsistently-spaced function definitions that span multiple lines to declare the function name.</source>
          <target state="translated">El ejemplo siguiente, una función que devuelve las funciones que se utilizan en las secuencias de comandos y módulos de script, muestra cómo utilizar el método MoveNext (que funciona de forma similar a "X"saltar en un bucle For) y la propiedad actual de la variable $foreach dentro de un bloque de script foreach, incluso si hay definiciones de función inusualmente o incoherente-espacios que abarcan varias líneas para declarar el nombre de función.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The example also works if there are comments in the functions used in a script or script module.</source>
          <target state="translated">El ejemplo también funciona si hay comentarios en las funciones utilizadas en un script o un módulo de script.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>function Get-FunctionPosition { [CmdletBinding()] [OutputType('FunctionPosition')] param( [Parameter(Position=0, Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String[]] $Path</source>
          <target state="translated">función Get FunctionPosition {param [CmdletBinding()] [OutputType('FunctionPosition')] ([parámetro (posición = 0, obligatorio, ValueFromPipeline, ValueFromPipelineByPropertyName)] [ValidateNotNullOrEmpty()] [Alias('PSPath')] [System.String []] $Path</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>)</source>
          <target state="translated">) simple</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>process { try { $filesToProcess = if ($_ -is [System.IO.FileSystemInfo]) {</source>
          <target state="translated">proceso {pruebe {$filesToProcess = si ($_-es [System.IO.FileSystemInfo]) {}</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>} else { Get-Item -Path $Path } foreach ($item in $filesToProcess) { if ($item.PSIsContainer -or $item.Extension -notin @('.ps1','.psm1')) { continue } $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile($item.FullName,([REF]$tokens),([REF]$errors)) if ($errors) { Write-Warning "File '$($item.FullName)' has $($errors.Count) parser errors."</source>
          <target state="translated">} else {Get-Item-Path $Path} foreach ($item en $filesToProcess) {si ($item. PSIsContainer- o $item. Extensión - notin @('.ps1','.psm1')) {continuar} $tokens = $errors = $null $ast = [System.Management.Automation.Language.Parser]::ParseFile ($item. FullName,([REF]$tokens),([REF]$errors)) si ($errors) {Write-Warning "archivo ' $($item. FullName)' tiene $($errors. Errores de analizador de recuento)".</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>} :tokenLoop foreach ($token in $tokens) { if ($token.Kind -ne 'Function') { continue } $position = $token.Extent.StartLineNumber do { if (-not $foreach.MoveNext()) { break tokenLoop } $token = $foreach.Current } until ($token.Kind -in @('Generic','Identifier')) $functionPosition = [pscustomobject]@{ Name = $token.Text LineNumber = $position Path = $item.FullName } Add-Member -InputObject $functionPosition -TypeName FunctionPosition -PassThru } } } catch { throw } } }</source>
          <target state="translated">}: tokenLoop foreach ($token en $tokens) {si ($token. Kind - ne 'Función') {continuar} $position = $token. Hacer Extent.StartLineNumber {si (-no $foreach. MoveNext()) {salto tokenLoop} $token = $foreach. Actualizada} hasta ($token. Clase - en @('Generic','Identifier')) $functionPosition = [pscustomobject] @{nombre = $token. Texto LineNumber = ruta de acceso de $position = $item. FullName} Add-Member - InputObject $functionPosition - TypeName FunctionPosition - PassThru}}} catch {throw}}}</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">VEA TAMBIÉN</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables about_If Foreach-Object</source>
          <target state="translated">about_Automatic_Variables about_If Foreach-Object</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>