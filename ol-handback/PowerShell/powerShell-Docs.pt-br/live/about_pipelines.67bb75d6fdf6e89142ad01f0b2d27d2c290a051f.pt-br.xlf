<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3154647bb6f7f37e9f428cf3f822ebcf7466f425</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_pipelines.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ade1b7a643ef9ffde1e8804e570cb62d5aeb7612</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d8327ea469f7eb12fa1f0450258f6248348467a</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">PowerShell, cmdlet</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>about_Pipelines</source>
          <target state="translated">about_Pipelines</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Pipelines</source>
          <target state="translated">Sobre Pipelines</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Pipelines</source>
          <target state="translated">about_Pipelines</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_pipelines</source>
          <target state="translated">about_pipelines</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIÇÃO BREVE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Combining commands into pipelines in the Windows PowerShell</source>
          <target state="translated">Combinando comandos em pipelines no Windows PowerShell</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIÇÃO LONGA</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A pipeline is a series of commands connected by pipeline operators (|)(ASCII 124).</source>
          <target state="translated">Um pipeline é uma série de comandos conectados por operadores de pipeline (|) (ASCII 124).</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Each pipeline operator sends the results of the preceding command to the next command.</source>
          <target state="translated">Cada operador pipeline envia os resultados do comando anterior para o próximo comando.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can use pipelines to send the objects that are output by one command to be used as input to another command for processing.</source>
          <target state="translated">Você pode usar pipelines para enviar os objetos que são produzidos por um comando a ser usado como entrada para outro comando para processamento.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>And you can send the output of that command to yet another command.</source>
          <target state="translated">E você pode enviar a saída desse comando para outro comando.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The result is a very powerful command chain or "pipeline" that is comprised of a series of simple commands.</source>
          <target state="translated">O resultado é uma cadeia de comando muito poderosa ou "pipeline" é composta de uma série de comandos simples.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por exemplo,</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Command-1 | Command-2 | Command-3</source>
          <target state="translated">Comando 1 | Comando 2 | Comando-3</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In this example, the objects that Command-1 emits are sent to Command-2.</source>
          <target state="translated">Neste exemplo, os objetos que emite comando-1 são enviados ao comando-2.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Command-2 processes the objects and sends them to Command-3.</source>
          <target state="translated">Comando 2 processa os objetos e as envia para o comando-3.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Command-3 processes the objects and send them down the pipeline.</source>
          <target state="translated">Comando 3 processa os objetos e enviá-las pelo pipeline.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Because there are no more commands in the pipeline, the results are displayed at the console.</source>
          <target state="translated">Porque não há nenhum mais comandos no pipeline, os resultados são exibidos no console.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In a pipeline, the commands are processed from left to right in the order that they appear.</source>
          <target state="translated">Em um pipeline, os comandos são processados da esquerda para a direita na ordem em que aparecem.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The processing is handled as a single operation and output is displayed as it is generated.</source>
          <target state="translated">O processamento é tratado como uma única operação e a saída é exibida como ela será gerada.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Here is a simple example.</source>
          <target state="translated">Aqui está um exemplo simples.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The following command gets the Notepad process and then stops it.</source>
          <target state="translated">O comando a seguir obtém o processo do bloco de notas e, em seguida, interrompida.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>get-process notepad | stop-process</source>
          <target state="translated">o bloco de notas do Get-process | Stop-process</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The first command uses the Get-Process cmdlet to get an object representing the Notepad process.</source>
          <target state="translated">O primeiro comando usa o cmdlet Get-Process para obter um objeto que representa o processo do bloco de notas.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>It uses a pipeline operator (|) to send the process object to the Stop-Process cmdlet, which stops the Notepad process.</source>
          <target state="translated">Ele usa um operador de pipeline (|) para enviar o objeto de processo para o cmdlet Stop-Process, que interrompe o processo do bloco de notas.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Notice that the Stop-Process command does not have a Name or ID parameter to specify the process, because the specified process is submitted through the pipeline.</source>
          <target state="translated">Observe que o comando Stop-Process não tem um parâmetro de nome ou ID para especificar o processo, pois o processo especificado é enviado por meio do pipeline.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Here is a practical example.</source>
          <target state="translated">Aqui está um exemplo prático.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This command pipeline gets the text files in the current directory, selects only the files that are more than 10,000 bytes long, sorts them by length, and displays the name and length of each file in a table.</source>
          <target state="translated">Esse pipeline de comando obtém os arquivos de texto no diretório atual, seleciona somente os arquivos que têm mais de 10.000 bytes, classifica por comprimento e exibe o nome e o comprimento de cada arquivo em uma tabela.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Get-ChildItem -path *.txt | Where-Object {$_.length -gt 10000} | Sort-Object -property Length | Format-Table -property name, length</source>
          <target state="translated">Get-ChildItem-caminho *. txt | Where-Object {$_.length - gt 10000} | Sort-Object-comprimento de propriedade | Format-Table-nome da propriedade, comprimento</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This pipeline is comprised of four commands in the specified order.</source>
          <target state="translated">Este pipeline é composto por quatro comandos na ordem especificada.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The command is written horizontally, but we will show the process vertically in the following graphic.</source>
          <target state="translated">O comando é escrito horizontalmente, mas mostraremos o processo verticalmente no gráfico a seguir.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Get-ChildItem -path *.txt</source>
          <target state="translated">Get-ChildItem-caminho *. txt</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects ) |   (    .txt         )</source>
          <target state="translated">|   (Objetos FileInfo) |   (    .txt         )</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Where-Object {$_.length -gt 10000}</source>
          <target state="translated">Where-Object {$_.length - gt 10000}</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects ) |   (    .txt         ) |   ( Length &gt; 10000  )</source>
          <target state="translated">|   (Objetos FileInfo) |   (    .txt         ) |   (Comprimento &gt; 10000)</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Sort-Object -property Length</source>
          <target state="translated">Sort-Object-comprimento de propriedade</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects  ) |   (    .txt          ) |   ( Length &gt; 10000   ) |   ( Sorted by length )</source>
          <target state="translated">|   (Objetos FileInfo) |   (    .txt          ) |   (Comprimento &gt; 10000) |   (Classificados por comprimento)</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Format-Table -property name, length</source>
          <target state="translated">Format-Table-nome da propriedade, comprimento</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>|   (FileInfo objects     ) |   (    .txt             ) |   ( Length &gt; 10000      ) |   ( Sorted by length    ) |   (Formatted in a table )</source>
          <target state="translated">|   (Objetos FileInfo) |   (    .txt             ) |   (Comprimento &gt; 10000) |   (Classificados por comprimento) |   (Formatado em uma tabela)</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Name                       Length</source>
          <target state="translated">Comprimento do nome</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>tmp1.txt                    82920 tmp2.txt                   114000 tmp3.txt                   114000</source>
          <target state="translated">tmp1.txt 82920 tmp2.txt 114000 tmp3.txt 114000</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>USING PIPELINES</source>
          <target state="translated">O USO DE PIPELINES</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell cmdlets were designed to be used in pipelines.</source>
          <target state="translated">Os cmdlets do Windows PowerShell foi projetados para ser usado em pipelines.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For example, you can usually pipe the results of a Get cmdlet to an action cmdlet (such as a Set, Start, Stop, or Rename cmdlet) for the same noun.</source>
          <target state="translated">Por exemplo, geralmente é possível canalizar os resultados de um cmdlet de Get para um cmdlet de ação (como um conjunto, iniciar, parar ou renomear cmdlet) para o mesmo substantivo.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>For example, you can pipe any service from the Get-Service cmdlet to the Start-Service or Stop-Service cmdlets (although disabled services cannot be restarted in this way).</source>
          <target state="translated">Por exemplo, você pode direcionar qualquer serviço do cmdlet Get-Service para os cmdlets de serviço iniciar ou parar o serviço (embora serviços desativados não podem ser reiniciados assim).</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This command pipeline starts the WMI service on the computer:</source>
          <target state="translated">Esse pipeline de comando inicia o serviço WMI no computador:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>get-service wmi | start-service</source>
          <target state="translated">Get-service wmi | Iniciar serviço</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The cmdlets that get and set objects of the Windows PowerShell providers, such as the Item and ItemProperty cmdlets, are also designed to be used in pipelines.</source>
          <target state="translated">Os cmdlets get e set objetos dos provedores do Windows PowerShell, como os cmdlets de Item e ItemProperty, também devem ser usadas em pipelines.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For example, you can pipe the results of a Get-Item or Get-ChildItem command in the Windows PowerShell registry provider to the New-ItemProperty cmdlet.</source>
          <target state="translated">Por exemplo, é possível canalizar os resultados de um Item de Get ou o comando Get-ChildItem no provedor de registro do Windows PowerShell para o cmdlet New-ItemProperty.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This command adds a new registry entry, NoOfEmployees, with a value of 8124, to the MyCompany registry key.</source>
          <target state="translated">Este comando adiciona uma nova entrada de registro, NoOfEmployees, com um valor de 8124, à chave de registro MyCompany.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>get-item -path HKLM:\Software\MyCompany | new-Itemproperty -name NoOfEmployees -value 8124</source>
          <target state="translated">Get-item - caminho HKLM:\Software\MyCompany | New-Itemproperty-NoOfEmployees de nome-valor 8124</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Many of the utility cmdlets, such as Get-Member, Where-Object, Sort-Object, Group-Object, and Measure-Object are used almost exclusively in pipelines.</source>
          <target state="translated">Muitos dos cmdlets do utilitário, como Get-Member, Where-Object, Sort-Object, objeto de grupo e objeto de medida são usados quase que exclusivamente em pipelines.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You can pipe any objects to these cmdlets.</source>
          <target state="translated">É possível redirecionar qualquer objeto para esses cmdlets.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For example, you can pipe all of the processes on the computer to the Sort-Object command and have them sorted by the number of handles in the process.</source>
          <target state="translated">Por exemplo, você pode redirecionar todos os processos no computador para o comando Sort-Object e sejam classificados pelo número de identificadores do processo.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>get-process | sort-object -property handles</source>
          <target state="translated">Get-process | Sort-object-identificadores de propriedade</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Also, you can pipe any objects to the formatting cmdlets, such as Format-List and Format-Table, the Export cmdlets, such as Export-Clixml and Export-CSV, and the Out cmdlets, such as Out-Printer.</source>
          <target state="translated">Além disso, você pode redirecionar todos os objetos para os cmdlets de formatação como Format-List e Format-Table, os cmdlets de exportação, como Export-Clixml e Export-CSV e os cmdlets Out, como out-Printer.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, you can pipe the Winlogon process to the Format-List cmdlet to display all of the properties of the process in a list.</source>
          <target state="translated">Por exemplo, você pode canalizar o processo do Winlogon para o cmdlet Format-List para exibir todas as propriedades do processo em uma lista.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>get-process winlogon | format-list -property *</source>
          <target state="translated">o winlogon Get-process | format-list-propriedade *</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>With a bit of practice, you'll find that combining simple commands into pipelines saves time and typing, and makes your scripting more efficient.</source>
          <target state="translated">Com um pouco de prática, você encontrará combinar comandos simples em pipelines economiza tempo e digitando e torna mais eficiente a seu script.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>HOW PIPELINES WORK</source>
          <target state="translated">COMO FUNCIONAM OS PIPELINES</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>When you "pipe" objects, that is send the objects in the output of one command to another command, Windows PowerShell tries to associate the piped objects with one of the parameters of the receiving cmdlet.</source>
          <target state="translated">Quando você "redirecionar" objetos, que é enviar os objetos na saída de um comando para outro comando, o Windows PowerShell tenta associar os objetos redirecionados um dos parâmetros do cmdlet recebimento.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To do so, the Windows PowerShell "parameter binding" component, which associates input objects with cmdlet parameters, tries to find a parameter that meets the following criteria:</source>
          <target state="translated">Para fazer isso, o componente do Windows PowerShell "associação de parâmetro", que associa objetos de entrada com parâmetros de cmdlet, tenta encontrar um parâmetro que atenda aos seguintes critérios:</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>-- The parameter must accept input from a pipeline (not all do) -- The parameter must accept the type of object being sent or a type that the object can be converted to.</source>
          <target state="translated">-- O parâmetro deve aceitar entrada de um pipeline (nem todos fazem)--o parâmetro deve aceitar o tipo de objeto que está sendo enviado ou um tipo que o objeto pode ser convertido.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>-- The parameter must not already be used in the command.</source>
          <target state="translated">-- O parâmetro já não deve ser usado no comando.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For example, the Start-Service cmdlet has many parameters, but only two of them, Name and InputObject accept pipeline input.</source>
          <target state="translated">Por exemplo, o cmdlet Start-Service tem muitos parâmetros, mas somente dois deles, nome e InputObject aceitam entrada do pipeline.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The Name parameter takes strings and the InputObject parameter takes service objects.</source>
          <target state="translated">O parâmetro Name usa cadeias de caracteres e o parâmetro InputObject usa objetos de serviço.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Therefore, you can pipe strings and service objects (and objects with properties that can be converted to string and service objects) to Start-Service.</source>
          <target state="translated">Portanto, é possível canalizar cadeias de caracteres e serviço objetos (e objetos com propriedades que podem ser convertidos em objetos de cadeia de caracteres e de serviço) para o serviço de início.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If the parameter binding component of Windows PowerShell cannot associate the piped objects with a parameter of the receiving cmdlet, the command fails and Windows PowerShell prompts you for the missing parameter values.</source>
          <target state="translated">Se o componente de associação de parâmetro do Windows PowerShell não é possível associar os objetos redirecionados com um parâmetro do cmdlet recebimento, o comando falhará e o Windows PowerShell solicitará os valores de parâmetro ausente.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You cannot force the parameter binding component to associate the piped objects with a particular parameter -- you cannot even suggest a parameter.</source>
          <target state="translated">Não é possível forçar o componente de associação de parâmetro para associar os objetos redirecionados um determinado parâmetro--você não pode até mesmo sugerir um parâmetro.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Instead, the logic of the component manages the piping as efficiently as possible.</source>
          <target state="translated">Em vez disso, a lógica do componente gerencia a tubulação forma mais eficiente possível.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>ONE-AT-A-TIME PROCESSING</source>
          <target state="translated">PROCESSAMENTO DE UM AT-UMA VEZ</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Piping objects to a command is much like using a parameter of the command to submit the objects.</source>
          <target state="translated">Redirecionar objetos para um comando é muito semelhante usando um parâmetro do comando para enviar os objetos.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>For example, piping objects representing the services on the computer to a Format-Table command, such as:</source>
          <target state="translated">Por exemplo, canalizar os objetos que representam os serviços no computador a um comando Format-Table, como:</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>get-service | format-table -property name, dependentservices</source>
          <target state="translated">Get-service | format-table-nome de propriedade, dependentservices</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>is much like saving the service objects in a variable and using the InputObject parameter of Format-Table to submit the service object.</source>
          <target state="translated">é semelhante a salvar os objetos de serviço em uma variável e usar o parâmetro InputObject do Format-Table para enviar o objeto de serviço.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>$services = get-service format-table -inputobject $services -property name, dependentservices</source>
          <target state="translated">$services = get-service format-table - inputobject $services-nome da propriedade, dependentservices</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>or imbedding the command in the parameter value</source>
          <target state="translated">ou como inserir o comando no valor do parâmetro</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>format-table -inputobject (get-service wmi) -property name, dependentservices</source>
          <target state="translated">format-table - inputobject (get-service wmi)-nome de propriedade, dependentservices</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>However, there is an important difference.</source>
          <target state="translated">No entanto, há uma diferença importante.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>When you pipe multiple objects to a command, Windows PowerShell sends the objects to the command one at a time.</source>
          <target state="translated">Quando você direciona vários objetos em um comando, o Windows PowerShell envia os objetos para o comando um por vez.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When you use a command parameter, the objects are sent as a single array object.</source>
          <target state="translated">Quando você usa um parâmetro de comando, os objetos são enviados como um único objeto de matriz.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This seemingly technical difference can have interesting, and sometimes useful, consequences.</source>
          <target state="translated">Essa diferença aparentemente técnica pode ter consequências interessantes e útil às vezes.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>For example, if you pipe multiple process objects from the Get-Process cmdlet to the Get-Member cmdlet, Windows PowerShell sends each process object, one at a time, to Get-Member.</source>
          <target state="translated">Por exemplo, se você redirecionar vários objetos de processo do cmdlet Get-Process para o cmdlet Get-Member, o Windows PowerShell envia cada objeto de processo, um de cada vez, para Get-Member.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Get-Member displays the .NET class (type) of the process objects, and their properties and methods.</source>
          <target state="translated">Get-Member exibe a classe do .NET (tipo) de objetos de processo e suas propriedades e métodos.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>(Get-Member eliminates duplicates, so if the objects are all of the same type, it displays only one object type.)</source>
          <target state="translated">(Get-Member elimina duplicatas, portanto, se os objetos são todas do mesmo tipo, ele exibe apenas um tipo de objeto.)</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In this case, Get-Member displays the properties and methods of each process object, that is, a System.Diagnostics.Process object.</source>
          <target state="translated">Nesse caso, o Get-Member exibe as propriedades e métodos de cada objeto de processo, ou seja, um objeto System.Diagnostics.Process.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>get-process | get-member</source>
          <target state="translated">Get-process | get-member</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>TypeName: System.Diagnostics.Process</source>
          <target state="translated">TypeName: System.Diagnostics.Process</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Name                           MemberType     Definition</source>
          <target state="translated">Nome MemberType definição</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Handles                        AliasProperty  Handles = Handlecount Name                           AliasProperty  Name = ProcessName NPM                            AliasProperty  NPM = NonpagedSystemMemorySize</source>
          <target state="translated">Lida com identificadores de AliasProperty = nome do AliasProperty Handlecount = ProcessName NPM AliasProperty NPM = NonpagedSystemMemorySize</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>However, if you use the InputObject parameter of Get-Member, then Get-Member receives an array of System.Diagnostics.Process objects as a single unit, and it displays the properties of an array of objects.</source>
          <target state="translated">No entanto, se você usar o parâmetro InputObject do Get-Member, em seguida, Get-Member recebe uma matriz de objetos System.Diagnostics.Process como uma única unidade e exibe as propriedades de uma matriz de objetos.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>(Note the array symbol ([]) after the System.Object type name.)</source>
          <target state="translated">(Observe o símbolo de matriz ([]) após o nome do tipo System. Object).</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>get-member -inputobject (get-process)</source>
          <target state="translated">get-member - inputobject (get-process)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>TypeName: System.Object[]</source>
          <target state="translated">TypeName: [] de System. Object</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Name               MemberType    Definition</source>
          <target state="translated">Nome MemberType Definition</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Count              AliasProperty Count = Length Address            Method        System.Object&amp; Address(Int32 ) Clone              Method        System.Object Clone()</source>
          <target state="translated">Contagem de contagem de AliasProperty = comprimento endereço método System. Object &amp; endereço clone () Object (Int32) do método Clone</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This result might not be what you intended, but after you understand it, you can use it.</source>
          <target state="translated">Esse resultado pode não ser o que você pretendia, mas depois de entender, você pode usá-lo.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>For example, an array of process objects has a Count property that you can use to count the number of processes on the computer.</source>
          <target state="translated">Por exemplo, uma matriz de objetos de processo tem uma propriedade Count que você pode usar para contar o número de processos no computador.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>(get-process).count</source>
          <target state="translated">.count (get-process)</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This distinction can be important, so remember that when you pipe objects to a cmdlet, they are delivered one at a time.</source>
          <target state="translated">Essa distinção pode ser importante, lembre-se que, quando você direcionar objetos para um cmdlet, eles são entregues um de cada vez.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>ACCEPTS PIPELINE INPUT</source>
          <target state="translated">ACEITA ENTRADA DO PIPELINE</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>In order to receive objects in a pipeline, the receiving cmdlet must have a parameter that accepts pipeline input.</source>
          <target state="translated">Para receber os objetos em um pipeline, o cmdlet de recebimento deve ter um parâmetro que aceita entrada do pipeline.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You can use a Get-Help command with the Full or Parameter parameters to determine which, if any, of a cmdlet's parameters accepts pipeline input.</source>
          <target state="translated">Você pode usar um comando Get-Help com os parâmetros completo ou parâmetro para determinar que, se houver, de parâmetros do cmdlet aceita entrada do pipeline.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>In the Get-Help default display, the "Accepts pipeline input" item appears in a table of parameter attributes.</source>
          <target state="translated">Na exibição padrão do Get-Help, o item "Aceita entrada do pipeline" aparece em uma tabela de atributos de parâmetro.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>This table is displayed only when you use the Full or Parameter parameters of the Get-Help cmdlet.</source>
          <target state="translated">Essa tabela é exibida somente quando você usa os parâmetros completo ou o parâmetro do cmdlet Get-Help.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>For example, to determine which of the parameters of the Start-Service cmdlet accepts pipeline input, type:</source>
          <target state="translated">Por exemplo determinar quais dos parâmetros do cmdlet Start-Service aceita entrada do pipeline, digite:</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>get-help start-service -full</source>
          <target state="translated">Get-help start-service-completo</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>get-help start-service -parameter *</source>
          <target state="translated">Get-help start-service-parâmetro *</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For example, the help for the Start-Service cmdlet shows that the Name and InputObject parameters accept pipeline input ("true").</source>
          <target state="translated">Por exemplo, a Ajuda para o cmdlet Start-Service mostra os parâmetros Name e InputObject aceitam entrada de pipeline ("true").</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>All other parameters have a value of "false" in the "Accept pipeline input?"</source>
          <target state="translated">Todos os outros parâmetros têm um valor de "false" em "aceitar pipeline entrada?"</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>row.</source>
          <target state="translated">linha.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>-name &lt;string[]&gt; Specifies the service names for the service to be started.</source>
          <target state="translated">-nome &lt; string [] &gt; especifica os nomes de serviço para o serviço a ser iniciado.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The parameter name is optional.</source>
          <target state="translated">O nome do parâmetro é opcional.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You can use "-Name" or its alias, "-ServiceName", or you can omit the parameter name.</source>
          <target state="translated">Você pode usar "-Name" ou seu alias "-ServiceName", ou pode omitir o nome do parâmetro.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Required?</source>
          <target state="translated">Necessário?</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>true Position?</source>
          <target state="translated">Posição real?</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>1 Default value --&gt;  Accept pipeline input?</source>
          <target state="translated">Valor de padrão de 1--&gt; aceitar entrada de pipeline?</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>true (ByValue, ByPropertyName) Accept wildcard characters?</source>
          <target state="translated">verdadeiro (ByValue, ByPropertyName) aceitar caracteres curinga?</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">verdadeiro</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>-inputObject &lt;ServiceController[]&gt; Specifies ServiceController objects representing the services to be started.</source>
          <target state="translated">-inputObject &lt; ServiceController [] &gt; objetos de Especifica ServiceController que representam os serviços sejam iniciados.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Enter a variable that contains the objects or type a command or expression that gets the objects.</source>
          <target state="translated">Insira uma variável que contém os objetos ou digite um comando ou uma expressão que obtém os objetos.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Required?</source>
          <target state="translated">Necessário?</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>false Position?</source>
          <target state="translated">Posição False?</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>named Default value --&gt;  Accept pipeline input?</source>
          <target state="translated">valor padrão nomeado--&gt; aceitar entrada de pipeline?</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>true (ByValue) Accept wildcard characters?</source>
          <target state="translated">verdadeiro (ByValue) aceitar curingas?</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>false</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>This means that you can send objects (PsObjects) through the pipeline to the Where-Object cmdlet and Windows PowerShell will associate the object with the InputObject parameter.</source>
          <target state="translated">Isso significa que você pode enviar objetos (PsObjects) por meio do pipeline para o cmdlet Where-Object e Windows PowerShell irá associar o objeto com o parâmetro InputObject.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>METHODS OF ACCEPTING PIPELINE INPUT</source>
          <target state="translated">MÉTODOS DE ACEITAR ENTRADA DE PIPELINE</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Cmdlets parameters can accept pipeline input in one of two different ways:</source>
          <target state="translated">Parâmetros de cmdlets podem aceitar entrada de pipeline em uma das duas maneiras diferentes:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>-- ByValue: Parameters that accept input "by value" can accept piped objects that have the same .NET type as their parameter value or objects that can be converted to that type.</source>
          <target state="translated">-ByValue: parâmetros que aceitam a entrada "por valor de" pode aceitar canalizados objetos que têm o mesmo tipo de .NET como seu valor de parâmetro ou objetos que podem ser convertidos para esse tipo.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>For example, the Name parameter of Start-Service accepts pipeline input by value.</source>
          <target state="translated">Por exemplo, o parâmetro de nome do serviço de início aceita entrada do pipeline por valor.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>It can accept string objects or objects that can be converted to strings.</source>
          <target state="translated">Ele pode aceitar objetos de cadeia de caracteres ou objetos que podem ser convertidos em cadeias de caracteres.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>-- ByPropertyName: Parameters that accept input "by property name" can accept piped objects only when a property of the object has the same name as the parameter.</source>
          <target state="translated">-ByPropertyName: parâmetros que aceitam a entrada "pelo nome da propriedade" pode aceitar canalizados objetos somente quando uma propriedade do objeto tem o mesmo nome que o parâmetro.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>For example, the Name parameter of Start-Service can accept objects that have a Name property.</source>
          <target state="translated">Por exemplo, o parâmetro de nome do serviço de início pode aceitar objetos que têm uma propriedade de nome.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>(To list the properties of an object, pipe it to Get-Member.)</source>
          <target state="translated">(Para listar as propriedades de um objeto, Redirecione para Get-Member.)</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Some parameters can accept objects by value or by property name.</source>
          <target state="translated">Alguns parâmetros podem aceitar objetos por valor ou por nome de propriedade.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>These parameters are designed to take input from the pipeline easily.</source>
          <target state="translated">Esses parâmetros destinam-se a entrada do pipeline facilmente.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>INVESTIGATING PIPELINE ERRORS</source>
          <target state="translated">INVESTIGAR ERROS DO PIPELINE</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>If a command fails because of a pipeline error, you can investigate the failure and rewrite the command.</source>
          <target state="translated">Se um comando falhar devido a um erro de pipeline, você pode investigar a falha e reescreva o comando.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For example, the following command tries to move a registry entry from one registry key to another by using the Get-Item cmdlet to get the destination path and then piping the path to the Move-ItemProperty cmdlet.</source>
          <target state="translated">Por exemplo, o seguinte comando tenta mover uma entrada de registro de chave de um registro para outro usando o cmdlet Get-Item para obter o caminho de destino e canalizar o caminho para o cmdlet Move-ItemProperty.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Specifically, the command uses the Get-Item cmdlet to get the destination path.</source>
          <target state="translated">Especificamente, o comando usa o cmdlet Get-Item para obter o caminho de destino.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>It uses a pipeline operator to send the result to the Move-ItemProperty cmdlet.</source>
          <target state="translated">Ele usa um operador de pipeline para enviar o resultados para o cmdlet Move-ItemProperty.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The Move-ItemProperty command specifies the current path and name of the registry entry to be moved.</source>
          <target state="translated">O comando Move-ItemProperty Especifica o caminho atual e o nome da entrada do registro a ser movido.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>get-item -path hklm:\software\mycompany\sales | move-itemproperty -path hklm:\software\mycompany\design -name product</source>
          <target state="translated">Get-item - caminho hklm:\software\mycompany\sales | Move-itemproperty-caminho hklm:\software\mycompany\design-produto</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The command fails and Windows PowerShell displays the following error message:</source>
          <target state="translated">O comando falhará e o Windows PowerShell exibirá a seguinte mensagem de erro:</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Move-ItemProperty : The input object cannot be bound to any parameters for the command either because the command does not take pipeline input or the input and its properties do not match any of the parameters that take pipeline input.</source>
          <target state="translated">Move-ItemProperty: O objeto de entrada não pode ser associado a quaisquer parâmetros para o comando porque o comando não aceita entrada de pipeline ou a entrada e suas propriedades não coincidem com qualquer um dos parâmetros que aceita entrada do pipeline.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>At line:1 char:23</source>
          <target state="translated">Na linha: 1 char: 23</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>$a | move-itemproperty &lt;&lt;&lt;&lt;  -path hklm:\software\mycompany\design -name product</source>
          <target state="translated">$um | Move-itemproperty &lt;&lt;&lt;&lt;-caminho hklm:\software\mycompany\design-produto</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>To investigate, use the Trace-Command cmdlet to trace the Parameter Binding component of Windows PowerShell.</source>
          <target state="translated">Para investigar, use o cmdlet Trace-Command para rastrear o componente de associação de parâmetros do Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The following command traces the Parameter Binding component while the command is processing.</source>
          <target state="translated">O seguinte comando rastreia o componente de associação de parâmetros enquanto o comando está sendo processada.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>It uses the -pshost parameter to display the results at the console and the -filepath command to send them to the debug.txt file for later reference.</source>
          <target state="translated">Ele usa o parâmetro - pshost para exibir os resultados no console e o comando - filepath para enviá-los para o arquivo debug.txt para referência posterior.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>trace-command -name parameterbinding -expression {get-item -path hklm:\software\mycompany\sales | move-itemproperty -path hklm:\software\mycompany\design -name product} -pshost -filepath debug.txt</source>
          <target state="translated">Trace-command - nome parameterbinding-expressão {get-item-caminho hklm:\software\mycompany\sales | move-itemproperty-caminho hklm:\software\mycompany\design-produto} - pshost - filepath debug.txt</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>The results of the trace are lengthy, but they show the values being bound to the Get-Item cmdlet and then the named values being bound to the Move-ItemProperty cmdlet.</source>
          <target state="translated">Os resultados do rastreamento são longos, mas eles mostram os valores que está sendo associados para o cmdlet Get-Item e, em seguida, os valores nomeados que está sendo associados ao cmdlet Move-ItemProperty.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>BIND NAMED cmd line args [Move-ItemProperty] BIND arg [hklm:\software\mycompany\design] to parameter [Path]</source>
          <target state="translated">ASSOCIAR CHAMADO cmd linha args [Move-ItemProperty] LIGAÇÃO arg [hklm:\software\mycompany\design] ao parâmetro [caminho]</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>BIND arg [product] to parameter [Name]</source>
          <target state="translated">ASSOCIAR arg [product] ao parâmetro [nome]</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>....</source>
          <target state="translated">....</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>BIND POSITIONAL cmd line args [Move-ItemProperty]</source>
          <target state="translated">Argumentos de linha ASSOCIAR POSICIONAL cmd [Move-ItemProperty]</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Finally, it shows that the attempt to bind the path to the Destination parameter of Move-ItemProperty failed.</source>
          <target state="translated">Por fim, ele mostra que a tentativa de vincular o caminho para o parâmetro de destino do Move-ItemProperty falhou.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>BIND PIPELINE object to parameters: [Move-ItemProperty] PIPELINE object TYPE = [Microsoft.Win32.RegistryKey] RESTORING pipeline parameter's original values Parameter [Destination] PIPELINE INPUT ValueFromPipelineByPropertyName NO COERCION Parameter [Credential] PIPELINE INPUT ValueFromPipelineByPropertyName NO COERCION</source>
          <target state="translated">Objeto de PIPELINE VINCULAR aos parâmetros: TIPO de objeto PIPELINE [Move-ItemProperty] = [Microsoft.Win32.RegistryKey] original do parâmetro de pipeline RESTAURANDO valores de parâmetro [destino] PIPELINE ENTRADA ValueFromPipelineByPropertyName NÃO COERÇÃO parâmetro [credencial] PIPELINE ENTRADA ValueFromPipelineByPropertyName NÃO COERÇÃO</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>To investigate the failure, use the Get-Help cmdlet to view the attributes of the Destination parameter.</source>
          <target state="translated">Para investigar a falha, use o cmdlet Get-Help para exibir os atributos do parâmetro Destination.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>The following command gets detailed information about the Destination parameter.</source>
          <target state="translated">O comando a seguir obtém informações detalhadas sobre o parâmetro de destino.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>get-help move-itemproperty -parameter destination</source>
          <target state="translated">Get-help move-itemproperty-destino do parâmetro</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The results show that Destination takes pipeline input only "by property name".</source>
          <target state="translated">Os resultados mostram que o destino recebe entrada de pipeline apenas "pelo nome da propriedade".</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>That is, the piped object must have a property named Destination.</source>
          <target state="translated">Ou seja, o objeto canalizado deve ter uma propriedade chamada de destino.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>-destination <ph id="ph1">&lt;string&gt;</ph> Specifies the path to the destination location.</source>
          <target state="translated">-destino <ph id="ph1">&lt;string&gt;</ph> Especifica o caminho para o local de destino.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Required?</source>
          <target state="translated">Necessário?</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>true Position?</source>
          <target state="translated">Posição real?</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>2 Default value Accept pipeline input?</source>
          <target state="translated">Aceitar entrada de pipeline de valor padrão 2?</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>true (ByPropertyName) Accept wildcard characters?</source>
          <target state="translated">verdadeiro (ByPropertyName) aceitar curingas?</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">verdadeiro</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>To see the properties of the object being piped to the Move-ItemProperty cmdlet, pipe it to the Get-Member cmdlet.</source>
          <target state="translated">Para ver as propriedades do objeto que está sendo enviada por pipe para o cmdlet Move-ItemProperty, redirecione-lo para o cmdlet Get-Member.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The following command pipes the results of the first part of the command to the Get-Member cmdlet.</source>
          <target state="translated">O seguinte comando canaliza os resultados da primeira parte do comando para o cmdlet Get-Member.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>get-item -path hklm:\software\mycompany\sales | get-member</source>
          <target state="translated">Get-item - caminho hklm:\software\mycompany\sales | get-member</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The output shows that the item is a Microsoft.Win32.RegistryKey that does not have a Destination property.</source>
          <target state="translated">A saída mostra que o item é um Microsoft.Win32.RegistryKey que não tem uma propriedade de destino.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>That explains why the command failed.</source>
          <target state="translated">Isso explica por que o comando falhou.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>To fix the command, we must specify the destination in the Move-ItemProperty cmdlet.</source>
          <target state="translated">Para corrigir o comando, podemos deve especificar o destino no cmdlet Move-ItemProperty.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>We can use a Get-ItemProperty command to get the path, but the name and destination must be specified in the Move-ItemProperty part of the command.</source>
          <target state="translated">Podemos usar um comando Get-ItemProperty para obter o caminho e o nome e o destino devem ser especificados na parte do comando Move-ItemProperty.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>get-item -path hklm:\software\mycompany\design | move-itemproperty -dest hklm:\software\mycompany\design -name product</source>
          <target state="translated">Get-item - caminho hklm:\software\mycompany\design | Move-itemproperty dest - hklm:\software\mycompany\design-produto</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>To verify that the command worked, use a Get-ItemProperty command:</source>
          <target state="translated">Para verificar se o comando funcionou, use um comando Get-ItemProperty:</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>get-itemproperty hklm:\software\mycompany\sales</source>
          <target state="translated">Get-itemproperty hklm:\software\mycompany\sales</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The results show that the Product registry entry was moved to the Sales key.</source>
          <target state="translated">Os resultados mostram que a entrada de registro do produto foi movida para a chave de vendas.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>PSPath       : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany\sales PSParentPath : Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany PSChildName  : sales PSDrive      : HKLM PSProvider   : Microsoft.PowerShell.Core\Registry Product      : 18</source>
          <target state="translated">PSPath: Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany\sales PSParentPath: Microsoft.PowerShell.Core\Registry::HKEY_LOCAL_MACHINE\software\mycompany PSChildName: vendas PSDrive: PSProvider HKLM: Microsoft.PowerShell.Core\Registry produto: 18</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">CONSULTE TAMBÉM</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>about_objects about_parameters about_command_syntax about_foreach</source>
          <target state="translated">about_objects about_parameters about_command_syntax about_foreach</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>