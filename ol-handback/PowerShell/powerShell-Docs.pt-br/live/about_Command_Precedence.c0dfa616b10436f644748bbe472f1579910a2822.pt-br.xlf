<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e64799232a97a2ccc413eedab8847a68fc45f805</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Command_Precedence.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a73f57efd0a2d7eb74d3017f761cf8de22d9dbed</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ff216515ee10fbdc6f1053f80852fa01f0958004</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">PowerShell, cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Command Precedence</source>
          <target state="translated">Sobre a precedência de comando</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Command_Precedence</source>
          <target state="translated">about_Command_Precedence</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">DESCRIÇÃO BREVE</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes how Windows PowerShell determines which command to run.</source>
          <target state="translated">Descreve como o Windows PowerShell determina qual comando deve ser executado.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">DESCRIÇÃO LONGA</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This topic explains how Windows PowerShell determines which command to run, especially when a session contains more than one command with the same name.</source>
          <target state="translated">Este tópico explica como o Windows PowerShell determina qual comando seja executado, especialmente quando uma sessão contém mais de um comando com o mesmo nome.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It also explains how to run commands that do not run by default, and it explains how to avoid command-name conflicts in your session.</source>
          <target state="translated">Ele também explica como executar comandos que não são executados por padrão, e explica como evitar conflitos de nome do comando na sessão.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>COMMAND PRECEDENCE</source>
          <target state="translated">PRECEDÊNCIA DE COMANDOS</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When a session includes commands that have the same name, Windows PowerShell uses the following rules to decide which command to run.</source>
          <target state="translated">Quando uma sessão inclui comandos que têm o mesmo nome, o Windows PowerShell usa as regras a seguir para decidir qual comando deve ser executado.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>These rules become very important when you add commands to your session from modules, snap-ins, and other sessions.</source>
          <target state="translated">Essas regras se tornar muito importantes ao adicionar comandos à sua sessão de sessões de snap-ins e outros módulos.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>-- If you specify the path to a command, Windows PowerShell runs the command at the location specified by the path.</source>
          <target state="translated">-- Se você especificar o caminho para um comando, o Windows PowerShell executa o comando no local especificado pelo caminho.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, the following command runs the FindDocs.ps1 script in the C:\TechDocs directory:</source>
          <target state="translated">Por exemplo, o comando a seguir executa o script FindDocs.ps1 no diretório C:\TechDocs:</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>C:\TechDocs\FindDocs.ps1</source>
          <target state="translated">C:\TechDocs\FindDocs.ps1</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>As a security feature, Windows PowerShell does not run executable (native) commands, including Windows PowerShell scripts, unless the command is located in a path that is listed in the Path environment variable ($env:path) or unless you specify the path to the script file.</source>
          <target state="translated">Como um recurso de segurança, o Windows PowerShell não executa comandos executáveis (nativos), incluindo scripts do Windows PowerShell, a menos que o comando está localizado em um caminho que é listado na variável de ambiente Path ($env: caminho) ou a menos que você especifique o caminho para o arquivo de script.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>To run a script that is in the current directory, specify the full path, or type a dot (.) to represent the current directory.</source>
          <target state="translated">Para executar um script que está no diretório atual, especifique o caminho completo ou digite um ponto (.) para representar o diretório atual.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example, to run the FindDocs.ps1 file in the current directory, type:</source>
          <target state="translated">Por exemplo, para executar o arquivo FindDocs.ps1 no diretório atual, digite:</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>.\FindDocs.ps1</source>
          <target state="translated">.\FindDocs.ps1</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>-- If you do not specify a path, Windows PowerShell uses the following precedence order when it runs commands:</source>
          <target state="translated">-- Se você não especificar um caminho, o Windows PowerShell usa a seguinte ordem de precedência quando ele executa comandos:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Função</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Cmdlet</source>
          <target state="translated">Cmdlet</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Native Windows commands</source>
          <target state="translated">Comandos nativos do Windows</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Therefore, if you type "help", Windows PowerShell first looks for an alias named "help", then a function named "Help", and finally a cmdlet named "Help".</source>
          <target state="translated">Portanto, se você digitar "help", o Windows PowerShell primeiro procura por um alias chamado "Ajuda", em seguida, uma função nomeada "Ajuda" e, finalmente, um cmdlet chamado "Ajuda".</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>It runs the first "help" item that it finds.</source>
          <target state="translated">Ele é executado primeiro item "Ajuda" que encontra.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>For example, if you have a Get-Map function in the session and you import a cmdlet named Get-Map.</source>
          <target state="translated">Por exemplo, se você tiver uma função de Get-mapa na sessão e importar um cmdlet chamado Get-mapa.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>By default, when you type "Get-Map", Windows PowerShell runs the Get-Map function.</source>
          <target state="translated">Por padrão, quando você digitar "Get-mapa", o Windows PowerShell executa a função Get-Map.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-- When the session contains items of the same type that have the same name, such as two cmdlets with the same name, Windows PowerShell runs the item that was added to the session most recently.</source>
          <target state="translated">– Quando a sessão contém itens do mesmo tipo que têm o mesmo nome, como dois cmdlets com o mesmo nome, o Windows PowerShell executa o item que foi adicionado à sessão mais recentemente.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, if you have a cmdlet named Get-Date and you import another cmdlet named Get-Date, by default, Windows PowerShell runs the most-recently imported cmdlet when you type "Get-Date".</source>
          <target state="translated">Por exemplo, se você tiver um cmdlet chamado Get-Date e importar outro cmdlet chamado Get-Date, por padrão, o Windows PowerShell executa o cmdlet mais recentemente importado quando você digitar "Get data".</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>HIDDEN and REPLACED ITEMS As a result of these rules, items can be replaced or hidden by items with the same name.</source>
          <target state="translated">ITENS OCULTOS e SUBSTITUÍDO como resultado essas regras, itens podem ser substituídos ou ocultados por itens com o mesmo nome.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>--  Items are "hidden" or "shadowed" if you can still access the original item, such as by qualifying the item name with a module or snap-in name.</source>
          <target state="translated">-Itens são "ocultos" ou "sombreados" Se você ainda pode acessar o item original, como qualificar o nome do item com um módulo ou snap-in.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, if you import a function that has the same name as a cmdlet in the session, the cmdlet is hidden (but not replaced) because it was imported from a snap-in or module.</source>
          <target state="translated">Por exemplo, se você importar uma função que tem o mesmo nome que um cmdlet na sessão, o cmdlet é oculto (mas não substituído) porque ela foi importada de um snap-in ou módulo.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>--  Items are "replaced" or "overwritten" if you can no longer access the original item.</source>
          <target state="translated">-Itens são "substituídos" ou "substituídos" Se você não pode acessar o item original.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For example, if you import a variable that has the same name as a a variable in the session, the original variable is replaced and is no longer accessible.</source>
          <target state="translated">Por exemplo, se você importar uma variável que tem o mesmo nome que um uma variável na sessão, a variável original é substituída e não está mais acessível.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You cannot qualify a variable with a module name.</source>
          <target state="translated">Você não pode qualificar uma variável com um nome de módulo.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Also, if you type a function at the command line and then import a function with the same name, the original function is replaced and is no longer accessible.</source>
          <target state="translated">Além disso, se você digitar uma função na linha de comando e, em seguida, importar uma função com o mesmo nome, a função original é substituída e não está mais acessível.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>FINDING HIDDEN COMMANDS</source>
          <target state="translated">LOCALIZANDO OCULTADO COMANDOS</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The All parameter of the Get-Command cmdlet gets all commands with the specified name, even if they are hidden or replaced.</source>
          <target state="translated">Todos os parâmetros do cmdlet Get-Command obtém todos os comandos com o nome especificado, mesmo se eles são ocultados ou substituídos.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, by default, Get-Command gets only the commands that run when you type the command name.</source>
          <target state="translated">A partir do Windows PowerShell 3.0, por padrão, Get-Command obtém somente os comandos que são executados quando você digita o nome do comando.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In the following examples, the session includes a Get-Date function and a Get-Date cmdlet.</source>
          <target state="translated">Nos exemplos a seguir, a sessão inclui uma função de Get-Date e um cmdlet Get-Date.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following command gets the Get-Date command that runs when you type "Get-Date".</source>
          <target state="translated">O comando a seguir obtém o comando Get-Date que é executado quando você digitar "Get data".</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-Command Get-Date</source>
          <target state="translated">PS C: &gt; Get-Command Get-Date</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>CommandType     Name                                               ModuleName</source>
          <target state="translated">ModuleName Nome CommandType</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Function        get-date</source>
          <target state="translated">Função get-date</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The following command uses the All parameter to get all Get-Date commands.</source>
          <target state="translated">O comando a seguir usa o parâmetro All para obter todos os comandos Get-Date.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-Command Get-Date -All</source>
          <target state="translated">PS C: &gt; Get-Command Get-Date-todos</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>CommandType     Name                                               ModuleName</source>
          <target state="translated">ModuleName Nome CommandType</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Function        get-date Cmdlet          Get-Date                                           Microsoft.PowerShell.Utility</source>
          <target state="translated">Função get-date Cmdlet Get-Date Microsoft.PowerShell.Utility</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>RUNNING HIDDEN COMMANDS</source>
          <target state="translated">EXECUTANDO COMANDOS OCULTOS</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can run particular commands by specifying item properties that distinguish the command from other commands that might have the same name.</source>
          <target state="translated">Você pode executar determinados comandos especificando propriedades de item que distinguem o comando de outros comandos que podem ter o mesmo nome.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You can use this method to run any command, but it is especially useful for running hidden commands.</source>
          <target state="translated">Você pode usar esse método para executar qualquer comando, mas é especialmente útil para executar comandos ocultos.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Use this method as a best practice when writing scripts that you intend to distribute because you cannot predict which commands might be present in the session in which the script runs.</source>
          <target state="translated">Use esse método como uma prática recomendada ao escrever scripts que você pretende distribuir porque você não pode prever quais comandos podem estar presentes na sessão na qual o script é executado.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>QUALIFIED NAMES</source>
          <target state="translated">NOMES QUALIFICADOS</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can run commands that have been imported from a Windows PowerShell snap-in or module or from another session by qualifying the command name with the name of the module or snap-in in which it originated.</source>
          <target state="translated">Você pode executar comandos que foram importados de um snap-in do Windows PowerShell ou o módulo ou de outra sessão qualificando o nome de comando com o nome do módulo ou snap-in na qual ele se originou.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You can qualify commands, but you cannot qualify variables or aliases.</source>
          <target state="translated">Você pode qualificar comandos, mas você não pode qualificar variáveis ou aliases.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For example, if the Get-Date cmdlet from the Microsoft.PowerShell.Utility snap-in is hidden by an alias, function, or cmdlet with the same name, you can run it by using the snap-in-qualified name of the cmdlet:</source>
          <target state="translated">Por exemplo, se o cmdlet Get-Date no snap-in Microsoft.PowerShell.Utility está oculto por um alias, a função ou o cmdlet com o mesmo nome, você pode executá-lo usando o nome snap em qualificado do cmdlet:</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Microsoft.PowerShell.Utility\Get-Date</source>
          <target state="translated">Microsoft.PowerShell.Utility\Get-Date</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To run a New-Map command that was added by the MapFunctions module, use its module-qualified name:</source>
          <target state="translated">Para executar um comando de novo mapa foi adicionado pelo módulo MapFunctions, use o nome qualificado de módulo:</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>MapFunctions\New-Map</source>
          <target state="translated">Mapa MapFunctions\New</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To find the snap-in or module from which a command was imported, use the ModuleName property of commands.</source>
          <target state="translated">Para localizar o snap-in ou módulo do que um comando foi importado, use a propriedade ModuleName de comandos.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>(Get-Command &lt;command-name&gt;).ModuleName</source>
          <target state="translated">(Get-Command &lt; nome do comando &gt;). ModuleName</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, to find the source of the Get-Date cmdlet, type:</source>
          <target state="translated">Por exemplo, para localizar a origem do cmdlet Get-Date, digite:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>PS C:&gt;(Get-Command Get-Date).ModuleName Microsoft.PowerShell.Utility</source>
          <target state="translated">PS c &gt; (Get-Command Get-Date). Módulo Microsoft.PowerShell.Utility</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>CALL OPERATOR</source>
          <target state="translated">OPERADOR DE CHAMADA</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can also use the Call operator (&amp;) to run any command that you can get by using a Get-ChildItem (the alias is "dir"), Get-Command, or Get-Module command.</source>
          <target state="translated">Você também pode usar o operador de chamada (&amp;) para executar qualquer comando que você pode obter usando um Get-ChildItem (o alias é "dir"), Get-Command ou Get-Module comando.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>To run a command, enclose the Get-Command command in parentheses, and use the Call operator (&amp;) to run the command.</source>
          <target state="translated">Para executar um comando, coloque o comando Get-Command entre parênteses e usar o operador de chamada (&amp;) para executar o comando.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>&amp;(Get-Command ...)</source>
          <target state="translated">&amp; (get-Command...)</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>or -</source>
          <target state="translated">ou -</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>&amp;(dir ... )</source>
          <target state="translated">&amp;(DIR...)</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For example, if you have a function named Map that is hidden by an alias named Map, use the following command to run the function.</source>
          <target state="translated">Por exemplo, se você tiver uma função chamada mapa que está oculto por um alias chamado mapa, use o seguinte comando para executar a função.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>&amp;(Get-Command -Name Map -Type function)</source>
          <target state="translated">&amp; (get-Command - mapa de nome-tipo de função)</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>or -</source>
          <target state="translated">ou -</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>&amp;(dir function:\map)</source>
          <target state="translated">&amp; (função dir: \map)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can also save your hidden command in a variable to make it easier to run.</source>
          <target state="translated">Você também pode salvar seu comando oculto em uma variável para facilitar a execução.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>For example, the following command saves the Map function in the $myMap variable and then uses the Call operator to run it.</source>
          <target state="translated">Por exemplo, o comando a seguir salva a função de mapa na variável $myMap e, em seguida, usa o operador de chamada para executá-lo.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>$myMap = (Get-Command -Name map -Type function)</source>
          <target state="translated">$myMap = (get-Command - nome do tipo função - map)</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>&amp;($myMap)</source>
          <target state="translated">&amp;($myMap)</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If a command originated in a module, you can use the following format to run it.</source>
          <target state="translated">Se um comando foi originado em um módulo, você pode usar o seguinte formato para executá-lo.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>&amp; &lt;PSModuleInfo-object&gt;</source>
          <target state="translated">&amp; &lt; objeto PSModuleInfo &gt;</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For example, to run the Add-File cmdlet in the FileCommands module, use the following command sequence.</source>
          <target state="translated">Por exemplo, para executar o cmdlet Add File no módulo FileCommands, use a seguinte sequência de comando.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>$FileCommands = get-module -name FileCommands</source>
          <target state="translated">$FileCommands = get-module-nome FileCommands</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>&amp; $FileCommands Add-File</source>
          <target state="translated">&amp; Adicionar $FileCommands-arquivo</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>REPLACED ITEMS</source>
          <target state="translated">SUBSTITUÍDO ITENS</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Items that have not been imported from a module or snap-in, such as functions, variables, and aliases that you create in your session or that you add by using a profile can be replaced by commands that have the same name.</source>
          <target state="translated">Itens que não foram importados de um módulo ou snap-in, como funções, variáveis e aliases criado na sessão ou adicionar usando um perfil podem ser substituídos por comandos que têm o mesmo nome.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>If they are replaced, you cannot access them.</source>
          <target state="translated">Se eles forem substituídos, você não pode acessá-los.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Variables and aliases are always replaced even if they have been imported from a module or snap-in because you cannot use a call operator or a qualified name to run them.</source>
          <target state="translated">Variáveis e aliases sempre são substituídos mesmo se eles foram importados de um módulo ou snap-in porque você não pode usar um operador de chamada ou um nome qualificado para executá-las.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, if you type a Get-Map function in your session, and you import a function called Get-Map, the original function is replaced.</source>
          <target state="translated">Por exemplo, se você digita uma função de Get-mapa em sua sessão e importar uma função chamada Get-mapa, a função original será substituída.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You cannot retrieve it in the current session.</source>
          <target state="translated">Você não pode recuperá-la na sessão atual.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>AVOIDING NAME CONFLICTS</source>
          <target state="translated">EVITANDO CONFLITOS DE NOME</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The best way to manage command name conflicts is to prevent them.</source>
          <target state="translated">A melhor maneira de gerenciar conflitos de nome do comando é impedi-los.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>When you name your commands, use a name that is very specific or is likely to be unique.</source>
          <target state="translated">Ao nomear seus comandos, use um nome que é muito específico ou deve ser exclusivo.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>For example, add your initials or company name acronym to the nouns in your commands.</source>
          <target state="translated">Por exemplo, adicione iniciais ou o acrônimo de nome da empresa aos substantivos nos seus comandos.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Also, when you import commands into your session from a Windows PowerShell module or from another session, use the Prefix parameter of the Import-Module or Import-PSSession cmdlet to add a prefix to the nouns in the names of commands.</source>
          <target state="translated">Além disso, quando você importa comandos para a sessão de um módulo do Windows PowerShell ou de outra sessão, use o parâmetro de prefixo do cmdlet Import-Module ou Import-PSSession para adicionar um prefixo aos substantivos nos nomes dos comandos.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For example, the following command avoids any conflict with the Get-Date and Set-Date cmdlets that come with Windows PowerShell when you import the DateFunctions module.</source>
          <target state="translated">Por exemplo, o comando a seguir evita qualquer conflito com os cmdlets Get-Date e Set-Date que vêm com o Windows PowerShell quando importar o módulo DateFunctions.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Import-Module -Name DateFunctions -Prefix ZZ</source>
          <target state="translated">Import-Module-nome DateFunctions-prefixo ZZ</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For more information, see Import-Module and Import-PSSession.</source>
          <target state="translated">Para obter mais informações, consulte Import-Module e Import-PSSession.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">CONSULTE TAMBÉM</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>about_Path_Syntax about_Aliases about_Functions Alias (provider) Function (provider) Get-Command Import-Module Import-PSSession</source>
          <target state="translated">about_Path_Syntax about_Aliases about_Functions Alias (provedor) função Get-Command Import-Module Import-PSSession (provedor)</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>