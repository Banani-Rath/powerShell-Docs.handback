<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b91e3bbb40b2b5eddd1e43be568773c850a9b8e0</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-2072b6e" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>New language features in PowerShell 5.0</source>
          <target state="translated">Novos recursos de linguagem no PowerShell 5.0</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>PowerShell 5.0 introduces the following new language elements in Windows PowerShell:</source>
          <target state="translated">O PowerShell 5.0 introduz os seguintes novos elementos de linguagem no Windows PowerShell:</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Class keyword</source>
          <target state="translated">Palavra-chave class</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>class<ept id="p1">**</ept> keyword defines a new class.</source>
          <target state="translated">A palavra-chave <bpt id="p1">**</bpt>class<ept id="p1">**</ept> define uma nova classe.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This is a true .NET Framework type.</source>
          <target state="translated">Este é um tipo real do .NET Framework.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Class members are public, but only public within the module scope.</source>
          <target state="translated">Membros de classe são públicos, mas somente públicos dentro do escopo do módulo.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can't refer to the type name as a string (for example, <ph id="ph1">`New-Object`</ph> doesn't work), and in this release, you can't use a type literal (for example, <ph id="ph2">`[MyClass]`</ph>) outside the script/module file in which the class is defined.</source>
          <target state="translated">Não é possível se referir ao nome de tipo como uma cadeia de caracteres (por exemplo, <ph id="ph1">`New-Object`</ph> não funciona), e nesta versão, não é possível usar um literal de tipo (por exemplo, <ph id="ph2">`[MyClass]`</ph>) fora do arquivo de script/módulo no qual a classe é definida.</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Enum keyword and enumerations</source>
          <target state="translated">Palavra-chave Enum e enumerações</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Support for the <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> keyword has been added, which uses newline as the delimiter.</source>
          <target state="translated">O suporte à palavra-chave <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> for adicionado, que usa uma nova linha como o delimitador.</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Current limitations: you cannot define an enumerator in terms of itself, but you can initialize an enum in terms of another enum, as shown in the following example.</source>
          <target state="translated">Limitações atuais: não é possível definir um enumerador em relação a si mesmo, mas é possível inicializar um enum em relação a outro enum, conforme mostrado no exemplo a seguir.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Also, the base type cannot currently be specified; it is always [int].</source>
          <target state="translated">Além disso, atualmente, o tipo base não pode ser especificado; ele é sempre [int].</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>An enumerator value must be a parse time constant; you cannot set it to the result of an invoked command.</source>
          <target state="translated">Um valor do enumerador deve ser uma constante de tempo de análise; não é possível defini-lo como o resultado de um comando invocado.</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Enums support arithmetic operations, as shown in the following example.</source>
          <target state="translated">Enums dão suporte a operações aritméticas, conforme mostrado no exemplo a seguir.</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Import-DscResource</source>
          <target state="translated">Import-DscResource</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Import-DscResource<ept id="p1">**</ept> is now a true dynamic keyword.</source>
          <target state="translated"><bpt id="p1">**</bpt>Import-DscResource<ept id="p1">**</ept> agora é uma palavra-chave dinâmica real.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>PowerShell parses the specified module’s root module, searching for classes that contain the <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> attribute.</source>
          <target state="translated">O PowerShell analisa o módulo raiz do módulo especificado, pesquisando classes que contêm o atributo <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>ImplementingAssembly</source>
          <target state="translated">ImplementingAssembly</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A new field, <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept>, has been added to ModuleInfo.</source>
          <target state="translated">Um novo campo, <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept>, foi adicionado a ModuleInfo.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>It is set to the dynamic assembly created for a script module if the script defines classes, or the loaded assembly for binary modules.</source>
          <target state="translated">Ele é definido como o assembly dinâmico criado para um módulo de script, caso o script defina classes, ou como o assembly carregado para módulos binários.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It is not set when ModuleType = Manifest.</source>
          <target state="translated">Ele não é definido quando ModuleType = Manifest.</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Reflection on the <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept> field discovers resources in a module.</source>
          <target state="translated">A reflexão sobre o campo <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept> descobre recursos em um módulo.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This means you can discover resources written in either PowerShell or other managed languages.</source>
          <target state="translated">Isso significa que é possível descobrir recursos escritos no PowerShell ou em outras linguagens gerenciadas.</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Fields with initializers:</source>
          <target state="translated">Campos com inicializadores:</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Static is supported; it works like an attribute, as do the type constraints, so it can be specified in any order.</source>
          <target state="translated">Há suporte para static; ele funciona como um atributo, assim como as restrições de tipo; portanto, pode ser especificado em qualquer ordem.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A type is optional.</source>
          <target state="translated">Um tipo é opcional.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>All members are public.</source>
          <target state="translated">Todos os membros são públicos.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Constructors and instantiation</source>
          <target state="translated">Construtores e instanciação</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Windows PowerShell classes can have constructors; they have the same name as their class.</source>
          <target state="translated">As classes do Windows PowerShell podem ter construtores; eles têm o mesmo nome que a classe.</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Constructors can be overloaded.</source>
          <target state="translated">Os construtores podem ser sobrecarregados.</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Static constructors are supported.</source>
          <target state="translated">Há suporte para construtores estáticos.</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Properties with initialization expressions are initialized before running any code in a constructor.</source>
          <target state="translated">As propriedades com expressões de inicialização são inicializadas antes da execução de qualquer código em um construtor.</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Static properties are initialized before the body of a static constructor, and instance properties are initialized before the body of the non-static constructor.</source>
          <target state="translated">As propriedades estáticas são inicializadas antes do corpo de um construtor estático, e as propriedades de instância são inicializadas antes do corpo do construtor não estático.</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Currently, there is no syntax for calling a constructor from another constructor (like the C\# syntax ": this()").</source>
          <target state="translated">Atualmente, não há nenhuma sintaxe para chamar um construtor de outro construtor (como a sintaxe do C\# ": this()").</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The workaround is to define a common Init method.</source>
          <target state="translated">A solução alternativa é definir um método comum de Init.</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following are ways of instantiating classes in this release.</source>
          <target state="translated">Veja a seguir as maneiras de criar uma instância de classes nesta versão.</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Instantiating by using the default constructor.</source>
          <target state="translated">Criando uma instância usando o construtor padrão.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note that New-Object is not supported in this release.</source>
          <target state="translated">Observe que não há suporte para New-Object nesta versão.</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Calling a constructor with a parameter</source>
          <target state="translated">Chamando um construtor com um parâmetro</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Passing an array to a constructor with multiple parameters</source>
          <target state="translated">Passando uma matriz para um construtor com vários parâmetros</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In this release, New-Object does not work with classes defined in Windows PowerShell.</source>
          <target state="translated">Nesta versão, New-Object não funciona com classes definidas no Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Also for this release, the type name is only visible lexically, meaning it is not visible outside of the module or script that defines the class.</source>
          <target state="translated">Além disso, nesta versão, o nome de tipo é visível apenas lexicalmente, o que significa que ele não é visível fora do módulo ou do script que define a classe.</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Functions can return instances of a class defined in Windows PowerShell, and instances work well outside of the module or script.</source>
          <target state="translated">As funções podem retornar instâncias de uma classe definida no Windows PowerShell, e as instâncias funcionam bem fora do módulo ou do script.</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>lists constructors, so you can view overloads like any other method.</source>
          <target state="translated">lista os construtores, para que você possa exibir sobrecargas como qualquer outro método.</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The performance of this syntax is also considerably faster than New-Object.</source>
          <target state="translated">O desempenho dessa sintaxe também é consideravelmente mais rápido do que o de New-Object.</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The pseudo-static method named <bpt id="p1">**</bpt>new<ept id="p1">**</ept> works with .NET types, as shown in the following example.</source>
          <target state="translated">O método pseudoestático chamado <bpt id="p1">**</bpt>new<ept id="p1">**</ept> funciona com tipos do .NET, conforme mostrado no exemplo a seguir.</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can now see constructor overloads with Get-Member, or as shown in this example:</source>
          <target state="translated">Agora você pode ver as sobrecargas do construtor com Get-Member, ou conforme mostrado neste exemplo:</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Métodos</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A Windows PowerShell class method is implemented as a ScriptBlock that has only an end block.</source>
          <target state="translated">Um método de classe do Windows PowerShell é implementado como um ScriptBlock que tem apenas um end block.</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>All methods are public.</source>
          <target state="translated">Todos os métodos são públicos.</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following shows an example of defining a method named <bpt id="p1">**</bpt>DoSomething<ept id="p1">**</ept></source>
          <target state="translated">A seguir, um exemplo de como definir um método chamado <bpt id="p1">**</bpt>DoSomething<ept id="p1">**</ept></target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Method invocation:</source>
          <target state="translated">Invocação de método:</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Overloaded methods--that is, those that are named the same as an existing method, but differentiated by their specified values--are also supported.</source>
          <target state="translated">Também há suporte para métodos sobrecarregados – ou seja, aqueles que têm o mesmo nome que um método existente, mas que são diferenciados por seus valores especificados.</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Propriedades</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>All properties are public.</source>
          <target state="translated">Todas as propriedades são públicas.</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Properties require either a newline or semicolon.</source>
          <target state="translated">As propriedades exigem uma nova linha ou um ponto-e-vírgula.</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If no object type is specified, the property type is object.</source>
          <target state="translated">Se nenhum tipo de objeto for especificado, o tipo de propriedade será o objeto.</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Properties that use validation attributes or argument transformation attributes (e.g. <ph id="ph1">`[ValidateSet("aaa")]`</ph>) work as expected.</source>
          <target state="translated">As propriedades que usam atributos de validação ou atributos de transformação de argumento (por exemplo, <ph id="ph1">`[ValidateSet("aaa")]`</ph>) funcionam como esperado.</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Hidden</source>
          <target state="translated">Hidden</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A new keyword, <bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept>, has been added.</source>
          <target state="translated">Uma nova palavra-chave, <bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept>, foi adicionada.</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept> can be applied to properties and methods (including constructors).</source>
          <target state="translated"><bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept> pode ser aplicado a propriedades e métodos (incluindo construtores).</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Hidden members are public, but do not appear in the output of Get-Member unless the -Force parameter is added.</source>
          <target state="translated">Membros ocultos são públicos, mas não aparecem na saída de Get-Member, a menos que o parâmetro -Force seja adicionado.</target>         
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Hidden members are not included when tab completing or using Intellisense unless the completion occurs in the class defining the hidden member.</source>
          <target state="translated">Membros ocultos não são incluídos durante o preenchimento de tabulação ou uso do IntelliSense, a menos que o preenchimento ocorra na classe que define o membro oculto.</target>         
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A new attribute, <bpt id="p1">**</bpt>System.Management.Automation.HiddenAttribute<ept id="p1">**</ept> has been added so that C# code can have the same semantics within Windows PowerShell.</source>
          <target state="translated">Um novo atributo, <bpt id="p1">**</bpt>System.Management.Automation.HiddenAttribute<ept id="p1">**</ept>, foi adicionado, para que o código do C# possa ter a mesma semântica dentro do Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Return types</source>
          <target state="translated">Tipos de retorno</target>         
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Return type is a contract; the return value is converted to the expected type.</source>
          <target state="translated">O tipo de retorno é um contrato; o valor retornado é convertido para o tipo esperado.</target>         
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If no return type is specified, the return type is void.</source>
          <target state="translated">Se nenhum tipo de retorno for especificado, o tipo de retorno será nulo.</target>         
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>There is no streaming of objects; objects cannot be written to the pipeline either intentionally or by accident.</source>
          <target state="translated">Não há nenhum streaming de objetos; os objetos não podem ser gravados no pipeline, seja intencionalmente ou por engano.</target>         
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Atributos</target>         
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Two new attributes, <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> and <bpt id="p2">**</bpt>DscProperty<ept id="p2">**</ept> have been added.</source>
          <target state="translated">Dois novos atributos, <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> e <bpt id="p2">**</bpt>DscProperty<ept id="p2">**</ept> foram adicionados.</target>         
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Lexical scoping of variables</source>
          <target state="translated">Escopo léxico de variáveis</target>         
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The following shows an example of how lexical scoping works in this release.</source>
          <target state="translated">Apresentamos a seguir um exemplo de como o escopo léxico funciona nesta versão.</target>         
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>End-to-End Example</source>
          <target state="translated">Exemplo de ponta a ponta</target>         
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The following example creates several new, custom classes to implement an HTML dynamic style sheet language (DSL).</source>
          <target state="translated">O exemplo a seguir cria várias classes novas e personalizadas para implementar uma DSL (linguagem de folha de estilos dinâmica) em HTML.</target>         
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Then, the example adds helper functions to create specific element types as part of the element class, such as heading styles and tables, because types cannot be used outside the scope of a module.</source>
          <target state="translated">Em seguida, o exemplo adiciona funções auxiliares para criar tipos específicos de elementos como parte da classe de elemento, como estilos de título e tabelas, já que os tipos não podem ser usados fora do escopo de um módulo.</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>