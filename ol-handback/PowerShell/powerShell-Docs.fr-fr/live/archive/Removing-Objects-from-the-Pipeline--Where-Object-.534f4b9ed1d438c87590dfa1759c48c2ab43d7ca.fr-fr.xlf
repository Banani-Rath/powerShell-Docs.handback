<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ba19c46bed78498fb708014228488ab7dedc10dc</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04046aa" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Removing Objects from the Pipeline (Where-Object)</source>
          <target state="translated">Suppression d’objets du pipeline (Where-Object)</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Removing Objects from the Pipeline (Where-Object)</source>
          <target state="translated">Suppression d’objets du pipeline (Where-Object)</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, you often generate and pass along more objects to a pipeline than you want.</source>
          <target state="translated">Dans Windows PowerShell, vous générez et transmettez souvent à un pipeline plus d’objets que souhaité.</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>You can specify the properties of particular objects to display by using the <bpt id="p1">**</bpt>Format<ept id="p1">**</ept> cmdlets, but this does not help with the problem of removing entire objects from the display.</source>
          <target state="translated">Vous pouvez spécifier les propriétés d’objets particuliers à afficher à l’aide des applets de commande <bpt id="p1">**</bpt>Format<ept id="p1">**</ept>, mais cela ne résout pas le problème de la suppression d’objets entiers de l’affichage.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You may want to filter objects before the end of a pipeline, so you can perform actions on only a subset of the initially\-generated objects.</source>
          <target state="translated">Il se peut que vous souhaitiez filtrer des objets avant la fin d’un pipeline afin de pouvoir effectuer des actions uniquement sur un sous-ensemble des objets générés initialement.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Windows PowerShell includes a <bpt id="p1">**</bpt>Where\-Object<ept id="p1">**</ept> cmdlet that allows you to test each object in the pipeline and only pass it along the pipeline if it meets a particular test condition.</source>
          <target state="translated">Windows PowerShell inclut une applet de commande <bpt id="p1">**</bpt>Where-Object<ept id="p1">**</ept> qui permet de tester chaque objet dans le pipeline et de le transmettre dans le pipeline uniquement s’il répond à une condition de test particulière.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Objects that do not pass the test are removed from the pipeline.</source>
          <target state="translated">Les objets qui ne passent pas le test sont supprimés du pipeline.</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You supply the test condition as the value of the <bpt id="p1">**</bpt>Where\-ObjectFilterScript<ept id="p1">**</ept> parameter.</source>
          <target state="translated">Vous fournissez la condition de test en tant que la valeur du paramètre <bpt id="p1">**</bpt>Where-ObjectFilterScript<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Performing Simple Tests with Where\-Object</source>
          <target state="translated">Exécution de tests simples avec l’applet de commande Where-objet</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">**</bpt>FilterScript<ept id="p1">**</ept> is a <bpt id="p2">*</bpt>script block<ept id="p2">*</ept> \-  one or more Windows PowerShell commands surrounded by braces {} \- that evaluates to true or false.</source>
          <target state="translated">La valeur de <bpt id="p1">**</bpt>FilterScript<ept id="p1">**</ept> est un <bpt id="p2">*</bpt>bloc de script<ept id="p2">*</ept> (une ou plusieurs commandes Windows PowerShell entourées d’accolades {}) qui prend la valeur true ou false.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>These script blocks can be very simple, but creating them requires knowing about another Windows PowerShell concept, comparison operators.</source>
          <target state="translated">Un tel bloc de script peut être très simple, mais sa création nécessite de connaître un autre concept de Windows PowerShell, à savoir l’opérateur de comparaison.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A comparison operator compares the items that appear on each side of it.</source>
          <target state="translated">Un opérateur de comparaison compare les éléments figurant de part et d’autre de celui-ci.</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Comparison operators begin with a '\-' character and are followed by a name.</source>
          <target state="translated">Un opérateur de comparaison commence par un caractère « - » suivi d’un nom.</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Basic comparison operators work on almost any kind of object.</source>
          <target state="translated">Les opérateurs de comparaison de base fonctionnent sur pratiquement tout type d’objet.</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The more advanced comparison operators might only work on text or arrays.</source>
          <target state="translated">Certains opérateurs de comparaison plus avancés fonctionnent uniquement sur du texte ou des tableaux.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>By default, when working with text, Windows PowerShell comparison operators are case\-insensitive.</source>
          <target state="translated">Par défaut, lorsque vous travaillez sur du texte, les opérateurs de comparaison de Windows PowerShell ne respectent pas la casse.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Due to parsing considerations, symbols such as &lt;,&gt;, and \= are not used as comparison operators.</source>
          <target state="translated">En raison de considérations liées à l’analyse, des symboles tels que &lt;, &gt;, et = ne sont pas utilisés comme opérateurs de comparaison.</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Instead, comparison operators are comprised of letters.</source>
          <target state="translated">Au lieu de cela, les opérateurs de comparaison sont constitués de lettres.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The basic comparison operators are listed in the following table.</source>
          <target state="translated">Les opérateurs de comparaison de base sont répertoriés dans le tableau suivant.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Comparison Operator</source>
          <target state="translated">Opérateur de comparaison</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Signification</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Example (returns true)</source>
          <target state="translated">Exemple (retourne true)</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>\-eq</source>
          <target state="translated">-eq</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>is equal to</source>
          <target state="translated">Est égal à</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>1 \-eq 1</source>
          <target state="translated">1 -eq 1</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>\-ne</source>
          <target state="translated">-ne</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Is not equal to</source>
          <target state="translated">N’est pas égal à</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>1 \-ne 2</source>
          <target state="translated">1 -ne 2</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>\-lt</source>
          <target state="translated">-lt</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Is less than</source>
          <target state="translated">Est inférieur à</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>1 \-lt 2</source>
          <target state="translated">1 -lt 2</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>\-le</source>
          <target state="translated">-le</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Is less than or equal to</source>
          <target state="translated">Est inférieur ou égal à</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>1 \-le 2</source>
          <target state="translated">1 -le 2</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>\-gt</source>
          <target state="translated">-gt</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Is greater than</source>
          <target state="translated">Est supérieur à</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>2 \-gt 1</source>
          <target state="translated">2 -gt 1</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>\-ge</source>
          <target state="translated">-ge</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Is greater than or equal to</source>
          <target state="translated">Est supérieur ou égal à</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>2 \-ge 1</source>
          <target state="translated">2 -ge 1</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>\-like</source>
          <target state="translated">-like</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Is like (wildcard comparison for text)</source>
          <target state="translated">Est comme (comparaison générique pour le texte)</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>"file.doc" \-like "f\*.do?"</source>
          <target state="translated">"file.doc" -like "f*.do?"</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>\-notlike</source>
          <target state="translated">-notlike</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Is not like (wildcard comparison for text)</source>
          <target state="translated">N’est pas comme (comparaison générique pour le texte)</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>"file.doc" \-notlike "p\*.doc"</source>
          <target state="translated">"file.doc" -notlike "p*.doc"</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>\-contains</source>
          <target state="translated">-contains</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="translated">Contient</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>1,2,3 \-contains 1</source>
          <target state="translated">1,2,3 -contains 1</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>\-notcontains</source>
          <target state="translated">-notcontains</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Does not contain</source>
          <target state="translated">Ne contient pas</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>1,2,3 \-notcontains 4</source>
          <target state="translated">1,2,3 -notcontains 4</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Where\-Object script blocks use the special variable '$\_' to refer to the current object in the pipeline.</source>
          <target state="translated">Les blocs de script Where-Object utilisent la variable spéciale « $_ » pour faire référence à l’objet actuel dans le pipeline.</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Here is an example of how it works.</source>
          <target state="translated">Voici un exemple de son fonctionnement.</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you have a list of numbers, and only want to return the ones that are less than 3, you can use Where\-Object to filter the numbers by typing:</source>
          <target state="translated">Si vous avez une liste de nombres et souhaitez retourner uniquement ceux dont la valeur est inférieure à 3, vous pouvez utiliser l’applet de commande Where-Object pour filtrer les nombres en tapant ce qui suit :</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Filtering Based on Object Properties</source>
          <target state="translated">Filtrage basé sur les propriétés de l’objet</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Since $\_ refers to the current pipeline object, we can access its properties for our tests.</source>
          <target state="translated">Comme $_ fait référence à l’objet de pipeline actif, nous pouvons accéder à ses propriétés pour nos tests.</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>As an example, we can look at the Win32\_SystemDriver class in WMI.</source>
          <target state="translated">Par exemple, nous pouvons examiner la classe Win32_SystemDriver dans WMI.</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>There might be hundreds of system drivers on a particular system, but you might only be interested in a particular set of the system drivers, such as those which are currently running.</source>
          <target state="translated">Il peut y avoir des centaines de pilotes système sur un système particulier, mais il se peut que vous vous intéressiez uniquement à certains pilotes, par exemple, à ceux qui sont en cours d’exécution.</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If you use Get\-Member to view Win32\_SystemDriver members (<bpt id="p1">**</bpt>Get\-WmiObject \-Class Win32\_SystemDriver | Get\-Member \-MemberType Property<ept id="p1">**</ept>) you will see that the relevant property is State, and that it has a value of "Running" when the driver is running.</source>
          <target state="translated">Si vous utilisez l’applet de commande Get-Member pour afficher les membres de Win32_SystemDriver (<bpt id="p1">**</bpt>Get-WmiObject -Class Win32_SystemDriver | Get-Member -MemberType Property<ept id="p1">**</ept>), vous constatez que la propriété pertinente est State, et qu’elle a la valeur « Running » quand le pilote est en cours d’exécution.</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can filter the system drivers, selecting only the running ones by typing:</source>
          <target state="translated">Vous pouvez filtrer les pilotes du système afin de sélectionner uniquement ceux qui sont en cours d’exécution, en tapant ce qui suit :</target>         
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This still produces a long list.</source>
          <target state="translated">Cela génère toujours une longue liste.</target>         
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You may want to filter to only select the drivers set to start automatically by testing the StartMode value as well:</source>
          <target state="translated">Il se peut que vouliez filtrer afin de sélectionner uniquement les pilotes configurés pour démarrer automatiquement, en testant également la valeur StartMode :</target>         
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This gives us a lot of information we no longer need because we know that the drivers are running.</source>
          <target state="translated">Cela produit un grand nombre d’informations dont nous n’avons plus besoin, car nous savons que les pilotes sont en cours d’exécution.</target>         
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In fact, the only information we probably need at this point are the name and the display name.</source>
          <target state="translated">En fait, les seules informations dont nous ayons probablement besoin à ce stade sont le nom et le nom d’affichage.</target>         
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The following command includes only those two properties, resulting in much simpler output:</source>
          <target state="translated">La commande suivante inclut uniquement ces deux propriétés, de sorte que la sortie est beaucoup plus simple :</target>         
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>There are two Where\-Object elements in the above command, but they can be expressed in a single Where\-Object element by using the \-and logical operator, like this:</source>
          <target state="translated">Il existe deux éléments Where-Object dans la commande ci-dessus, mais ils peuvent être exprimés en un seul élément Where-Object à l’aide de l’opérateur logique -and comme suit :</target>         
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The standard logical operators are listed in the following table.</source>
          <target state="translated">Les opérateurs logiques standards sont répertoriés dans le tableau suivant.</target>         
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Logical Operator</source>
          <target state="translated">Opérateur logique</target>         
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Signification</target>         
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Example (returns true)</source>
          <target state="translated">Exemple (retourne true)</target>         
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>\-and</source>
          <target state="translated">-and</target>         
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Logical and; true if both sides are true</source>
          <target state="translated">Opérateur logique et ; true si les deux côtés sont vrais</target>         
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>(1 \-eq 1) \-and (2 \-eq 2)</source>
          <target state="translated">(1 -eq 1) -and (2 -eq 2)</target>         
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>\-or</source>
          <target state="translated">-or</target>         
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Logical or; true if either side is true</source>
          <target state="translated">Opérateur logique ou ; true si l’un des côtés est vrai</target>         
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>(1 \-eq 1) \-or (1 \-eq 2)</source>
          <target state="translated">(1 -eq 1) -or (1 -eq 2)</target>         
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>\-not</source>
          <target state="translated">-not</target>         
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Logical not; reverses true and false</source>
          <target state="translated">Opérateur logique non ; inverse les valeurs true et false</target>         
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>\-not (1 \-eq 2)</source>
          <target state="translated">-not (1 -eq 2)</target>         
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Logical not; reverses true and false</source>
          <target state="translated">Opérateur logique non ; inverse les valeurs true et false</target>         
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>\!(1 \-eq 2)</source>
          <target state="translated">!(1 -eq 2)</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>