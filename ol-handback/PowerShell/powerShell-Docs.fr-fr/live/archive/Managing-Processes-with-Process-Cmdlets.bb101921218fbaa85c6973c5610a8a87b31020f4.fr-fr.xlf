<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">719e3da3a26f2e3f6b049fec30d543f7bccf8d34</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04046aa" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Managing Processes with Process Cmdlets</source>
          <target state="translated">Gestion des processus avec les applets de commande Process</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Managing Processes with Process Cmdlets</source>
          <target state="translated">Gestion des processus avec les applets de commande Process</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>You can use the Process cmdlets in Windows PowerShell to manage local and remote processes in Windows PowerShell.</source>
          <target state="translated">Les applets de commande Process de Windows PowerShell permettent de gérer des processus locaux et distants dans Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Getting Processes (Get\-Process)</source>
          <target state="translated">Obtention de processus (Get-Process)</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>To get the processes running on the local computer, run a <bpt id="p1">**</bpt>Get\-Process<ept id="p1">**</ept> with no parameters.</source>
          <target state="translated">Pour obtenir les processus en cours d’exécution sur l’ordinateur local, exécutez l’applet de commande <bpt id="p1">**</bpt>Get-Process<ept id="p1">**</ept> sans paramètres.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You can get particular processes by specifying their process names or process IDs.</source>
          <target state="translated">Vous pouvez obtenir des processus particuliers en spécifiant leur nom ou leur ID.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The following command gets the Idle process:</source>
          <target state="translated">La commande suivante obtient le processus Idle :</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Although it is normal for cmdlets to return no data in some situations, when you specify a process by its ProcessId, <bpt id="p1">**</bpt>Get\-Process<ept id="p1">**</ept> generates an error if it finds no matches, because the usual intent is to retrieve a known running process.</source>
          <target state="translated">S’il est normal que des applets de commande ne retournent aucune donnée dans certaines situations, lorsque vous spécifiez un processus par son ID, l’applet de commande <bpt id="p1">**</bpt>Get-Process<ept id="p1">**</ept> génère une erreur si elle ne trouve aucune correspondance, car l’objectif consiste généralement à récupérer un processus en cours d’exécution connu.</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If there is no process with that Id, it is likely that the Id is incorrect or that the process of interest has already exited:</source>
          <target state="translated">Si aucun processus ne correspond à cet ID, il est probable que celui-ci est incorrect ou que son exécution est déjà terminée :</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can use the Name parameter of the Get\-Process cmdlet to specify a subset of processes based on the process name.</source>
          <target state="translated">Vous pouvez utiliser le paramètre Name de l’applet de commande Get-Process pour spécifier une partie des processus en se basant sur le nom des processus.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The Name parameter can take multiple names in a comma\-separated list and it supports the use of wildcards, so you can type name patterns.</source>
          <target state="translated">Le paramètre Name peut prendre plusieurs noms dans une liste de valeurs séparées par des virgules. Comme il prend en charge l’utilisation de caractères génériques, vous pouvez entrer des modèles de noms.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>For example, the following command gets process whose names begin with "ex."</source>
          <target state="translated">Par exemple, la commande suivante obtient les processus dont les noms commencent par « ex ».</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Because the .NET System.Diagnostics.Process class is the foundation for Windows PowerShell processes, it follows some of the conventions used by System.Diagnostics.Process.</source>
          <target state="translated">Étant donné que la classe System.Diagnostics.Process de .NET constitue la base des processus Windows PowerShell, elle suit certaines des conventions utilisées par System.Diagnostics.Process.</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>One of those conventions is that the process name for an executable never includes the ".exe" at the end of the executable name.</source>
          <target state="translated">L’une de ces conventions est que le nom de processus d’un exécutable n’inclut jamais « .exe » à la fin du nom.</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Get\-Process<ept id="p1">**</ept> also accepts multiple values for the Name parameter.</source>
          <target state="translated">L’applet de commande <bpt id="p1">**</bpt>Get-Process<ept id="p1">**</ept> accepte également plusieurs valeurs pour le paramètre Name.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You can use the ComputerName parameter of Get\-Process to get processes on remote computers.</source>
          <target state="translated">Vous pouvez utiliser le paramètre ComputerName de l’applet de commande Get-Process pour obtenir des processus sur des ordinateurs distants.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the PowerShell processes on the local computer (represented by "localhost") and on two remote computers.</source>
          <target state="translated">Par exemple, la commande suivante obtient les processus PowerShell sur l’ordinateur local (représenté par « localhost ») et sur deux ordinateurs distants.</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The computer names are not evident in this display, but they are stored in the MachineName property of the process objects that Get\-Process returns.</source>
          <target state="translated">Les noms d’ordinateurs ne sont pas évidents dans cet affichage, mais ils sont stockés dans la propriété MachineName des objets de processus que l’applet de commande Get-Process retourne.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following command uses the Format\-Table cmdlet to display the process ID, ProcessName and MachineName (ComputerName) properties of the process objects.</source>
          <target state="translated">La commande suivante utilise l’applet de commande Format-Table pour afficher les propriétés d’ID de processus, ProcessName et MachineName (ComputerName) des objets de processus.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>This more complex command adds the MachineName property to the standard Get\-Process display.</source>
          <target state="translated">Cette commande plus complexe ajoute la propriété MachineName à l’affichage standard de l’applet de commande Get-Process.</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The backtick (\`)(ASCII 96) is the Windows PowerShell continuation character.</source>
          <target state="translated">L’accent grave (`)(ASCII 96) est le caractère de continuation de Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Stopping Processes (Stop\-Process)</source>
          <target state="translated">Arrêt des processus (Stop-Process)</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Windows PowerShell gives you flexibility for listing processes, but what about stopping a process?</source>
          <target state="translated">Windows PowerShell offre une flexibilité certaine pour l’affichage des processus, mais qu’en est-il de l’arrêt d’un processus ?</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Stop\-Process<ept id="p1">**</ept> cmdlet takes a Name or Id to specify a process you want to stop.</source>
          <target state="translated">L’applet de commande <bpt id="p1">**</bpt>Stop-Process<ept id="p1">**</ept> prend un nom ou un ID pour spécifier un processus à arrêter.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Your ability to stop processes depends on your permissions.</source>
          <target state="translated">Votre capacité à arrêter des processus dépend des autorisations dont vous disposez.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Some processes cannot be stopped.</source>
          <target state="translated">Certains processus ne peuvent pas être arrêtés.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>For example, if you try to stop the idle process, you get an error:</source>
          <target state="translated">Par exemple, si vous essayez d’arrêter le processus inactif, vous obtenez une erreur :</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You can also force prompting with the <bpt id="p1">**</bpt>Confirm<ept id="p1">**</ept> parameter.</source>
          <target state="translated">Vous pouvez également forcer l’affichage d’une invite avec le paramètre <bpt id="p1">**</bpt>Confirm<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This parameter is particularly useful if you use a wildcard when specifying the process name, because you may accidentally match some processes you do not want to stop:</source>
          <target state="translated">Ce paramètre est particulièrement utile si vous utilisez un caractère générique quand vous spécifiez le nom du processus, car vous pouvez accidentellement établir une correspondance avec des processus que vous ne souhaitez pas arrêter :</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Complex process manipulation is possible by using some of the object filtering cmdlets.</source>
          <target state="translated">Une manipulation de processus complexes est possible en utilisant certaines applets de commande de filtrage d’objet.</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Because a Process object has a Responding property that is true when it is no longer responding, you can stop all nonresponsive applications with the following command:</source>
          <target state="translated">Étant donné qu’un objet Process a une propriété Responding dont la valeur est true quand il ne répond plus, vous pouvez arrêter toutes les applications qui ne répondent pas avec la commande suivante :</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>You can use the same approach in other situations.</source>
          <target state="translated">Vous pouvez utiliser la même approche dans d’autres situations.</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For example, suppose a secondary notification area application automatically runs when users start another application.</source>
          <target state="translated">Par exemple, supposons qu’une application de zone de notification secondaire s’exécute automatiquement quand des utilisateurs démarrent une autre application.</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You may find that this does not work correctly in Terminal Services sessions, but you still want to keep it in sessions that run on the physical computer console.</source>
          <target state="translated">Il est possible que vous constatiez que cela ne fonctionne pas correctement dans les sessions des services Terminal Server, mais que vous souhaitiez conserver cette approche dans les sessions qui s’exécutent sur la console de l’ordinateur physique.</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Sessions connected to the physical computer desktop always have a session ID of 0, so you can stop all instances of the process that are in other sessions by using <bpt id="p1">**</bpt>Where\-Object<ept id="p1">**</ept> and the process, <bpt id="p2">**</bpt>SessionId<ept id="p2">**</ept>:</source>
          <target state="translated">Les sessions connectées au bureau de l’ordinateur physique ayant toujours un ID de session 0, vous pouvez arrêter toutes les instances du processus figurant dans d’autres sessions à l’aide de l’applet de commande <bpt id="p1">**</bpt>Where-Object<ept id="p1">**</ept> et du processus <bpt id="p2">**</bpt>SessionId<ept id="p2">**</ept> :</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The Stop\-Process cmdlet does not have a ComputerName parameter.</source>
          <target state="translated">L’applet de commande Stop-Process ne prend pas de paramètre ComputerName.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Therefore, to run a stop process command on a remote computer, you need to use the Invoke\-Command cmdlet.</source>
          <target state="translated">Par conséquent, pour exécuter une commande d’arrêt de processus sur un ordinateur distant, vous devez utiliser l’applet de commande Invoke-Command.</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For example, to stop the PowerShell process on the Server01 remote computer, type:</source>
          <target state="translated">Par exemple, pour arrêter le processus PowerShell sur l’ordinateur distant Serveur01, tapez :</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Stopping All Other Windows PowerShell Sessions</source>
          <target state="translated">Arrêt de toutes les autres sessions Windows PowerShell</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>It may occasionally be useful to be able to stop all running Windows PowerShell sessions other than the current session.</source>
          <target state="translated">Il est parfois utile de pouvoir arrêter toutes les sessions Windows PowerShell en cours d’exécution autres que la session active.</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If a session is using too many resources or is inaccessible (it may be running remotely or in another desktop session), you may not be able to directly stop it.</source>
          <target state="translated">Si une session utilise trop de ressources ou n’est pas accessible (par exemple, si elle s’exécute à distance ou dans une autre session de bureau), il se peut que vous ne puissiez pas l’arrêter directement.</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you try to stop all running sessions, however, the current session may be terminated instead.</source>
          <target state="translated">Toutefois, si vous essayez d’arrêter toutes les sessions en cours d’exécution, il se peut que la session active s’arrête à la place.</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Each Windows PowerShell session has an environment variable PID that contains the Id of the Windows PowerShell process.</source>
          <target state="translated">Chaque session Windows PowerShell a un PID de variable d’environnement qui contient l’ID du processus Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can check the $PID against the Id of each session and terminate only Windows PowerShell sessions that have a different Id.</source>
          <target state="translated">Vous pouvez contrôler la valeur de $PID par rapport à l’ID de chaque session, et arrêter uniquement les sessions Windows PowerShell dont l’ID diffère.</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The following pipeline command does this and returns the list of terminated sessions (because of the use of the <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> parameter):</source>
          <target state="translated">La commande de pipeline suivante effectue cette opération et retourne la liste des sessions terminées (en raison de l’utilisation du paramètre <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept>) :</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Starting, Debugging, and Waiting for Processes</source>
          <target state="translated">Démarrage, débogage et attente de processus</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Windows PowerShell also comes with cmdlets to start (or restart), debug a process, and wait for a process to complete before running a command.</source>
          <target state="translated">Windows PowerShell comprend également des applets de commande permettant de démarrer (ou redémarrer) un processus, de déboguer un processus, et d’attendre qu’un processus s’achève avant d’exécuter une commande.</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For information about these cmdlets, see the cmdlet help topic for each cmdlet.</source>
          <target state="translated">Pour plus d’informations sur ces applets de commande, voir la rubrique d’aide sur chacune d’elles.</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">Voir aussi</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Get-Process [m2]</source>
          <target state="translated">Get-Process [m2]</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Stop-Process [m2]</source>
          <target state="translated">Stop-Process [m2]</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Start-Process</source>
          <target state="translated">Start-Process</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Wait-Process</source>
          <target state="translated">Wait-Process</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Debug-Process</source>
          <target state="translated">Debug-Process</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Invoke-Command</source>
          <target state="translated">Invoke-Command</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>