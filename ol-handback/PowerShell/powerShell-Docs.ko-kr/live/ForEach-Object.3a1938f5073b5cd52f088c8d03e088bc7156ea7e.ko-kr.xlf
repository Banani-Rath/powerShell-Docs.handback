<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">128b330f029b09d6d15ebc5a1cda9c52bf275293</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\ForEach-Object.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">879467f5044fb17e5a8f5454d8866973d9eb2aff</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c6c78fd8c27534de8e0cc7bbe70b148ad56501c1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>ForEach-Object</source>
          <target state="translated">ForEach-Object</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>ForEach-Object</source>
          <target state="translated">ForEach-Object</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>SYNOPSIS</source>
          <target state="translated">요약</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Performs an operation against each item in a collection of input objects.</source>
          <target state="translated">입력 개체 컬렉션에 있는 각 항목에 대해 작업을 수행합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">구문</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ScriptBlockSet (Default)</source>
          <target state="translated">ScriptBlockSet (기본값)</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>PropertyAndMethodSet</source>
          <target state="translated">PropertyAndMethodSet</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>DESCRIPTION</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet performs an operation on each item in a collection of input objects.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet 입력된 개체의 컬렉션에 있는 각 항목에 대 한 작업을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The input objects can be piped to the cmdlet or specified by using the <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parameter.</source>
          <target state="translated">입력된 개체를 cmdlet으로 파이프 하거나 사용 하 여 지정 된 수의 <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 3.0, there are two different ways to construct a <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> command.</source>
          <target state="translated">Windows PowerShell 3.0부터, 두 가지가 서로 다른 생성 하는 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 명령입니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Script block<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>스크립트 블록<ept id="p1">**</ept>합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can use a script block to specify the operation.</source>
          <target state="translated">스크립트 블록을 사용하여 작업을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Within the script block, use the $_ variable to represent the current object.</source>
          <target state="translated">스크립트 블록 내에서 $_ 변수를 사용하여 현재 개체를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The script block is the value of the <bpt id="p1">*</bpt>Process<ept id="p1">*</ept> parameter.</source>
          <target state="translated">스크립트 블록의 값은는 <bpt id="p1">*</bpt>프로세스<ept id="p1">*</ept> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The script block can contain any Windows PowerShell script.</source>
          <target state="translated">스크립트 블록에는 모든 Windows PowerShell 스크립트가 포함될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the value of the <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> property of each process on the computer.</source>
          <target state="translated">예를 들어 다음 명령은의 값을 가져옵니다는 <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> 컴퓨터에 있는 각 프로세스의 속성입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Operation statement<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>작업 문을<ept id="p1">**</ept>합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You can also write an operation statement, which is much more like natural language.</source>
          <target state="translated">또한 자연어와 유사한 작업 문을 프로그램을 작성할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can use the operation statement to specify a property value or call a method.</source>
          <target state="translated">작업 문을 사용하여 속성 값을 지정하거나 메서드를 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Operation statements were introduced in Windows PowerShell 3.0.</source>
          <target state="translated">작업 문은 Windows PowerShell 3.0에서 도입되었습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For example, the following command also gets the value of the <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> property of each process on the computer.</source>
          <target state="translated">예를 들어 다음 명령은의 값을도 가져옵니다는 <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> 컴퓨터에 있는 각 프로세스의 속성입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When using the script block format, in addition to using the script block that describes the operations that are performed on each input object, you can provide two additional script blocks.</source>
          <target state="translated">스크립트 블록 형식을 사용할 경우 각 입력 개체에 대해 수행되는 작업을 설명하는 스크립트 블록을 사용하는 것 외에 추가 스크립트 블록 두 개를 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The Begin script block, which is the value of the <bpt id="p1">*</bpt>Begin<ept id="p1">*</ept> parameter, runs before this cmdlet processes the first input object.</source>
          <target state="translated">Begin 스크립트 블록 값인의 <bpt id="p1">*</bpt>시작<ept id="p1">*</ept> 이 cmdlet는 첫 번째 입력된 개체를 처리 하기 전에 매개 변수를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The End script block, which is the value of the <bpt id="p1">*</bpt>End<ept id="p1">*</ept> parameter, runs after this cmdlet processes the last input object.</source>
          <target state="translated">End 스크립트 블록 값인의 <bpt id="p1">*</bpt>끝<ept id="p1">*</ept> 매개 변수를이 cmdlet은 마지막 입력된 개체가 처리 한 후 실행 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">예제</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Example 1: Divide integers in an array</source>
          <target state="translated">예제 1: 배열에 있는 정수 나누기</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This command takes an array of three integers and divides each one of them by 1024.</source>
          <target state="translated">이 명령은 정수 3개의 배열을 사용하고 각 정수를 1024로 나눕니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Example 2: Get the length of all the files in a directory</source>
          <target state="translated">예제 2: 디렉터리에 있는 모든 파일의 길이 가져옵니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This command gets the files and directories in the Windows PowerShell installation directory ($pshome) and passes them to the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">이 명령은 Windows PowerShell 설치 디렉터리 ($pshome)에서 파일 및 디렉터리를 가져옵니다 하 고 파이프라인 연산자는 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet입니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If the object is not a directory, the script block gets the name of the file, divides the value of its <bpt id="p1">**</bpt>Length<ept id="p1">**</ept> property by 1024, and adds a space (" ") to separate it from the next entry.</source>
          <target state="translated">스크립트 블록은 파일의 이름을 가져옵니다의 값을 나눕니다 디렉터리 개체가 없는 경우 해당 <bpt id="p1">**</bpt>길이<ept id="p1">**</ept> 1024, 속성에 공백을 추가 하 고 ("") 다음 항목을 구분할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The cmdlet uses the <bpt id="p1">**</bpt>PSISContainer<ept id="p1">**</ept> property to determine whether an object is a directory.</source>
          <target state="translated">Cmdlet을 사용 하는 <bpt id="p1">**</bpt>PSISContainer<ept id="p1">**</ept> 개체가 디렉터리 인지 확인 하는 속성입니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Example 3: Operate on the most recent System events</source>
          <target state="translated">예제 3: 가장 최근의 시스템 이벤트에 적용</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This command gets the 1000 most recent events from the System event log and stores them in the $Events variable.</source>
          <target state="translated">이 명령은 시스템 이벤트 로그에서 최근 이벤트 1000개를 가져와 $Events 변수에 저장한 다음</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>It then pipes the events to the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">이벤트를 파이프는 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet입니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>Begin<ept id="p1">*</ept> parameter displays the current date and time.</source>
          <target state="translated"> <bpt id="p1">*</bpt>시작<ept id="p1">*</ept> 매개 변수는 현재 날짜 및 시간을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Next, the <bpt id="p1">*</bpt>Process<ept id="p1">*</ept> parameter uses the <bpt id="p2">**</bpt>Out-File<ept id="p2">**</ept> cmdlet to create a text file that is named events.txt and stores the message property of each of the events in that file.</source>
          <target state="translated">다음으로 <bpt id="p1">*</bpt>프로세스<ept id="p1">*</ept> 매개 변수를 사용 하 여는 <bpt id="p2">**</bpt>Out-file<ept id="p2">**</ept> cmdlet events.txt 라는 하 고 해당 파일의 각 이벤트의 메시지 속성을 저장 하는 텍스트 파일을 만듭니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Last, the <bpt id="p1">*</bpt>End<ept id="p1">*</ept> parameter is used to display the date and time after all of the processing has completed.</source>
          <target state="translated">마지막으로는 <bpt id="p1">*</bpt>끝<ept id="p1">*</ept> 매개 변수를 사용 하 여 날짜를 표시 하 고 시간 모든 처리가 완료 합니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Example 4: Change the value of a Registry key</source>
          <target state="translated">레지스트리 키의 값을 변경 하는 예 4:</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This command changes the value of the <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> registry entry in all of the subkeys under the HKCU:\Network key to uppercase text.</source>
          <target state="translated">이 명령은의 값이 변경 된 <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> 모든 텍스트를 대문자로 hkcu: \network 키 아래의 하위 키의 레지스트리 항목입니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can use this format to change the form or content of a registry entry value.</source>
          <target state="translated">이 형식을 사용하여 레지스트리 항목 값의 형식이나 내용을 변경할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Each subkey in the <bpt id="p1">**</bpt>Network<ept id="p1">**</ept> key represents a mapped network drive that will reconnect at logon.</source>
          <target state="translated">각 하위 키에는 <bpt id="p1">**</bpt>네트워크<ept id="p1">**</ept> 키는 로그온 시 다시 연결할 매핑된 네트워크 드라이브를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> entry contains the UNC path of the connected drive.</source>
          <target state="translated"> <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> 는 연결 된 드라이브의 UNC 경로 포함 하는 항목입니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For example, if you map the E: drive to <ph id="ph1">\\\\</ph>Server\Share, there will be an E subkey of HKCU:\Network and the value of the <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> registry entry in the E subkey will be <ph id="ph2">\\\\</ph>Server\Share.</source>
          <target state="translated">예를 들어 e: 드라이브를 매핑하는 경우 <ph id="ph1">\\\\</ph>느릴, 생깁니다 hkcu: \network의 E 하위는 및의 값은 <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> E 하위 키에서 레지스트리 항목이 됩니다 <ph id="ph2">\\\\</ph>느릴 합니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The command uses the Get-ItemProperty cmdlet to get all of the subkeys of the <bpt id="p1">**</bpt>Network<ept id="p1">**</ept> key and the Set-ItemProperty cmdlet to change the value of the <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> registry entry in each key.</source>
          <target state="translated">이 명령은 Get-itemproperty cmdlet를 사용 하 여 모든의 하위 키를 얻습니다는 <bpt id="p1">**</bpt>네트워크<ept id="p1">**</ept> 키와 값을 변경 하려면 Set-itemproperty cmdlet는 <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> 각 키의 레지스트리 항목입니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Set-ItemProperty<ept id="p1">**</ept> command, the path is the value of the <bpt id="p2">**</bpt>PSPath<ept id="p2">**</ept> property of the registry key.</source>
          <target state="translated">에 <bpt id="p1">**</bpt>Set-itemproperty<ept id="p1">**</ept> 명령, 경로 값은 <bpt id="p2">**</bpt>PSPath<ept id="p2">**</ept> 레지스트리 키의 속성입니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>This is a property of the Microsoft .NET Framework object that represents the registry key, not a registry entry.</source>
          <target state="translated">레지스트리 항목이 아니라 레지스트리 키를 나타내는 Microsoft.NET Framework 개체의 속성입니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The command uses the <bpt id="p1">**</bpt>ToUpper()<ept id="p1">**</ept> method of the <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> value, which is a string (REG_SZ).</source>
          <target state="translated">명령을 사용 하 여는 <bpt id="p1">**</bpt>toupper ()<ept id="p1">**</ept> 의 메서드는 <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> 문자열 (REG_SZ)는 값입니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Because <bpt id="p1">**</bpt>Set-ItemProperty<ept id="p1">**</ept> is changing the property of each key, the <bpt id="p2">**</bpt>ForEach-Object<ept id="p2">**</ept> cmdlet is required to access the property.</source>
          <target state="translated">때문에 <bpt id="p1">**</bpt>Set-itemproperty<ept id="p1">**</ept> 각 키의 속성이 변경 되는 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> cmdlet은 속성에 액세스 해야 합니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Example 5: Use the $Null automatic variable</source>
          <target state="translated">예제 5: $Null 자동 변수를 사용 합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This example shows the effect of piping the $Null automatic variable to the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">$Null 자동 변수를 파이프의 효과 보여 주는이 예제는 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet입니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Because Windows PowerShell treats null as an explicit placeholder, the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet generates a value for $Null, just as it does for other objects that you pipe to it.</source>
          <target state="translated">Windows PowerShell에서 null을 명시적 자리 표시자로 처리 하기 때문에 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet에 파이프 하는 다른 개체와 마찬가지로 $Null에 대 한 값을 생성 합니다.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>For more information about the $Null automatic variable, see about_Automatic_Variables.</source>
          <target state="translated">$Null 자동 변수에 대 한 자세한 내용은 about_Automatic_Variables를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Example 6: Get property values</source>
          <target state="translated">예제 6: 속성 값을 가져오려면</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>These commands gets the value of the <bpt id="p1">**</bpt>Path<ept id="p1">**</ept> property of all installed Windows PowerShell modules.</source>
          <target state="translated">이러한 명령은의 값을 가져옵니다는 <bpt id="p1">**</bpt>경로<ept id="p1">**</ept> 설치 된 Windows PowerShell 모듈의 모든 속성.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>They use the <bpt id="p1">*</bpt>MemberName<ept id="p1">*</ept> parameter to specify the <bpt id="p2">**</bpt>Path<ept id="p2">**</ept> property of modules.</source>
          <target state="translated">사용 하는 <bpt id="p1">*</bpt>MemberName<ept id="p1">*</ept> 매개 변수는 <bpt id="p2">**</bpt>경로<ept id="p2">**</ept> 모듈의 속성입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The second command is equivalent to the first.</source>
          <target state="translated">두 번째 명령은 첫 번째 명령과 같습니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> alias of the <bpt id="p2">**</bpt>ForEach-Object<ept id="p2">**</ept> cmdlet and omits the name of the <bpt id="p3">*</bpt>MemberName<ept id="p3">*</ept> parameter, which is optional.</source>
          <target state="translated">사용 하 여는 <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> 의 별칭은 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> cmdlet의 이름을 생략 하 고는 <bpt id="p3">*</bpt>MemberName<ept id="p3">*</ept> 매개 변수는 선택 사항입니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet is very useful for getting property values, because it gets the value without changing the type, unlike the <bpt id="p2">**</bpt>Format<ept id="p2">**</ept> cmdlets or the Select-Object cmdlet, which change the property value type.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 달리 형식을 변경 하지 않고 값을 가져오기 때문에 cmdlet은 속성 값을 가져오는 데 매우 유용는 <bpt id="p2">**</bpt>형식<ept id="p2">**</ept> cmdlet 또는 속성을 변경 하는 Select-object cmdlet으로 값 형식입니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Example 7: Split module names into component names</source>
          <target state="translated">구성 요소 이름으로 예 7: 분할 모듈 이름</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>These commands split two dot-separated module names into their component names.</source>
          <target state="translated">이 명령은 점으로 구분된 두 개의 모듈 이름을 해당 구성 요소 이름으로 분할합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The commands call the <bpt id="p1">**</bpt>Split<ept id="p1">**</ept> method of strings.</source>
          <target state="translated">명령 호출의 <bpt id="p1">**</bpt>분할<ept id="p1">**</ept> 방법 문자열입니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The three commands use different syntax, but they are equivalent and interchangeable.</source>
          <target state="translated">세 명령은 서로 다른 구문을 사용하지만 동일하며 교환해서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The first command uses the traditional syntax, which includes a script block and the current object operator ($_).</source>
          <target state="translated">첫 번째 명령은 스크립트 블록과 현재 개체 연산자($_)를 포함하는 일반적인 구문을 사용합니다.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>It uses the dot syntax to specify the method and parentheses to enclose the delimiter argument.</source>
          <target state="translated">점 구문을 사용하여 메서드를 지정하고 괄호를 사용하여 구분 기호 인수를 묶습니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The second command uses the <bpt id="p1">*</bpt>MemberName<ept id="p1">*</ept> parameter to specify the <bpt id="p2">**</bpt>Split<ept id="p2">**</ept> method and the <bpt id="p3">*</bpt>ArgumentName<ept id="p3">*</ept> parameter to identify the dot (".") as the split delimiter.</source>
          <target state="translated">두 번째 명령은 <bpt id="p1">*</bpt>MemberName<ept id="p1">*</ept> 매개 변수는 <bpt id="p2">**</bpt>분할<ept id="p2">**</ept> 메서드 및 <bpt id="p3">*</bpt>ArgumentName<ept id="p3">*</ept> 점 연산자를 식별 하는 매개 변수 (".") 분할 구분 기호로.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The third command uses the <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> alias of the <bpt id="p2">**</bpt>Foreach-Object<ept id="p2">**</ept> cmdlet and omits the names of the <bpt id="p3">*</bpt>MemberName<ept id="p3">*</ept> and <bpt id="p4">*</bpt>ArgumentList<ept id="p4">*</ept> parameters, which are optional.</source>
          <target state="translated">세 번째 명령은 <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> 의 별칭은 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> cmdlet의 이름은 생략 하 고는 <bpt id="p3">*</bpt>MemberName<ept id="p3">*</ept> 및 <bpt id="p4">*</bpt>ArgumentList<ept id="p4">*</ept> 선택적 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The output of these three commands, shown below, is identical.</source>
          <target state="translated">아래 표시된 세 명령의 출력은 동일합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Split<ept id="p1">**</ept> is just one of many useful methods of strings.</source>
          <target state="translated"><bpt id="p1">**</bpt>분할<ept id="p1">**</ept> 문자열의 많은 유용한 메서드 중 하나일 뿐입니다.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>To see all of the properties and methods of strings, pipe a string to the Get-Member cmdlet.</source>
          <target state="translated">모든 속성 및 메서드를 보려면 문자열을 Get-member cmdlet에 대 한 문자열을 파이프 합니다.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>PARAMETERS</source>
          <target state="translated">매개 변수</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>-ArgumentList</source>
          <target state="translated">-ArgumentList</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Specifies an array of arguments to a method call.</source>
          <target state="translated">메서드 호출에 대 한 인수 배열을 지정합니다.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This parameter was introduced in Windows PowerShell 3.0.</source>
          <target state="translated">이 매개 변수는 Windows PowerShell 3.0에서 도입 되었습니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>-Begin</source>
          <target state="translated">-시작</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Specifies a script block that runs before this cmdlet processes any input objects.</source>
          <target state="translated">이 cmdlet는 모든 입력된 개체를 처리 하기 전에 실행 되는 스크립트 블록을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>-Confirm</source>
          <target state="translated">-Confirm</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Prompts you for confirmation before running the cmdlet.Prompts you for confirmation before running the cmdlet.</source>
          <target state="translated">이 cmdlet을 실행 하기 전에 확인 하면 메시지를 표시 합니다. 이 cmdlet을 실행 하기 전에 확인 하면 메시지를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>-End</source>
          <target state="translated">엔드</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Specifies a script block that runs after this cmdlet processes all input objects.</source>
          <target state="translated">이 cmdlet는 모든 입력된 개체를 처리 한 후 실행 되는 스크립트 블록을 지정 합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>-InputObject</source>
          <target state="translated">-InputObject</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Specifies the input objects.</source>
          <target state="translated">입력 개체를 지정합니다.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>ForEach-Object<ept id="p1">*</ept> runs the script block or operation statement on each input object.</source>
          <target state="translated"><bpt id="p1">*</bpt>Foreach-object<ept id="p1">*</ept> 각 입력된 개체에 대해 스크립트 블록 또는 작업 문을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Enter a variable that contains the objects, or type a command or expression that gets the objects.</source>
          <target state="translated">개체를 포함하는 변수를 입력하거나 개체를 가져오는 명령 또는 식을 입력하세요.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When you use the <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> parameter with <bpt id="p2">**</bpt>ForEach-Object<ept id="p2">**</ept>, instead of piping command results to <bpt id="p3">**</bpt>ForEach-Object<ept id="p3">**</ept>, the <bpt id="p4">*</bpt>InputObject<ept id="p4">*</ept> value is treated as a single object.</source>
          <target state="translated">사용 하는 경우는 <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> 매개 변수를 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept>, 명령 결과를 파이프 하는 대신 <bpt id="p3">**</bpt>Foreach-object<ept id="p3">**</ept>,  <bpt id="p4">*</bpt>InputObject<ept id="p4">*</ept> 값은 단일 개체로 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This is true even if the value is a collection that is the result of a command, such as <ph id="ph1">`-InputObject (Get-Process)`</ph>.</source>
          <target state="translated">값 컬렉션, 명령의 결과 같은 경우에 그렇습니다 <ph id="ph1">`-InputObject (Get-Process)`</ph>합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Because <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> cannot return individual properties from an array or collection of objects, we recommend that if you use <bpt id="p2">**</bpt>ForEach-Object<ept id="p2">**</ept> to perform operations on a collection of objects for those objects that have specific values in defined properties, you use <bpt id="p3">**</bpt>ForEach-Object<ept id="p3">**</ept> in the pipeline, as shown in the examples in this topic.</source>
          <target state="translated">때문에 <bpt id="p1">*</bpt>InputObject<ept id="p1">*</ept> 개별 속성을 반환할 수 없는 배열 또는 개체의 컬렉션에서 권장 하는 사용 하는 경우 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> 사용 하면 정의 된 속성에 특정 값이 있는 해당 개체에 대 한 개체의 컬렉션에 대 한 작업을 수행 하려면 <bpt id="p3">**</bpt>Foreach-object<ept id="p3">**</ept> 파이프라인에서이 항목의 예제에 나와 있는 것 처럼 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>-MemberName</source>
          <target state="translated">-MemberName</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Specifies the property to get or the method to call.</source>
          <target state="translated">가져올 속성이나 호출할 메서드를 지정합니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Wildcard characters are permitted, but work only if the resulting string resolves to a unique value.</source>
          <target state="translated">와일드 카드 문자 허용 되지만 결과 문자열 고유 값으로 확인 하는 경우에 작동 합니다.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>If, for example, you run <ph id="ph1">`Get-Process | ForEach -MemberName *Name`</ph>, and more than one member exists with a name that contains the string Name, such as the <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Name<ept id="p2">**</ept> properties, the command fails.</source>
          <target state="translated">예를 들어, 실행 하는 경우 <ph id="ph1">`Get-Process | ForEach -MemberName *Name`</ph>, 둘 이상의 멤버와 같은 이름 문자열을 포함 하는 이름의 존재는 <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> 및 <bpt id="p2">**</bpt>이름<ept id="p2">**</ept> 속성 명령이 실패 합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This parameter was introduced in Windows PowerShell 3.0.</source>
          <target state="translated">이 매개 변수는 Windows PowerShell 3.0에서 도입 되었습니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>-Process</source>
          <target state="translated">프로세스</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Specifies the operation that is performed on each input object.</source>
          <target state="translated">각 입력 개체에 대해 수행되는 작업을 지정합니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Enter a script block that describes the operation.</source>
          <target state="translated">작업을 설명하는 스크립트 블록을 입력합니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>-RemainingScripts</source>
          <target state="translated">-RemainingScripts</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Specifies all script blocks that are not taken by the <bpt id="p1">*</bpt>Process<ept id="p1">*</ept> parameter.</source>
          <target state="translated">사용 되지 않은 모든 스크립트 블록을 지정 된 <bpt id="p1">*</bpt>프로세스<ept id="p1">*</ept> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This parameter was introduced in Windows PowerShell 3.0.</source>
          <target state="translated">이 매개 변수는 Windows PowerShell 3.0에서 도입 되었습니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>-WhatIf</source>
          <target state="translated">-WhatIf</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Shows what would happen if the cmdlet runs.</source>
          <target state="translated">cmdlet이 실행될 경우 결과 동작을 표시합니다.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The cmdlet is not run.Shows what would happen if the cmdlet runs.</source>
          <target state="translated">Cmdlet은 실행 되지 않습니다. Cmdlet이 실행 되 면 어떻게 되는지를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The cmdlet is not run.</source>
          <target state="translated">cmdlet이 실행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>CommonParameters</source>
          <target state="translated">CommonParameters</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable.</source>
          <target state="translated">이 cmdlet은 공통 매개 변수:-디버그,-ErrorAction,-ErrorVariable,-InformationAction,-InformationVariable,-OutVariable,-OutBuffer,-PipelineVariable,-Verbose,-WarningAction 및-warningvariable을 지원 합니다.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>For more information, see about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216).</source>
          <target state="translated">자세한 내용은 about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216)를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>INPUTS</source>
          <target state="translated">입력</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>System.Management.Automation.PSObject</source>
          <target state="translated">System.Management.Automation.PSObject</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>You can pipe any object to this cmdlet.</source>
          <target state="translated">이 cmdlet에 개체를 파이프할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>OUTPUTS</source>
          <target state="translated">출력</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>System.Management.Automation.PSObject</source>
          <target state="translated">System.Management.Automation.PSObject</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>This cmdlet returns objects that are determined by the input.</source>
          <target state="translated">이 cmdlet는 입력에 의해 결정 하는 개체를 반환 합니다.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>NOTES</source>
          <target state="translated">참고 사항</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet works much like the <bpt id="p2">**</bpt>Foreach<ept id="p2">**</ept> statement, except that you cannot pipe input to a <bpt id="p3">**</bpt>Foreach<ept id="p3">**</ept> statement.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet와 비슷하게 작동는 <bpt id="p2">**</bpt>Foreach<ept id="p2">**</ept> 문을 제외 하 고에 대 한 입력을 파이프할 수 없습니다는 <bpt id="p3">**</bpt>Foreach<ept id="p3">**</ept> 문입니다.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For more information about the <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> statement, see about_Foreach (http://go.microsoft.com/fwlink/?LinkID=113229) in the Microsoft TechNet library.</source>
          <target state="translated">에 대 한 자세한 내용은 <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> 문, Microsoft TechNet 라이브러리에서 참조 about_Foreach (http://go.microsoft.com/fwlink/?LinkID=113229).</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>RELATED LINKS</source>
          <target state="translated">관련된 링크</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>about_Automatic_Variables</source>
          <target state="translated">about_Automatic_Variables</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>about_ForEach</source>
          <target state="translated">about_ForEach</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>about_Script_Blocks</source>
          <target state="translated">about_Script_Blocks</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Get-ItemProperty</source>
          <target state="translated">Get-itemproperty</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Get-Member</source>
          <target state="translated">Get-Member</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Select-Object</source>
          <target state="translated">Select-Object</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Set-ItemProperty</source>
          <target state="translated">Set-ItemProperty</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>