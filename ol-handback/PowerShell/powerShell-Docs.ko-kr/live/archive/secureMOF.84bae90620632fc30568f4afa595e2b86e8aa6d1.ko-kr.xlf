<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dsc\secureMOF.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">792135742e34239f6866945e300b9277289e2062</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-8d96cd8" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Securing the MOF File</source>
          <target state="translated">MOF 파일 보안</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Securing the MOF File</source>
          <target state="translated">MOF 파일 보안</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Applies To: Windows PowerShell 4.0, Windows PowerShell 5.0</source>
          <target state="translated">적용 대상: Windows PowerShell 4.0, Windows PowerShell 5.0</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>DSC tells the target nodes what configuration they should have by sending a MOF file with that information to each node, where the Local Configuration Manager (LCM) implements the desired configuration.</source>
          <target state="translated">DSC에서는 해당 정보가 있는 MOF 파일을 LCM(로컬 구성 관리자)이 원하는 구성을 구현하는 각 노드에 전송하여 보유해야 하는 구성을 대상 노드에게 알려줍니다.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Because this file contains the details of the configuration, it’s important to keep it secure.</source>
          <target state="translated">이 파일은 구성의 세부 정보를 포함하므로 안전하게 보관해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>To do this, you can set the LCM to check the credentials of a user.</source>
          <target state="translated">이렇게 하기 위해 사용자의 자격 증명을 확인하도록 LCM을 설정할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This topic describes how to transmit those credentials securely to the target node by encrypting them with certificates.</source>
          <target state="translated">이 항목에서는 인증서로 암호화하여 이러한 자격 증명을 대상 노드에 안전하게 전송하는 방법에 대해 설명합니다.</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note:<ept id="p1">**</ept> This topic discusses certificates used for encryption.</source>
          <target state="translated"><bpt id="p1">**</bpt>참고:<ept id="p1">**</ept> 이 항목에서는 암호화에 사용되는 인증서에 대해 설명합니다.</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For encryption, a self-signed certificate is sufficient, because the private key is always kept secret and encryption does not imply trust of the document.</source>
          <target state="translated">암호화의 경우 개인 키의 보안이 항상 유지되고 암호화는 문서에 대한 신뢰를 암시하지 않으므로 자체 서명된 인증서로도 충분합니다.</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Self-signed certificates should <bpt id="p1">*</bpt>not<ept id="p1">*</ept> be used for authentication purposes.</source>
          <target state="translated">자체 서명된 인증서는 인증 목적으로 사용하면 <bpt id="p1">*</bpt>안 됩니다<ept id="p1">*</ept>.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You should use a certificate from a trusted Certification Authority (CA) for any authentication purposes.</source>
          <target state="translated">인증 목적에는 신뢰할 수 있는 CA(인증 기관)의 인증서를 사용해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">필수 구성 요소</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>To successfully encrypt the credentials used to secure a DSC configuration, make sure you have the following:</source>
          <target state="translated">DSC 구성을 보호하는 데 사용되는 자격 증명을 적절히 암호화하려면 다음의 항목이 있어야 합니다.</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Some means of issuing and distributing certificates<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>인증서를 발급하고 배포할 여러 가지 방법<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This topic and its examples assume you are using Active Directory Certification Authority.</source>
          <target state="translated">이 항목 및 해당 예제에서는 Active Directory 인증 기관을 사용 중이라고 가정합니다.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For more background information on Active Directory Certificate Services, see <bpt id="p1">[</bpt>Active Directory Certificate Services Overview<ept id="p1">](https://technet.microsoft.com/library/hh831740.aspx)</ept> and <bpt id="p2">[</bpt>Active Directory Certificate Services in Windows Server 2008<ept id="p2">](https://technet.microsoft.com/windowsserver/dd448615.aspx)</ept>.</source>
          <target state="translated">Active Directory 인증서 서비스에 대한 자세한 배경 정보를 알려면 <bpt id="p1">[</bpt>Active Directory 인증서 서비스 개요<ept id="p1">](https://technet.microsoft.com/library/hh831740.aspx)</ept> 및 <bpt id="p2">[</bpt>Windows Server 2008의 Active Directory 인증서 서비스<ept id="p2">](https://technet.microsoft.com/windowsserver/dd448615.aspx)</ept>를 참조하세요.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Administrative access to the target node or nodes<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>대상 노드에 대한 관리 권한<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Each target node has an encryption-capable certificate saved its Personal Store<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>각 대상 노드에 해당 개인 저장소에 저장된 암호화 가능 인증서가 있습니다<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, the path to the store is Cert:\LocalMachine\My.</source>
          <target state="translated">Windows PowerShell에서 저장소 경로는 Cert:\LocalMachine\My입니다.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The examples in this topic use the “workstation authentication” template, which you can find (along with other certificate templates) at <bpt id="p1">[</bpt>Default Certificate Templates<ept id="p1">](https://technet.microsoft.com/library/cc740061(v=WS.10).aspx)</ept>.</source>
          <target state="translated">이 항목의 예제에서는 <bpt id="p1">[</bpt>기본 인증서 템플릿<ept id="p1">](https://technet.microsoft.com/library/cc740061(v=WS.10).aspx)</ept>에 있는(다른 인증서 템플릿과 함께) "워크스테이션 인증" 템플릿을 사용합니다.</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you will be running this configuration on a computer other than the target node, <bpt id="p1">**</bpt>export the public key of the certificate<ept id="p1">**</ept>, and then import it to the computer you will run the configuration from.</source>
          <target state="translated">이 구성을 대상 노드 외의 컴퓨터에서 실행하려는 경우 <bpt id="p1">**</bpt>인증서의 공개 키를 내보내고<ept id="p1">**</ept>, 구성을 실행할 컴퓨터로 가져옵니다.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Make sure that you export only the <bpt id="p1">**</bpt>public<ept id="p1">**</ept> key; keep the private key secure.</source>
          <target state="translated"><bpt id="p1">**</bpt>공개<ept id="p1">**</ept> 키만 내보내도록 합니다. 개인 키는 안전하게 보관하세요.</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Overall process</source>
          <target state="translated">전체 프로세스</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Set up the certificates, keys, and thumbprints, making sure that each target node has copies of the certificate and the configuration computer has the public key and thumbprint.</source>
          <target state="translated">인증서, 키 및 지문을 설정하여, 각 대상 노드에 인증서의 복사본이 있고, 구성 컴퓨터에 공개 키와 지문이 있도록 합니다.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Create a configuration data block that contains the path and thumbprint of the public key.</source>
          <target state="translated">공개 키의 경로와 지문을 포함하는 구성 데이터 블록을 만듭니다.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Create a configuration script that defines your desired configuration for the target node and sets up decryption on the target nodes by commanding the Local Configuration manager to decrypt the configuration data using the certificate and its thumbprint.</source>
          <target state="translated">로컬 구성 관리자가 인증서 및 지문을 사용하여 구성 데이터를 해독하도록 함으로써 대상 노드에 대해 원하는 구성을 정의하고 대상 노드에서 암호 해독을 설정하는 구성 스크립트를 만듭니다.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Run the configuration, which will set the Local Configuration Manager settings and start the DSC configuration.</source>
          <target state="translated">로컬 구성 관리자 설정을 설정하고 DSC 구성을 시작할 구성을 실행합니다.</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Diagram1</source>
          <target state="translated">Diagram1</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Certificate Requirements</source>
          <target state="translated">인증서 요구 사항</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To enact credential encryption, a public key certificate must be available on the <bpt id="p1">_</bpt>Target Node<ept id="p1">_</ept> that is <bpt id="p2">**</bpt>trusted<ept id="p2">**</ept> by the computer being used to author the DSC configuration.</source>
          <target state="translated">자격 증명 암호화를 적용하려면 DSC 구성을 작성하는 데 사용되는 컴퓨터에서 <bpt id="p2">**</bpt>신뢰할 수 있는<ept id="p2">**</ept> <bpt id="p1">_</bpt>대상 노드<ept id="p1">_</ept>에서 공개 키 인증서를 사용할 수 있어야 합니다.</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This public key certificate has specific requirements for it to be used for DSC credential encryption:</source>
          <target state="translated">이 공개 키 인증서를 DSC 자격 증명 암호화에 사용하려면 다음과 같은 특정 요구 사항을 충족해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Key Usage<ept id="p1">**</ept>:</source>
          <target state="translated"><bpt id="p1">**</bpt>키 사용<ept id="p1">**</ept>:</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Must contain: 'KeyEncipherment' and 'DataEncipherment'.</source>
          <target state="translated">'KeyEncipherment' 및 'DataEncipherment'를 포함해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Should <bpt id="p1">_</bpt>not<ept id="p1">_</ept> contain: 'Digital Signature'.</source>
          <target state="translated">'디지털 서명'을 포함하지 <bpt id="p1">_</bpt>않아야<ept id="p1">_</ept> 합니다.</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Enhanced Key Usage<ept id="p1">**</ept>:</source>
          <target state="translated"><bpt id="p1">**</bpt>확장된 키 사용<ept id="p1">**</ept>:</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Must contain: Document Encryption (1.3.6.1.4.1.311.80.1).</source>
          <target state="translated">문서 암호화(1.3.6.1.4.1.311.80.1)를 포함해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Should <bpt id="p1">_</bpt>not<ept id="p1">_</ept> contain: Client Authentication (1.3.6.1.5.5.7.3.2) and Server Authentication (1.3.6.1.5.5.7.3.1).</source>
          <target state="translated">클라이언트 인증(1.3.6.1.5.5.7.3.2) 및 서버 인증(1.3.6.1.5.5.7.3.1)을 포함하지 <bpt id="p1">_</bpt>않아야<ept id="p1">_</ept> 합니다.</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The Private Key for the certificate is available on the *Target Node_.</source>
          <target state="translated">인증서에 대한 개인 키를 *대상 노드_에서 사용할 수 있어야 합니다.</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Provider<ept id="p1">**</ept> for the certificate must be "Microsoft RSA SChannel Cryptographic Provider".</source>
          <target state="translated">인증서의 <bpt id="p1">**</bpt>공급자<ept id="p1">**</ept>는 "Microsoft RSA SChannel Cryptographic Provider"여야 합니다.</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Recommended Best Practice:<ept id="p1">**</ept> Although you can use a certificate with containing a Key Usage of 'Digital Signature' or one of the Authentication EKU's, this will enable the encryption key to be more easily misused and vulnerable to attack.</source>
          <target state="translated"><bpt id="p1">**</bpt>권장 모범 사례:<ept id="p1">**</ept> 키 사용 '디지털 서명' 또는 인증 EKU 중 하나를 포함하는 인증서를 사용할 수 있지만 이 경우 암호화 키가 오용되기 쉽고 공격에 취약해질 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>So it is best practice to use a certificate created specifically for the purpose of securing DSC credentials that omits these Key Usage and EKUs.</source>
          <target state="translated">따라서 이러한 키 사용 및 EKU를 포함하지 않고 DSC 자격 증명을 보호하기 위해 특별히 만든 인증서를 사용하는 것이 좋습니다.</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Any existing certificate on the <bpt id="p1">_</bpt>Target Node<ept id="p1">_</ept> that meets these criteria can be used to secure DSC credentials.</source>
          <target state="translated">이러한 기준을 충족하는 <bpt id="p1">_</bpt>대상 노드<ept id="p1">_</ept>의 모든 기존 인증서는 DSC 자격 증명을 보호하는 데 사용할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Certificate creation</source>
          <target state="translated">인증서 만들기</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>There are two approaches you can take to create and use the required Encryption Certificate (public-private key pair).</source>
          <target state="translated">필요한 암호화 인증서(공개-개인 키 쌍)를 만들고 사용하기 위한 두 가지 방법이 있습니다.</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Create it on the <bpt id="p1">**</bpt>Target Node<ept id="p1">**</ept> and export just the public key to the <bpt id="p2">**</bpt>Authoring Node<ept id="p2">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>대상 노드<ept id="p1">**</ept>에서 만든 후 공개 키를 <bpt id="p2">**</bpt>제작 노드<ept id="p2">**</ept>로 내보냅니다.</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Create it on the <bpt id="p1">**</bpt>Authoring Node<ept id="p1">**</ept> and export the entire key pair to the <bpt id="p2">**</bpt>Target Node<ept id="p2">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>제작 노드<ept id="p1">**</ept>에서 만든 후 전체 키 쌍을 <bpt id="p2">**</bpt>대상 노드<ept id="p2">**</ept>로 내보냅니다.</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Method 1 is recommended because the private key used to decrypt credentials in the MOF stays on the Target Node at all times.</source>
          <target state="translated">MOF의 자격 증명 암호 해독에 사용되는 개인 키는 항상 대상 노드에 머무르므로 1번 방법을 사용하는 것이 좋습니다.</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Creating the Certificate on the Target Node</source>
          <target state="translated">대상 노드에서 인증서 만들기</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The private key must be kept secret, because is used to decrypt the MOF on the <bpt id="p1">**</bpt>Target Node<ept id="p1">**</ept> The easiest way to do that is to create the private key certificate on the <bpt id="p2">**</bpt>Target Node<ept id="p2">**</ept>, and copy the <bpt id="p3">**</bpt>public key certificate<ept id="p3">**</ept> to the computer being used to author the DSC configuration into a MOF file.</source>
          <target state="translated"><bpt id="p1">**</bpt>대상 노드<ept id="p1">**</ept>에서 개인 키는 MOF의 암호를 해독하는 데 사용되기 때문에 보안을 유지해야 합니다. 이를 위한 가장 손쉬운 방법은 <bpt id="p2">**</bpt>대상 노드<ept id="p2">**</ept>에서 개인 키 인증서를 만들고, DSC 구성을 MOF 파일로 제작하는 데 사용하는 컴퓨터로 <bpt id="p3">**</bpt>공개 키 인증서<ept id="p3">**</ept>를 복사하는 것입니다.</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following example:</source>
          <target state="translated">다음 예제를 참조하세요.</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>creates a certificate on the <bpt id="p1">**</bpt>Target node<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>대상 노드<ept id="p1">**</ept>에서 인증서를 만듭니다.</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>exports the public key certificate on the <bpt id="p1">**</bpt>Target node<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>대상 노드<ept id="p1">**</ept>에서 공개 키 인증서를 내보냅니다.</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>imports the public key certificate into the <bpt id="p1">**</bpt>my<ept id="p1">**</ept> certificate store on the <bpt id="p2">**</bpt>Authoring node<ept id="p2">**</ept>.</source>
          <target state="translated">공개 키 인증서를 <bpt id="p2">**</bpt>제작 노드<ept id="p2">**</ept>에 있는 <bpt id="p1">**</bpt>내<ept id="p1">**</ept> 인증서 저장소로 가져옵니다.</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>On the Target Node: create and export the certificate</source>
          <target state="translated">대상 노드: 인증서를 만들고 내보냅니다.</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Authoring Node: Windows Server 2016 and Windows 10</source>
          <target state="translated">제작 노드: Windows Server 2016 및 Windows 10</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Once exported, the <ph id="ph1">```DscPublicKey.cer```</ph> would need to be copied to the <bpt id="p1">**</bpt>Authoring Node<ept id="p1">**</ept>.</source>
          <target state="translated">내보내고 나면 <ph id="ph1">```DscPublicKey.cer```</ph>을 <bpt id="p1">**</bpt>제작 노드<ept id="p1">**</ept>로 복사해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Authoring Node: Windows Server 2012 R2/Windows 8.1 and earlier</source>
          <target state="translated">제작 노드: Windows Server 2012 R2/Windows 8.1 이하 버전</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Because the New-SelfSignedCertificate cmdlet on Windows Operating Systems prior to Windows 10 and Windows Server 2016 do not support the <bpt id="p1">**</bpt>Type<ept id="p1">**</ept> parameter, an alternate method of creating this certificate is required on these operating systems.</source>
          <target state="translated">Windows 10 및 Windows Server 2016 이전의 Windows 운영 체제에서는 New-SelfSignedCertificate cmdlet이 <bpt id="p1">**</bpt>Type<ept id="p1">**</ept> 매개 변수를 지원하지 않으므로, 이 운영 체제에서는 이 인증서를 만들기 위한 대체 방법이 필요합니다.</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In this case you can use <ph id="ph1">```makecert.exe```</ph> or <ph id="ph2">```certutil.exe```</ph> to create the certificate.</source>
          <target state="translated">이 경우 <ph id="ph1">```makecert.exe```</ph> 또는 <ph id="ph2">```certutil.exe```</ph>를 사용해 인증서를 만들 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>An alternate method is to <bpt id="p1">[</bpt>download the New-SelfSignedCertificateEx.ps1 script from Microsoft Script Center<ept id="p1">](https://gallery.technet.microsoft.com/scriptcenter/Self-signed-certificate-5920a7c6)</ept> and use it to create the certificate instead:</source>
          <target state="translated">대체 방법은 <bpt id="p1">[</bpt>Microsoft 스크립트 센터에서 New-SelfSignedCertificateEx.ps1 스크립트를 다운로드<ept id="p1">](https://gallery.technet.microsoft.com/scriptcenter/Self-signed-certificate-5920a7c6)</ept>한 후 이를 대신 사용해 인증서를 만드는 것입니다.</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Once exported, the <ph id="ph1">```DscPublicKey.cer```</ph> would need to be copied to the <bpt id="p1">**</bpt>Authoring Node<ept id="p1">**</ept>.</source>
          <target state="translated">내보내고 나면 <ph id="ph1">```DscPublicKey.cer```</ph>을 <bpt id="p1">**</bpt>제작 노드<ept id="p1">**</ept>로 복사해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>On the Authoring Node: import the cert’s public key</source>
          <target state="translated">제작 노드: 인증서의 공개 키를 가져옵니다.</target>         
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Creating the Certificate on the Authoring Node</source>
          <target state="translated">제작 노드에서 인증서 만들기</target>         
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Alternately, the encryption certificate can be created on the <bpt id="p1">**</bpt>Authoring Node<ept id="p1">**</ept>, exported with the <bpt id="p2">**</bpt>private key<ept id="p2">**</ept> as a PFX file and then imported on the <bpt id="p3">**</bpt>Target Node<ept id="p3">**</ept>.</source>
          <target state="translated">또는, 암호화 인증서를 <bpt id="p1">**</bpt>제작 노드<ept id="p1">**</ept>에서 만들고, <bpt id="p2">**</bpt>개인 키<ept id="p2">**</ept>를 사용해 PFX 파일로 내보낸 다음 <bpt id="p3">**</bpt>대상 노드<ept id="p3">**</ept>에서 가져올 수도 있습니다.</target>         
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This is the current method for implementing DSC credential encryption on <bpt id="p1">_</bpt>Nano Server<ept id="p1">_</ept>.</source>
          <target state="translated">이것이 <bpt id="p1">_</bpt>Nano Server<ept id="p1">_</ept>에서 DSC 자격 증명 암호화를 구현하는 최신 방법입니다.</target>         
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Although the PFX is secured with a password it should be kept secure during transit.</source>
          <target state="translated">PFX는 암호로 보호되어 있지만 전송 중에도 보호 상태가 유지되어야 합니다.</target>         
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following example:</source>
          <target state="translated">다음 예제를 참조하세요.</target>         
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>creates a certificate on the <bpt id="p1">**</bpt>Authoring node<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>제작 노드<ept id="p1">**</ept>에서 인증서를 만듭니다.</target>         
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>exports the certificate including the private key on the <bpt id="p1">**</bpt>Authoring node<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>제작 노드<ept id="p1">**</ept>에서 개인 키를 포함하여 인증서를 내보냅니다.</target>         
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>removes the private key from the <bpt id="p1">**</bpt>Authoring node<ept id="p1">**</ept>, but keeps the public key certificate in the <bpt id="p2">**</bpt>my<ept id="p2">**</ept> store.</source>
          <target state="translated"><bpt id="p1">**</bpt>제작 노드<ept id="p1">**</ept>에서 개인 키를 제거하고, 공개 키 인증서는 <bpt id="p2">**</bpt>내<ept id="p2">**</ept> 저장소에 보관합니다.</target>         
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>imports the private key certificate into the root certificate store on the <bpt id="p1">**</bpt>Target node<ept id="p1">**</ept>.</source>
          <target state="translated">개인 키 인증서를 <bpt id="p1">**</bpt>대상 노드<ept id="p1">**</ept>에 있는 루트 인증서 저장소로 가져옵니다.</target>         
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>it must be added to the root store so that it will be trusted by the <bpt id="p1">**</bpt>Target node<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>대상 노드<ept id="p1">**</ept>에서 신뢰할 수 있도록 루트 저장소에 추가해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>On the Authoring Node: create and export the certificate</source>
          <target state="translated">제작 노드: 인증서를 만들고 내보냅니다.</target>         
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Target Node: Windows Server 2016 and Windows 10</source>
          <target state="translated">대상 노드: Windows Server 2016 및 Windows 10</target>         
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Once exported, the <ph id="ph1">```DscPrivateKey.cer```</ph> would need to be copied to the <bpt id="p1">**</bpt>Target Node<ept id="p1">**</ept>.</source>
          <target state="translated">내보내고 나면 <ph id="ph1">```DscPrivateKey.cer```</ph>을 <bpt id="p1">**</bpt>대상 노드<ept id="p1">**</ept>로 복사해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Target Node: Windows Server 2012 R2/Windows 8.1 and earlier</source>
          <target state="translated">대상 노드: Windows Server 2012 R2/Windows 8.1 이하 버전</target>         
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Because the New-SelfSignedCertificate cmdlet on Windows Operating Systems prior to Windows 10 and Windows Server 2016 do not support the <bpt id="p1">**</bpt>Type<ept id="p1">**</ept> parameter, an alternate method of creating this certificate is required on these operating systems.</source>
          <target state="translated">Windows 10 및 Windows Server 2016 이전의 Windows 운영 체제에서는 New-SelfSignedCertificate cmdlet이 <bpt id="p1">**</bpt>Type<ept id="p1">**</ept> 매개 변수를 지원하지 않으므로, 이 운영 체제에서는 이 인증서를 만들기 위한 대체 방법이 필요합니다.</target>         
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In this case you can use <ph id="ph1">```makecert.exe```</ph> or <ph id="ph2">```certutil.exe```</ph> to create the certificate.</source>
          <target state="translated">이 경우 <ph id="ph1">```makecert.exe```</ph> 또는 <ph id="ph2">```certutil.exe```</ph>를 사용해 인증서를 만들 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>An alternate method is to <bpt id="p1">[</bpt>download the New-SelfSignedCertificateEx.ps1 script from Microsoft Script Center<ept id="p1">](https://gallery.technet.microsoft.com/scriptcenter/Self-signed-certificate-5920a7c6)</ept> and use it to create the certificate instead:</source>
          <target state="translated">대체 방법은 <bpt id="p1">[</bpt>Microsoft 스크립트 센터에서 New-SelfSignedCertificateEx.ps1 스크립트를 다운로드<ept id="p1">](https://gallery.technet.microsoft.com/scriptcenter/Self-signed-certificate-5920a7c6)</ept>한 후 이를 대신 사용해 인증서를 만드는 것입니다.</target>         
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>On the Target Node: import the cert’s private key as a trusted root</source>
          <target state="translated">대상 노드: 인증서의 개인 키를 신뢰할 수 있는 루트로 가져옵니다.</target>         
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Configuration data</source>
          <target state="translated">구성 데이터</target>         
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The configuration data block defines which target nodes to operate on, whether or not to encrypt the credentials, the means of encryption, and other information.</source>
          <target state="translated">구성 데이터 블록은 자격 증명을 암호화할지 여부, 암호화 방법 및 기타 정보에 대해 작업을 수행할 대상 노드를 정의합니다.</target>         
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For more information on the configuration data block, see <bpt id="p1">[</bpt>Separating Configuration and Environment Data<ept id="p1">](configData.md)</ept>.</source>
          <target state="translated">구성 데이터 블록에 대한 자세한 내용은 <bpt id="p1">[</bpt>분리 및 환경 데이터 구성<ept id="p1">](configData.md)</ept>를 참조합니다.</target>         
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The elements that can be configured for each node that are related to credential encryption are:</source>
          <target state="translated">자격 증명 암호화와 관련된 각 노드에 대해 구성할 수 있는 요소는 다음과 같습니다.</target>         
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>NodeName<ept id="p1">**</ept> - the name of the target node that the credential encryption is being configured for.</source>
          <target state="translated"><bpt id="p1">**</bpt>NodeName<ept id="p1">**</ept> - 자격 증명 암호화가 구성되는 대상 노드의 이름입니다.</target>         
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>PsDscAllowPlainTextPassword<ept id="p1">**</ept> - whether unencrypted credentials will be allowed to be passed to this node.</source>
          <target state="translated"><bpt id="p1">**</bpt>PsDscAllowPlainTextPassword<ept id="p1">**</ept> - 암호화되지 않은 자격 증명을 이 노드로 전달할 수 있는지 여부입니다.</target>         
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This is <bpt id="p1">**</bpt>not recommended<ept id="p1">**</ept>.</source>
          <target state="translated">이 요소는 사용하지 <bpt id="p1">**</bpt>않는 것이 좋습니다<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Thumbprint<ept id="p1">**</ept> - the thumbprint of the certificate that will be used to decrypt the credentials in the DSC Configuration on the <bpt id="p2">_</bpt>Target Node<ept id="p2">_</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Thumbprint<ept id="p1">**</ept> - <bpt id="p2">_</bpt>대상 노드<ept id="p2">_</ept>의 DSC 구성에서 자격 증명의 암호를 해독하는 데 사용되는 인증서의 지문입니다.</target>         
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>This certificate must exist in the Local Machine certificate store on the Target Node.</source>
          <target state="translated">이 인증서는 대상 노드의 로컬 컴퓨터 인증서 저장소에 있어야 합니다.</target>         
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CertificateFile<ept id="p1">**</ept> - the certificate file (containing the public key only) that should be used to encrypt the credentials for the <bpt id="p2">_</bpt>Target Node<ept id="p2">_</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>CertificateFile<ept id="p1">**</ept> - <bpt id="p2">_</bpt>대상 노드<ept id="p2">_</ept>의 인증서를 암호화하는 데 사용할 인증서 파일(공개 키만 포함)입니다.</target>         
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This must be either a DER encoded binary X.509 or Base-64 encoded X.509 format certificate file.</source>
          <target state="translated">DER로 인코딩된 바이너리 X.509 또는 Base-64로 인코딩된 X.509 형식 인증서 파일 중 하나여야 합니다.</target>         
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>This example shows a configuration data block that specifies a target node to act on named targetNode, the path to the public key certificate file (named targetNode.cer), and the thumbprint for the public key.</source>
          <target state="translated">이 예제에서는 명명된 targetNode, 공개 키 인증서 파일 경로(명명된 targetNode.cer) 및 공개 키의 지문에 대해 작업을 수행할 대상 노드를 지정하는 구성 데이터 블록을 보여 줍니다.</target>         
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Configuration script</source>
          <target state="translated">구성 스크립트</target>         
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>In the configuration script itself, use the <ph id="ph1">`PsCredential`</ph> parameter to ensure that credentials are stored for the shortest possible time.</source>
          <target state="translated">구성 스크립트 자체에서 <ph id="ph1">`PsCredential`</ph> 매개 변수를 사용하여 자격 증명이 가능한 가장 짧은 시간 동안 저장되도록 하세요.</target>         
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>When you run the supplied example, DSC will prompt you for credentials and then encrypt the MOF file using the CertificateFile that is associated with the target node in the configuration data block.</source>
          <target state="translated">제공된 예제를 실행하면 DSC에서 자격 증명을 묻는 메시지를 표시한 다음, 구성 데이터 블록의 대상 노드와 연결된 CertificateFile을 사용하여 MOF 파일을 암호화합니다.</target>         
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This code example copies a file from a share that is secured to a user.</source>
          <target state="translated">이 코드 예제에서는 보호되는 공유의 파일을 사용자에게 복사합니다.</target>         
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Setting up decryption</source>
          <target state="translated">암호 해독 설정</target>         
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Before <bpt id="p1">[</bpt><ph id="ph1">`Start-DscConfiguration`</ph><ept id="p1">](https://technet.microsoft.com/en-us/library/dn521623.aspx)</ept> can work, you have to tell the Local Configuration Manager on each target node which certificate to use to decrypt the credentials, using the CertificateID resource to verify the certificate’s thumbprint.</source>
          <target state="translated"><bpt id="p1">[</bpt><ph id="ph1">`Start-DscConfiguration`</ph><ept id="p1">](https://technet.microsoft.com/en-us/library/dn521623.aspx)</ept>이 작동할 수 있도록 하려면 먼저 각 대상 노드의 로컬 구성 관리자에게 인증서의 지문 확인을 위해 CertificateID 리소스를 사용하여 인증서를 해독하는 데 사용할 인증서를 알려줍니다.</target>         
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>This example function will find the appropriate local certificate (you might have to customize it so it will find the exact certificate you want to use):</source>
          <target state="translated">이 예제 함수는 적절한 로컬 인증서를 찾을 것입니다(사용하려는 인증서를 정확히 찾도록 사용자 지정해야 할 수도 있습니다.).</target>         
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>With the certificate identified by its thumbprint, the configuration script can be updated to use the value:</source>
          <target state="translated">지문으로 인증서가 식별되면 해당 값을 사용하도록 구성 스크립트를 업데이트할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Running the configuration</source>
          <target state="translated">구성 실행</target>         
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>At this point, you can run the configuration, which will output two files:</source>
          <target state="translated">이 시점에서 두 개의 파일을 출력하는 구성을 실행할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>.meta.mof file that configures the Local Configuration Manager to decrypt the credentials using the certificate that is stored on the local machine store and identified by its thumbprint. <bpt id="p2">[</bpt><ph id="ph1">`Set-DscLocalConfigurationManager`</ph><ept id="p2">](https://technet.microsoft.com/en-us/library/dn521621.aspx)</ept> applies the <ept id="p1">*</ept>.meta.mof file.</source>
          <target state="translated">로컬 컴퓨터 저장소에 저장되어 있고 지문으로 식별되는 인증서를 사용하여 자격 증명을 해독하도록 로컬 구성 관리자를 구성하는 <bpt id="p1">*</bpt>.meta.mof 파일입니다. <bpt id="p2">[</bpt><ph id="ph1">`Set-DscLocalConfigurationManager`</ph><ept id="p2">](https://technet.microsoft.com/en-us/library/dn521621.aspx)</ept>는 <ept id="p1">*</ept>.meta.mof 파일을 적용합니다.</target>         
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>A MOF file that actually applies the configuration.</source>
          <target state="translated">실제로 구성을 적용하는 MOF 파일.</target>         
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Start-DscConfiguration applies the configuration.</source>
          <target state="translated">Start-DscConfiguration이 구성을 적용합니다.</target>         
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>These commands will accomplish those steps:</source>
          <target state="translated">다음 명령들은 해당 단계를 수행합니다.</target>         
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>This example would push the DSC configuration to the target node.</source>
          <target state="translated">이 예제에서는 대상 노드에 DSC 구성을 밀어넣습니다.</target>         
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The DSC configuration can also be applied using a DSC Pull Server if one is available.</source>
          <target state="translated">DSC 끌어오기 서버를 사용할 수 있는 경우 이 서버를 사용하여 DSC 구성을 적용할 수도 있습니다.</target>         
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Setting up a DSC pull client<ept id="p1">](pullClient.md)</ept> for more information on applying DSC configurations using a DSC Pull Server.</source>
          <target state="translated">DSC 끌어오기 서버를 사용하여 DSC 구성을 적용하는 방법에 대한 자세한 내용은 <bpt id="p1">[</bpt>DSC 끌어오기 클라이언트 설정<ept id="p1">](pullClient.md)</ept>을 참조하세요.</target>         
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Credential Encryption Module Example</source>
          <target state="translated">자격 증명 암호화 모듈 예제</target>         
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Here is a full example that incorporates all of these steps, plus a helper cmdlet that exports and copies the public keys:</source>
          <target state="translated">다음은 이러한 모든 단계와 공개 키를 내보내고 복사하는 도우미 cmdlet을 통합하는 전체 예제입니다.</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>