<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-db30baf" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b91e3bbb40b2b5eddd1e43be568773c850a9b8e0</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wmf\class_newtype.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>New language features in PowerShell 5.0</source>
          <target state="translated">PowerShell 5.0의 새로운 언어 기능</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>PowerShell 5.0 introduces the following new language elements in Windows PowerShell:</source>
          <target state="translated">PowerShell 5.0은 Windows PowerShell에서 다음과 같은 새로운 언어 요소를 소개합니다.</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Class keyword</source>
          <target state="translated">Class 키워드</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>class<ept id="p1">**</ept> keyword defines a new class.</source>
          <target state="translated"><bpt id="p1">**</bpt>class<ept id="p1">**</ept> 키워드는 새 클래스를 정의하며,</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This is a true .NET Framework type.</source>
          <target state="translated">진정한 .NET Framework 형식입니다.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Class members are public, but only public within the module scope.</source>
          <target state="translated">클래스 멤버는 공용이지만 모듈 범위 내에서만 공용입니다.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can't refer to the type name as a string (for example, <ph id="ph1">`New-Object`</ph> doesn't work), and in this release, you can't use a type literal (for example, <ph id="ph2">`[MyClass]`</ph>) outside the script/module file in which the class is defined.</source>
          <target state="translated">형식 이름을 문자열로 참조할 수 없으며(예를 들어 <ph id="ph1">`New-Object`</ph>는 작동하지 않음), 이 릴리스에서는 형식 리터럴(예: 클래스가 정의된 스크립트/모듈 파일 외부의 <ph id="ph2">`[MyClass]`</ph>)을 사용할 수 없습니다.</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Enum keyword and enumerations</source>
          <target state="translated">Enum 키워드 및 열거형</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Support for the <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> keyword has been added, which uses newline as the delimiter.</source>
          <target state="translated"><bpt id="p1">**</bpt>enum<ept id="p1">**</ept> 키워드에 대한 지원이 추가되어 줄 바꿈을 구분 기호로 사용합니다.</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Current limitations: you cannot define an enumerator in terms of itself, but you can initialize an enum in terms of another enum, as shown in the following example.</source>
          <target state="translated">현재 제한 사항: 다음 예제와 같이 열거자 자체와 관련하여 열거자를 정의할 수 없지만 다른 열거형 측면에서 열거형을 초기화할 수는 있습니다.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Also, the base type cannot currently be specified; it is always [int].</source>
          <target state="translated">또한 기본 형식을 현재 지정할 수 없으며, 항상 [int]입니다.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>An enumerator value must be a parse time constant; you cannot set it to the result of an invoked command.</source>
          <target state="translated">열거자 값은 구문 분석 시간 상수여야 하며, 호출된 명령의 결과로 설정할 수 없습니다.</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Enums support arithmetic operations, as shown in the following example.</source>
          <target state="translated">열거형은 다음 예제와 같이 산술 연산자를 지원합니다.</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Import-DscResource</source>
          <target state="translated">Import-DscResource</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Import-DscResource<ept id="p1">**</ept> is now a true dynamic keyword.</source>
          <target state="translated"><bpt id="p1">**</bpt>Import-DscResource<ept id="p1">**</ept>는 이제 진정한 동적 키워드입니다.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>PowerShell parses the specified module’s root module, searching for classes that contain the <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> attribute.</source>
          <target state="translated">PowerShell은 지정된 모듈의 루트 모듈을 구문 분석하여 <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> 특성이 포함된 클래스를 검색합니다.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>ImplementingAssembly</source>
          <target state="translated">ImplementingAssembly</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A new field, <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept>, has been added to ModuleInfo.</source>
          <target state="translated">새 필드인 <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept>가 ModuleInfo에 추가되었습니다.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>It is set to the dynamic assembly created for a script module if the script defines classes, or the loaded assembly for binary modules.</source>
          <target state="translated">이 필드는 스크립트에서 클래스를 정의하는 경우 스크립트 모듈에 대해 만들어진 동적 어셈블리 또는 이진 모듈에 대해 로드된 어셈블리로 설정됩니다.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It is not set when ModuleType = Manifest.</source>
          <target state="translated">ModuleType = Manifest인 경우에는 설정되지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Reflection on the <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept> field discovers resources in a module.</source>
          <target state="translated"><bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept> 필드에서 리플렉션하면 모듈에서 리소스를 검색합니다.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This means you can discover resources written in either PowerShell or other managed languages.</source>
          <target state="translated">즉, PowerShell이나 다른 관리 언어로 작성된 리소스를 검색할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Fields with initializers:</source>
          <target state="translated">이니셜라이저가 있는 필드:</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Static is supported; it works like an attribute, as do the type constraints, so it can be specified in any order.</source>
          <target state="translated">정적 필드가 지원되며 특성처럼 작동합니다. 형식 제약 조건과 마찬가지로 순서대로 지정할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A type is optional.</source>
          <target state="translated">형식은 선택 사항입니다.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>All members are public.</source>
          <target state="translated">모든 멤버는 공용입니다.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Constructors and instantiation</source>
          <target state="translated">생성자 및 인스턴스화</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Windows PowerShell classes can have constructors; they have the same name as their class.</source>
          <target state="translated">Windows PowerShell 클래스에는 생성자가 있을 수 있으며, 이름은 클래스와 동일합니다.</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Constructors can be overloaded.</source>
          <target state="translated">생성자는 오버로드할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Static constructors are supported.</source>
          <target state="translated">정적 생성자가 지원됩니다.</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Properties with initialization expressions are initialized before running any code in a constructor.</source>
          <target state="translated">초기화 식이 있는 속성은 생성자에서 코드를 실행하기 전에 초기화됩니다.</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Static properties are initialized before the body of a static constructor, and instance properties are initialized before the body of the non-static constructor.</source>
          <target state="translated">정적 속성은 정적 생성자의 본문보다 먼저 초기화되고, 인스턴스 속성은 비정적 생성자의 본문보다 먼저 초기화됩니다.</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Currently, there is no syntax for calling a constructor from another constructor (like the C<ph id="ph1">\#</ph> syntax ": this()").</source>
          <target state="translated">현재는 다른 생성자에서 생성자를 호출하는 구문(예: C<ph id="ph1">\#</ph> 구문 ": this()")이 없습니다.</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The workaround is to define a common Init method.</source>
          <target state="translated">해결 방법은 일반적인 Init 메서드를 정의하는 것입니다.</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following are ways of instantiating classes in this release.</source>
          <target state="translated">다음은 이 릴리스에서 클래스를 인스턴스화하는 방법입니다.</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Instantiating by using the default constructor.</source>
          <target state="translated">기본 생성자를 사용하여 인스턴스화합니다.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note that New-Object is not supported in this release.</source>
          <target state="translated">New-Object는 이 릴리스에서 지원되지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Calling a constructor with a parameter</source>
          <target state="translated">매개 변수를 사용하여 생성자를 호출합니다.</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Passing an array to a constructor with multiple parameters</source>
          <target state="translated">매개 변수가 여러 개인 생성자에 배열을 전달합니다.</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In this release, New-Object does not work with classes defined in Windows PowerShell.</source>
          <target state="translated">이 릴리스에서는 New-Object가 Windows PowerShell에 정의된 클래스에서 작동하지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Also for this release, the type name is only visible lexically, meaning it is not visible outside of the module or script that defines the class.</source>
          <target state="translated">또한 이 릴리스의 경우 형식 이름이 어휘적으로만 표시됩니다. 즉, 클래스를 정의하는 모듈이나 스크립트 외부에는 표시되지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Functions can return instances of a class defined in Windows PowerShell, and instances work well outside of the module or script.</source>
          <target state="translated">함수는 Windows PowerShell에 정의된 클래스의 인스턴스를 반환하며 인스턴스는 모듈 또는 스크립트 외부에서 잘 작동합니다.</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>lists constructors, so you can view overloads like any other method.</source>
          <target state="translated">생성자를 나열하므로 다른 모든 메서드처럼 오버로드를 볼 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The performance of this syntax is also considerably faster than New-Object.</source>
          <target state="translated">이 구문의 성능 또한 New-Object보다 현저하게 빠릅니다.</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The pseudo-static method named <bpt id="p1">**</bpt>new<ept id="p1">**</ept> works with .NET types, as shown in the following example.</source>
          <target state="translated"><bpt id="p1">**</bpt>new<ept id="p1">**</ept>라는 의사 정적 메서드는 다음 예제와 같이 .NET 형식에서 작동합니다.</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can now see constructor overloads with Get-Member, or as shown in this example:</source>
          <target state="translated">이제 Get-Member를 사용하거나 다음 예제와 같이 생성자 오버로드를 확인할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">메서드</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A Windows PowerShell class method is implemented as a ScriptBlock that has only an end block.</source>
          <target state="translated">Windows PowerShell 클래스 메서드는 끝 블록만 있는 ScriptBlock으로 구현됩니다.</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>All methods are public.</source>
          <target state="translated">모든 메서드는 공용입니다.</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following shows an example of defining a method named <bpt id="p1">**</bpt>DoSomething<ept id="p1">**</ept>.</source>
          <target state="translated">다음에서는 <bpt id="p1">**</bpt>DoSomething<ept id="p1">**</ept>이라는 메서드를 정의하는 예제를 보여 줍니다.</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Method invocation:</source>
          <target state="translated">메서드 호출:</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Overloaded methods--that is, those that are named the same as an existing method, but differentiated by their specified values--are also supported.</source>
          <target state="translated">오버로드된 메서드 즉, 기존 메서드와 동일하게 이름이 지정되지만 지정된 값으로 구별되는 메서드도 지원됩니다.</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">속성</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>All properties are public.</source>
          <target state="translated">모든 속성은 공용입니다.</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Properties require either a newline or semicolon.</source>
          <target state="translated">속성에는 줄 바꿈이나 세미콜론이 필요합니다.</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If no object type is specified, the property type is object.</source>
          <target state="translated">개체 형식이 지정되지 않은 경우 속성 형식은 개체입니다.</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Properties that use validation attributes or argument transformation attributes (e.g. <ph id="ph1">`[ValidateSet("aaa")]`</ph>) work as expected.</source>
          <target state="translated">유효성 검사 특성이나 인수 변환 특성(예: <ph id="ph1">`[ValidateSet("aaa")]`</ph>)을 사용하는 속성은 예상대로 작동합니다.</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Hidden</source>
          <target state="translated">숨김</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A new keyword, <bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept>, has been added.</source>
          <target state="translated">새로운 키워드 <bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept>이 추가되었습니다.</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept> can be applied to properties and methods (including constructors).</source>
          <target state="translated"><bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept>은 생성자를 비롯하여 속성 및 메서드에 적용할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Hidden members are public, but do not appear in the output of Get-Member unless the -Force parameter is added.</source>
          <target state="translated">숨겨진 멤버는 공용이지만 -Force 매개 변수를 추가하지 않는 한 Get-Member의 출력에 표시되지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Hidden members are not included when tab completing or using Intellisense unless the completion occurs in the class defining the hidden member.</source>
          <target state="translated">탭이 완료되거나 Intellisense를 사용할 때 숨겨진 멤버를 정의하는 클래스에서 완료되지 않으면 숨겨진 멤버가 포함되지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A new attribute, <bpt id="p1">**</bpt>System.Management.Automation.HiddenAttribute<ept id="p1">**</ept> has been added so that C# code can have the same semantics within Windows PowerShell.</source>
          <target state="translated">새로운 특성 <bpt id="p1">**</bpt>System.Management.Automation.HiddenAttribute<ept id="p1">**</ept>가 추가되어 C# 코드가 Windows PowerShell 내에서 동일한 의미 체계를 가질 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Return types</source>
          <target state="translated">반환 형식</target>         
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Return type is a contract; the return value is converted to the expected type.</source>
          <target state="translated">반환 형식은 계약이며, 반환 값은 필요한 형식으로 변환됩니다.</target>         
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If no return type is specified, the return type is void.</source>
          <target state="translated">반환 형식이 지정되지 않은 경우 반환 형식은 void입니다.</target>         
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>There is no streaming of objects; objects cannot be written to the pipeline either intentionally or by accident.</source>
          <target state="translated">개체의 스트리밍이 없으며 의도적으로 또는 실수로 개체를 파이프라인에 쓸 수 없습니다.</target>         
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">특성</target>         
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Two new attributes, <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> and <bpt id="p2">**</bpt>DscProperty<ept id="p2">**</ept> have been added.</source>
          <target state="translated">두 개의 새로운 특성 <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> 및 <bpt id="p2">**</bpt>DscProperty<ept id="p2">**</ept>가 추가되었습니다.</target>         
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Lexical scoping of variables</source>
          <target state="translated">변수의 어휘 범위 지정</target>         
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The following shows an example of how lexical scoping works in this release.</source>
          <target state="translated">다음에서는 이 릴리스에서 어휘 범위 지정이 작동하는 방식에 대한 예를 보여 줍니다.</target>         
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>End-to-End Example</source>
          <target state="translated">종단 간 예제</target>         
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The following example creates several new, custom classes to implement an HTML dynamic style sheet language (DSL).</source>
          <target state="translated">다음 예제에서는 여러 가지 새로운 사용자 지정 클래스를 만들어 HTML DSL(동적 스타일시트 언어)을 구현합니다.</target>         
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Then, the example adds helper functions to create specific element types as part of the element class, such as heading styles and tables, because types cannot be used outside the scope of a module.</source>
          <target state="translated">그런 다음 예제에서는 모듈의 범위 외부에서 형식을 사용할 수 없기 때문에 도우미 함수를 추가하여 요소 클래스의 일부로 제목 스타일 및 표와 같은 특정 요소 형식을 만듭니다.</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>