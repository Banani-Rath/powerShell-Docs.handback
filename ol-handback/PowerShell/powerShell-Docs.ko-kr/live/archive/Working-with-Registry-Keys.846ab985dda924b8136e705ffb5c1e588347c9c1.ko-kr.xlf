<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="ko-kr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">23fac6bfaed34ee45e12e630b8e9adbce471b5b3</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04046aa" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Working with Registry Keys</source>
          <target state="translated">레지스트리 키 작업</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Working with Registry Keys</source>
          <target state="translated">레지스트리 키 작업</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Because registry keys are items on Windows PowerShell drives, working with them is very similar to working with files and folders.</source>
          <target state="translated">레지스트리 키는 Windows PowerShell 드라이브에 있는 항목이므로 레지스트리 키에 대한 작업 수행은 파일 및 폴더 작업과 매우 유사합니다.</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>One critical difference is that every item on a registry\-based Windows PowerShell drive is a container, just like a folder on a file system drive.</source>
          <target state="translated">한 가지 중요한 차이점은 레지스트리 기반 Windows PowerShell 드라이브의 모든 항목은 파일 시스템 드라이브의 폴더와 같이 컨테이너라는 점입니다.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>However, registry entries and their associated values are properties of the items, not distinct items.</source>
          <target state="translated">그러나 레지스트리 항목 및 연결된 값은 고유한 항목이 아니라 항목의 속성입니다.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Listing All Subkeys of a Registry Key</source>
          <target state="translated">레지스트리 키의 모든 하위 키 표시</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can show all items directly within a registry key by using <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept>을 사용하여 레지스트리 키 바로 아래에 있는 항목을 모두 볼 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Add the optional <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> parameter to display hidden or system items.</source>
          <target state="translated">선택적 <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> 매개 변수를 추가하면 숨겨진 항목이나 시스템 항목을 볼 수도 있습니다.</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For example, this command displays the items directly within Windows PowerShell drive HKCU:, which corresponds to the HKEY\_CURRENT\_USER registry hive:</source>
          <target state="translated">예를 들어 다음 명령은 HKEY\_CURRENT\_USER 레지스트리 하이브에 해당하는 Windows PowerShell 드라이브 HKCU: 바로 아래에 있는 항목을 보여 줍니다.</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>These are the top\-level keys visible under HKEY\_CURRENT\_USER in the Registry Editor (Regedit.exe).</source>
          <target state="translated">이러한 키는 레지스트리 편집기(Regedit.exe)의 HKEY\_CURRENT\_USER에 표시되는 최상위 키입니다.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can also specify this registry path by specifying the registry provider's name, followed by "<bpt id="p1">**</bpt>::<ept id="p1">**</ept>".</source>
          <target state="translated">레지스트리 공급자 이름(뒤에 "<bpt id="p1">**</bpt>::<ept id="p1">**</ept>"이 옴)을 지정하여 레지스트리 경로를 지정할 수도 있습니다.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The registry provider's full name is <bpt id="p1">**</bpt>Microsoft.PowerShell.Core\\Registry<ept id="p1">**</ept>, but this can be shortened to just <bpt id="p2">**</bpt>Registry<ept id="p2">**</ept>.</source>
          <target state="translated">레지스트리 공급자의 전체 이름은 <bpt id="p1">**</bpt>Microsoft.PowerShell.Core\\Registry<ept id="p1">**</ept>이지만 <bpt id="p2">**</bpt>Registry<ept id="p2">**</ept>로 줄일 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Any of the following commands will list the contents directly under HKCU:</source>
          <target state="translated">다음 명령은 HKCU: 바로 아래에 있는 내용을 보여 줍니다.</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>These commands list only the directly contained items, much like using Cmd.exe's <bpt id="p1">**</bpt>DIR<ept id="p1">**</ept> command or <bpt id="p2">**</bpt>ls<ept id="p2">**</ept> in a UNIX shell.</source>
          <target state="translated">이 명령은 Cmd.exe의 <bpt id="p1">**</bpt>DIR<ept id="p1">**</ept> 명령이나 UNIX 셸의 <bpt id="p2">**</bpt>ls<ept id="p2">**</ept>를 사용하는 것과 매우 유사한 방법으로 바로 아래에 포함된 항목만 보여 줍니다.</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>To show contained items, you need to specify the <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> parameter.</source>
          <target state="translated">포함된 항목을 모두 보려면 <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> 매개 변수를 지정해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>To list all registry keys in HKCU, use the following command (This operation can take an extremely long time.):</source>
          <target state="translated">HKCU에 있는 모든 레지스트리 키를 보려면 다음 명령을 사용합니다. 이 작업은 완료하는 데 시간이 많이 걸릴 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> can perform complex filtering capabilities through its <bpt id="p2">**</bpt>Path<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Filter<ept id="p3">**</ept>, <bpt id="p4">**</bpt>Include<ept id="p4">**</ept>, and <bpt id="p5">**</bpt>Exclude<ept id="p5">**</ept> parameters, but those parameters are typically based only on name.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept>은 <bpt id="p2">**</bpt>Path<ept id="p2">**</ept>, <bpt id="p3">**</bpt>Filter<ept id="p3">**</ept>, <bpt id="p4">**</bpt>Include<ept id="p4">**</ept> 및 <bpt id="p5">**</bpt>Exclude<ept id="p5">**</ept> 매개 변수로 복잡한 필터링 기능을 수행할 수 있지만 이러한 변수는 일반적으로 이름을 기반으로 합니다.</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can perform complex filtering based on other properties of items by using the <bpt id="p1">**</bpt>Where\-Object<ept id="p1">**</ept>cmdlet.</source>
          <target state="translated"><bpt id="p1">**</bpt>Where\-Object<ept id="p1">**</ept> cmdlet을 사용하여 항목의 다른 속성을 기반으로 복잡한 필터링을 수행할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following command finds all keys within HKCU:\\Software that have no more than one subkey and also have exactly four values:</source>
          <target state="translated">다음 명령은 HKCU:\\Software 내에서 정확히 한 개의 하위 키와 네 개의 값을 갖는 모든 키를 찾습니다.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Copying Keys</source>
          <target state="translated">키 복사</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Copying is done with <bpt id="p1">**</bpt>Copy\-Item<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Copy\-Item<ept id="p1">**</ept>을 사용하여 복사를 수행합니다.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The following command copies HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion and all of its properties to HKCU:\\, creating a new key named "CurrentVersion":</source>
          <target state="translated">다음 명령은 "CurrentVersion"라는 새 키를 만들 때 HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion 및 모든 속성을 HKCU:\\에 복사합니다.</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>If you examine this new key in the registry editor or by using <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept>, you will notice that you do not have copies of the contained subkeys in the new location.</source>
          <target state="translated">레지스트리 편집기나 <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept>을 사용하여 새 키를 검사하면 포함된 하위 키가 새 위치에 복사되지 않은 것을 확인할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In order to copy all of the contents of a container, you need to specify the <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> parameter.</source>
          <target state="translated">컨테이너의 내용을 모두 복사하려면 <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> 매개 변수를 지정해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>To make the preceding copy command recursive, you would use this command:</source>
          <target state="translated">위의 복사 명령을 재귀적으로 실행하려면 다음 명령을 사용합니다.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can still use other tools you already have available to perform filesystem copies.</source>
          <target state="translated">파일 시스템 복사를 위해 이전부터 사용하던 다른 도구를 계속 사용할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Any registry editing tools—including reg.exe, regini.exe, and regedit.exe—and COM objects that support registry editing (such as WScript.Shell and WMI's StdRegProv class) can be used from within Windows PowerShell.</source>
          <target state="translated">예를 들어 reg.exe, regini.exe 및 regedit.exe 같은 레지스트리 편집 도구와 WScript.Shell 및 WMI의 StdRegProv 클래스와 같이 레지스트리 편집을 지원하는 COM 개체를 Windows PowerShell에서 사용할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Creating Keys</source>
          <target state="translated">키 만들기</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Creating new keys in the registry is simpler than creating a new item in a file system.</source>
          <target state="translated">레지스트리에서 새 키를 만드는 것은 파일 시스템에서 새 항목을 만드는 것보다 간단합니다.</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Because all registry keys are containers, you do not need to specify the item type; you simply supply an explicit path, such as:</source>
          <target state="translated">모든 레지스트리 키가 컨테이너이므로 항목 유형을 지정할 필요 없이 다음과 같이 명시적 경로만 지정하면 됩니다.</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You can also use a provider\-based path to specify a key:</source>
          <target state="translated">다음과 같이 공급자 기반 경로를 사용하여 키를 지정할 수도 있습니다.</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Deleting Keys</source>
          <target state="translated">키 삭제</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Deleting items is essentially the same for all providers.</source>
          <target state="translated">기본적으로 항목 삭제는 모든 공급자에 대해 동일하게 수행됩니다.</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The following commands will silently remove items:</source>
          <target state="translated">다음 명령은 항목을 제거합니다.</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Removing All Keys Under a Specific Key</source>
          <target state="translated">특정 키 아래에 있는 모든 키 제거</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can remove contained items by using <bpt id="p1">**</bpt>Remove\-Item<ept id="p1">**</ept>, but you will be prompted to confirm the removal if the item contains anything else.</source>
          <target state="translated"><bpt id="p1">**</bpt>Remove\-Item<ept id="p1">**</ept>을 사용하면 포함된 항목을 제거할 수 있지만 이 항목에 다른 항목이 들어 있는 경우 제거를 확인하는 메시지가 나타납니다.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For example, if we attempt to delete the HKCU:\\CurrentVersion subkey we created, we see this:</source>
          <target state="translated">예를 들어 앞에서 만든 HKCU:\\CurrentVersion 하위 키를 삭제하려고 하면 다음과 같은 메시지가 나타납니다.</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>To delete contained items without prompting, specify the <bpt id="p1">**</bpt>\-Recurse<ept id="p1">**</ept> parameter:</source>
          <target state="translated">확인 메시지 없이 포함된 항목을 삭제하려면 다음과 같이 <bpt id="p1">**</bpt>\-Recurse<ept id="p1">**</ept> 매개 변수를 지정합니다.</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If you wanted to remove all items within HKCU:\\CurrentVersion but not HKCU:\\CurrentVersion itself, you could instead use:</source>
          <target state="translated">또한 HKCU:\\CurrentVersion은 제거하지 않고 HKCU:\\CurrentVersion 안에 들어 있는 항목만 모두 제거하려면 다음 명령을 사용하면 됩니다.</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>