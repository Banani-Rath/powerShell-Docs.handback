<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Removing-Objects-from-the-Pipeline--Where-Object-.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0c5e2b60d96a6c64aedfa9522cbdc0ce5d4aa6b0</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-39517ae" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Removing Objects from the Pipeline  Where Object</source>
          <target state="translated">파이프라인에서 개체 제거(Where-Object)</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Removing Objects from the Pipeline (Where-Object)</source>
          <target state="translated">파이프라인에서 개체 제거(Where-Object)</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, you often generate and pass along more objects to a pipeline than you want.</source>
          <target state="translated">일반적으로 Windows PowerShell은 필요한 것보다 많은 개체를 만들어 파이프라인에 전달합니다.</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>You can specify the properties of particular objects to display by using the <bpt id="p1">**</bpt>Format<ept id="p1">**</ept> cmdlets, but this does not help with the problem of removing entire objects from the display.</source>
          <target state="translated"><bpt id="p1">**</bpt>Format<ept id="p1">**</ept> cmdlet을 사용하면 표시할 특정 개체의 속성을 지정할 수 있지만 전체 개체를 표시하지 않는 문제에는 도움이 되지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You may want to filter objects before the end of a pipeline, so you can perform actions on only a subset of the initially\-generated objects.</source>
          <target state="translated">파이프라인 끝에 도달하기 전에 개체를 필터링하여 처음 만들어진 개체의 하위 집합에 대해서만 특정 작업을 수행할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Windows PowerShell includes a <bpt id="p1">**</bpt>Where\-Object<ept id="p1">**</ept> cmdlet that allows you to test each object in the pipeline and only pass it along the pipeline if it meets a particular test condition.</source>
          <target state="translated">Windows PowerShell에는 파이프라인에 있는 각 개체를 테스트하고 특정 테스트 조건을 통과하는 개체만 파이프라인을 통해 전달할 수 있는 <bpt id="p1">**</bpt>Where\-Object<ept id="p1">**</ept> cmdlet이 포함되어 있습니다.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Objects that do not pass the test are removed from the pipeline.</source>
          <target state="translated">테스트를 통과하지 못한 개체는 파이프라인에서 제거됩니다.</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You supply the test condition as the value of the <bpt id="p1">**</bpt>Where\-ObjectFilterScript<ept id="p1">**</ept> parameter.</source>
          <target state="translated">테스트 조건은 <bpt id="p1">**</bpt>Where\-ObjectFilterScript<ept id="p1">**</ept> 매개 변수의 값으로 지정됩니다.</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Performing Simple Tests with Where\-Object</source>
          <target state="translated">Where\-Object를 사용하여 간단한 테스트 수행</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">**</bpt>FilterScript<ept id="p1">**</ept> is a <bpt id="p2">*</bpt>script block<ept id="p2">*</ept> \-  one or more Windows PowerShell commands surrounded by braces {} \- that evaluates to true or false.</source>
          <target state="translated"><bpt id="p1">**</bpt>FilterScript<ept id="p1">**</ept>의 값은 하나의 <bpt id="p2">*</bpt>스크립트 블록<ept id="p2">*</ept>으로, true 또는 false로 평가되는 하나 이상의 Windows PowerShell 명령이 중괄호({})로 묶여 있습니다.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>These script blocks can be very simple, but creating them requires knowing about another Windows PowerShell concept, comparison operators.</source>
          <target state="translated">이러한 스크립트 블록은 매우 간단할 수 있지만 비교 연산자와 같은 다른 Windows PowerShell 개념을 알고 있어야 만들 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A comparison operator compares the items that appear on each side of it.</source>
          <target state="translated">비교 연산자는 자신을 중심으로 양쪽에 표시되는 두 항목을 비교합니다.</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Comparison operators begin with a '\-' character and are followed by a name.</source>
          <target state="translated">비교 연산자의 이름은 '\-' 문자로 시작됩니다.</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Basic comparison operators work on almost any kind of object.</source>
          <target state="translated">기본 비교 연산자는 거의 모든 유형의 개체에서 작동하지만</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The more advanced comparison operators might only work on text or arrays.</source>
          <target state="translated">고급 비교 연산자는 텍스트나 배열에서만 작동할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!NOTE]</ph> By default, when working with text, Windows PowerShell comparison operators are case\-insensitive.</source>
          <target state="translated"><ph id="ph1">[!NOTE]</ph> 기본적으로 Windows PowerShell 비교 연산자는 텍스트를 비교할 때 대/소문자를 구분합니다.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Due to parsing considerations, symbols such as &lt;,&gt;, and \= are not used as comparison operators.</source>
          <target state="translated">구문 오류가 발생할 수 있으므로 &lt;, &gt;, \= 등의 기호는 비교 연산자로 사용할 수 없고</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Instead, comparison operators are comprised of letters.</source>
          <target state="translated">문자만 비교 연산자로 사용할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The basic comparison operators are listed in the following table.</source>
          <target state="translated">다음 표에는 기본 비교 연산자가 나와 있습니다.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Comparison Operator</source>
          <target state="translated">비교 연산자</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">의미</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Example (returns true)</source>
          <target state="translated">예제(true 반환)</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>\-eq</source>
          <target state="translated">\-eq</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>is equal to</source>
          <target state="translated">같음</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>1 \-eq 1</source>
          <target state="translated">1 \-eq 1</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>\-ne</source>
          <target state="translated">\-ne</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Is not equal to</source>
          <target state="translated">같지 않음</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>1 \-ne 2</source>
          <target state="translated">1 \-ne 2</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>\-lt</source>
          <target state="translated">\-lt</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Is less than</source>
          <target state="translated">보다 작음</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>1 \-lt 2</source>
          <target state="translated">1 \-lt 2</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>\-le</source>
          <target state="translated">\-le</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Is less than or equal to</source>
          <target state="translated">작거나 같음</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>1 \-le 2</source>
          <target state="translated">1 \-le 2</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>\-gt</source>
          <target state="translated">\-gt</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Is greater than</source>
          <target state="translated">보다 큼</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>2 \-gt 1</source>
          <target state="translated">2 \-gt 1</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>\-ge</source>
          <target state="translated">\-ge</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Is greater than or equal to</source>
          <target state="translated">크거나 같음</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>2 \-ge 1</source>
          <target state="translated">2 \-ge 1</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>\-like</source>
          <target state="translated">\-like</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Is like (wildcard comparison for text)</source>
          <target state="translated">비슷함(텍스트의 와일드카드 비교)</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>"file.doc" \-like "f\*.do?"</source>
          <target state="translated">"file.doc" \-like "f\*.do?"</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>\-notlike</source>
          <target state="translated">\-notlike</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Is not like (wildcard comparison for text)</source>
          <target state="translated">비슷하지 않음(텍스트의 와일드카드 비교)</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>"file.doc" \-notlike "p\*.doc"</source>
          <target state="translated">"file.doc" \-notlike "p\*.doc"</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>\-contains</source>
          <target state="translated">\-contains</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="translated">포함</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>1,2,3 \-contains 1</source>
          <target state="translated">1,2,3 \-contains 1</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>\-notcontains</source>
          <target state="translated">\-notcontains</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Does not contain</source>
          <target state="translated">포함 안 함</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>1,2,3 \-notcontains 4</source>
          <target state="translated">1,2,3 \-notcontains 4</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Where\-Object script blocks use the special variable '$\_' to refer to the current object in the pipeline.</source>
          <target state="translated">스크립트 블록은 특수 변수 '$\_'를 사용하여 파이프라인에 있는 현재 개체를 참조합니다.</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Here is an example of how it works.</source>
          <target state="translated">다음은 이러한 동작을 보여 주는 예제입니다.</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you have a list of numbers, and only want to return the ones that are less than 3, you can use Where\-Object to filter the numbers by typing:</source>
          <target state="translated">일련의 숫자 중에서 3보다 작은 숫자만 반환하려면 다음과 같이 Where\-Object를 사용하여 숫자를 필터링하면 됩니다.</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Filtering Based on Object Properties</source>
          <target state="translated">개체 속성을 기반으로 필터링</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Since $\_ refers to the current pipeline object, we can access its properties for our tests.</source>
          <target state="translated">$\_가 현재 파이프라인 개체를 참조하므로 테스트를 위해 이 개체의 속성에 액세스할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>As an example, we can look at the Win32\_SystemDriver class in WMI.</source>
          <target state="translated">예를 들어WMI에서 Win32_SystemDriver 클래스를 살펴보면</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>There might be hundreds of system drivers on a particular system, but you might only be interested in a particular set of the system drivers, such as those which are currently running.</source>
          <target state="translated">특정 시스템에 수백 개의 시스템 드라이버가 있을 수 있지만 현재 실행 중인 드라이버와 같은 특정 시스템 드라이버 집합만 사용할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If you use Get\-Member to view Win32\_SystemDriver members (<bpt id="p1">**</bpt>Get\-WmiObject \-Class Win32\_SystemDriver | Get\-Member \-MemberType Property<ept id="p1">**</ept>) you will see that the relevant property is State, and that it has a value of "Running" when the driver is running.</source>
          <target state="translated">Get\-Member를 사용하여 Win32_SystemDriver 멤버(<bpt id="p1">**</bpt>Get\-WmiObject \-Class Win32\_SystemDriver | Get\-Member \-MemberType Property<ept id="p1">**</ept>)를 보면 관련 속성이 State이고 드라이버가 실행 중일 때 해당 값이 "Running"인 것을 확인할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can filter the system drivers, selecting only the running ones by typing:</source>
          <target state="translated">다음과 같이 입력하면 시스템 드라이버를 필터링하여 실행 중인 드라이버만 선택할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This still produces a long list.</source>
          <target state="translated">그러나 이 목록에는 아직도 필요한 것보다 많은 항목이 포함되어 있으므로</target>         
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You may want to filter to only select the drivers set to start automatically by testing the StartMode value as well:</source>
          <target state="translated">다음과 같이 StartMode 값도 테스트하여 자동으로 시작되도록 설정된 드라이버만 선택하도록 필터링할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This gives us a lot of information we no longer need because we know that the drivers are running.</source>
          <target state="translated">드라이버가 실행 중이라는 것을 앞에서 확인했기 때문에 이 목록에는 아직도 불필요한 정보가 포함되어 있습니다.</target>         
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In fact, the only information we probably need at this point are the name and the display name.</source>
          <target state="translated">사실 이 시점에서 필요한 정보는 이름과 표시 이름뿐입니다.</target>         
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The following command includes only those two properties, resulting in much simpler output:</source>
          <target state="translated">다음 명령은 목록에 이러한 두 속성만 포함하여 출력을 훨씬 더 간단하게 만듭니다.</target>         
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>There are two Where\-Object elements in the above command, but they can be expressed in a single Where\-Object element by using the \-and logical operator, like this:</source>
          <target state="translated">위의 명령에는 두 개의 요소가 있지만 다음과 같이 \-and 논리 연산자를 사용하면 단일 Where\-Object 요소로 표시할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The standard logical operators are listed in the following table.</source>
          <target state="translated">다음 표에는 기본 논리 연산자가 나와 있습니다.</target>         
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Logical Operator</source>
          <target state="translated">논리 연산자</target>         
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">의미</target>         
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Example (returns true)</source>
          <target state="translated">예제(true 반환)</target>         
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>\-and</source>
          <target state="translated">\-and</target>         
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Logical and; true if both sides are true</source>
          <target state="translated">논리곱(둘 다 true일 경우 true임)</target>         
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>(1 \-eq 1) \-and (2 \-eq 2)</source>
          <target state="translated">(1 \-eq 1) \-and (2 \-eq 2)</target>         
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>\-or</source>
          <target state="translated">\-or</target>         
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Logical or; true if either side is true</source>
          <target state="translated">논리합(둘 중 하나만 true여도 true임)</target>         
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>(1 \-eq 1) \-or (1 \-eq 2)</source>
          <target state="translated">(1 \-eq 1) \-or (1 \-eq 2)</target>         
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>\-not</source>
          <target state="translated">\-not</target>         
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Logical not; reverses true and false</source>
          <target state="translated">논리 부정(true와 false를 반대로 바꿈)</target>         
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>\-not (1 \-eq 2)</source>
          <target state="translated">\-not (1 \-eq 2)</target>         
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>\!</source>
          <target state="translated">\!</target>         
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Logical not; reverses true and false</source>
          <target state="translated">논리 부정(true와 false를 반대로 바꿈)</target>         
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>\!(1 \-eq 2)</source>
          <target state="translated">\!(1 \-eq 2)</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>