<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">076d5b53801a066ecd4910aaae05ce4d69fb8382</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\ForEach-Object.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">979a1b4951aab29ab968a16f5844f6519ed93a02</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e1b94049ce73f84d2409be9e9f0eb413460e70c5</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>ForEach-Object</source>
          <target state="translated">ForEach-Object</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>ForEach-Object</source>
          <target state="translated">ForEach-Object</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>SYNOPSIS</source>
          <target state="translated">요약</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Performs an operation against each item in a collection of input objects.</source>
          <target state="translated">입력 개체 컬렉션에 있는 각 항목에 대해 작업을 수행합니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SYNTAX</source>
          <target state="translated">구문</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ScriptBlockSet (Default)</source>
          <target state="translated">ScriptBlockSet (기본값)</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>PropertyAndMethodSet</source>
          <target state="translated">PropertyAndMethodSet</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>DESCRIPTION</source>
          <target state="translated">설명</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet performs an operation on each item in a collection of input objects.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet 입력된 개체의 컬렉션에 있는 각 항목에 대 한 작업을 수행 합니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The input objects can be piped to the cmdlet or specified by using the InputObject parameter.</source>
          <target state="translated">입력 개체를 cmdlet으로 파이프하거나 InputObject 매개 변수를 사용하여 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, there are two different ways to construct a <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> command.</source>
          <target state="translated">Windows PowerShell 3.0부터, 두 가지가 서로 다른 생성 하는 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 명령입니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Script block<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>스크립트 블록<ept id="p1">**</ept>합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can use a script block to specify the operation.</source>
          <target state="translated">스크립트 블록을 사용하여 작업을 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Within the script block, use the $_ variable to represent the current object.</source>
          <target state="translated">스크립트 블록 내에서 $_ 변수를 사용하여 현재 개체를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The script block is the value of the <bpt id="p1">**</bpt>Process<ept id="p1">**</ept> parameter.</source>
          <target state="translated">스크립트 블록의 값은는 <bpt id="p1">**</bpt>프로세스<ept id="p1">**</ept> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The script block can contain any Windows PowerShell script.</source>
          <target state="translated">스크립트 블록에는 모든 Windows PowerShell 스크립트가 포함될 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the value of the <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> property of each process on the computer.</source>
          <target state="translated">예를 들어 다음 명령은의 값을 가져옵니다는 <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> 컴퓨터에 있는 각 프로세스의 속성입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Operation statement<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>작업 문을<ept id="p1">**</ept>합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You can also write a operation statement, which is much more like natural language.</source>
          <target state="translated">자연어와 유사한 작업 문을 작성할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can use the operation statement to specify a property value or call a method.</source>
          <target state="translated">작업 문을 사용하여 속성 값을 지정하거나 메서드를 호출할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Operation statements were introduced in Windows PowerShell 3.0.</source>
          <target state="translated">작업 문은 Windows PowerShell 3.0에서 도입되었습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For example, the following command also gets the value of the <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> property of each process on the computer.</source>
          <target state="translated">예를 들어 다음 명령은의 값을도 가져옵니다는 <bpt id="p1">**</bpt>ProcessName<ept id="p1">**</ept> 컴퓨터에 있는 각 프로세스의 속성입니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When using the script block format, in addition to using the script block that describes the operations that are performed on each input object, you can provide two additional script blocks.</source>
          <target state="translated">스크립트 블록 형식을 사용할 경우 각 입력 개체에 대해 수행되는 작업을 설명하는 스크립트 블록을 사용하는 것 외에 추가 스크립트 블록 두 개를 제공할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The Begin script block, which is the value of the <bpt id="p1">**</bpt>Begin<ept id="p1">**</ept> parameter, runs before the first input object is processed.</source>
          <target state="translated">Begin 스크립트 블록 값인의 <bpt id="p1">**</bpt>시작<ept id="p1">**</ept> 첫 번째 입력된 개체를 처리 하기 전에 매개 변수를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The End script block, which is the value of the <bpt id="p1">**</bpt>End<ept id="p1">**</ept> parameter, runs after the last input object is processed.</source>
          <target state="translated">End 스크립트 블록 값인의 <bpt id="p1">**</bpt>끝<ept id="p1">**</ept> 마지막 입력된 개체가 처리 된 후 매개 변수를 실행 합니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">예제</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 1 --------------------------</source>
          <target state="translated">-------------------------- 예제 1 --------------------------</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>This command takes an array of three integers and divides each one of them by 1024.</source>
          <target state="translated">이 명령은 정수 3개의 배열을 사용하고 각 정수를 1024로 나눕니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 2 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 2 --------------------------</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This command gets the files and directories in the Windows PowerShell installation directory ($pshome) and passes them to the ForEach-Object cmdlet.</source>
          <target state="translated">이 명령은 Windows PowerShell 설치 디렉터리($pshome)에 있는 파일과 디렉터리를 가져온 다음 ForEach-Object cmdlet으로 전달합니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If the object is not a directory (the value of the PSISContainer property is false), the script block gets the name of the file, divides the value of its Length property by 1024, and adds a space ("") to separate it from the next entry.</source>
          <target state="translated">개체가 디렉터리가 아닌 경우(PSISContainer 속성 값이 false임) 스크립트 블록은 파일 이름을 가져와 Length 속성 값을 1024로 나눈 다음 공백("")을 추가하여 다음 항목과 구분합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 3 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 3 --------------------------</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This command gets the 1000 most recent events from the System event log and stores them in the $Events variable.</source>
          <target state="translated">이 명령은 시스템 이벤트 로그에서 최근 이벤트 1000개를 가져와 $Events 변수에 저장한 다음</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>It then pipes the events to the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">이벤트를 파이프는 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet입니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Begin<ept id="p1">**</ept> parameter displays the current date and time.</source>
          <target state="translated"> <bpt id="p1">**</bpt>시작<ept id="p1">**</ept> 매개 변수는 현재 날짜 및 시간을 표시 합니다.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Next, the <bpt id="p1">**</bpt>Process<ept id="p1">**</ept> parameter uses the <bpt id="p2">**</bpt>Out-File<ept id="p2">**</ept> cmdlet to create a text file named events.txt and stores the message property of each of the events in that file.</source>
          <target state="translated">다음으로 <bpt id="p1">**</bpt>프로세스<ept id="p1">**</ept> 매개 변수를 사용 하 여는 <bpt id="p2">**</bpt>Out-file<ept id="p2">**</ept> 텍스트 파일을 만들려면이 cmdlet에서 events.txt 라는 파일에 각 이벤트의 메시지 속성을 저장 합니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Last, the <bpt id="p1">**</bpt>End<ept id="p1">**</ept> parameter is used to display the date and time after all of the processing has completed.</source>
          <target state="translated">마지막으로는 <bpt id="p1">**</bpt>끝<ept id="p1">**</ept> 매개 변수를 사용 하 여 날짜를 표시 하 고 시간 모든 처리가 완료 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 4 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 4 --------------------------</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This command changes the value of the <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> registry entry in all of the subkeys under the HKCU:\Network key to uppercase text.</source>
          <target state="translated">이 명령은의 값이 변경 된 <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> 모든 텍스트를 대문자로 hkcu: \network 키 아래의 하위 키의 레지스트리 항목입니다.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>You can use this format to change the form or content of a registry entry value.</source>
          <target state="translated">이 형식을 사용하여 레지스트리 항목 값의 형식이나 내용을 변경할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Each subkey in the <bpt id="p1">**</bpt>Network<ept id="p1">**</ept> key represents a mapped network drive that will reconnect at logon.</source>
          <target state="translated">각 하위 키에는 <bpt id="p1">**</bpt>네트워크<ept id="p1">**</ept> 키는 로그온 시 다시 연결할 매핑된 네트워크 드라이브를 나타냅니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> entry contains the UNC path of the connected drive.</source>
          <target state="translated"> <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> 는 연결 된 드라이브의 UNC 경로 포함 하는 항목입니다.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>For example, if you map the E: drive to <ph id="ph1">\\\\</ph>Server\Share, there will be an E subkey of HKCU:\Network and the value of the <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> registry entry in the E subkey will be <ph id="ph2">\\\\</ph>Server\Share.</source>
          <target state="translated">예를 들어 e: 드라이브를 매핑하는 경우 <ph id="ph1">\\\\</ph>느릴, 생깁니다 hkcu: \network의 E 하위는 및의 값은 <bpt id="p1">**</bpt>RemotePath<ept id="p1">**</ept> E 하위 키에서 레지스트리 항목이 됩니다 <ph id="ph2">\\\\</ph>느릴 합니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The command uses the Get-ItemProperty cmdlet to get all of the subkeys of the <bpt id="p1">**</bpt>Network<ept id="p1">**</ept> key and the Set-ItemProperty cmdlet to change the value of the <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> registry entry in each key.</source>
          <target state="translated">이 명령은 Get-itemproperty cmdlet를 사용 하 여 모든의 하위 키를 얻습니다는 <bpt id="p1">**</bpt>네트워크<ept id="p1">**</ept> 키와 값을 변경 하려면 Set-itemproperty cmdlet는 <bpt id="p2">**</bpt>RemotePath<ept id="p2">**</ept> 각 키의 레지스트리 항목입니다.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Set-ItemProperty<ept id="p1">**</ept> command, the path is the value of the <bpt id="p2">**</bpt>PSPath<ept id="p2">**</ept> property of the registry key.</source>
          <target state="translated">에 <bpt id="p1">**</bpt>Set-itemproperty<ept id="p1">**</ept> 명령, 경로 값은 <bpt id="p2">**</bpt>PSPath<ept id="p2">**</ept> 레지스트리 키의 속성입니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>(This is a property of the Microsoft .NET Framework object that represents the registry key; it is not a registry entry.) The command uses the ToUpper() method of the RemotePath value, which is a string (REG_SZ).</source>
          <target state="translated">이 값은 레지스트리 항목이 아니라 레지스트리 키를 나타내는 Microsoft .NET Framework 개체의 속성입니다. 또한 문자열(REG_SZ)인 RemotePath 값의 ToUpper() 메서드를 사용합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Because <bpt id="p1">**</bpt>Set-ItemProperty<ept id="p1">**</ept> is changing the property of each key, the <bpt id="p2">**</bpt>ForEach-Object<ept id="p2">**</ept> cmdlet is required to access the property.</source>
          <target state="translated">때문에 <bpt id="p1">**</bpt>Set-itemproperty<ept id="p1">**</ept> 각 키의 속성이 변경 되는 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> cmdlet은 속성에 액세스 해야 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 5 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 5 --------------------------</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This example shows the effect of piping the $null automatic variable to the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">$Null 자동 변수를 파이프의 효과 보여 주는이 예제는 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet입니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Because Windows PowerShell treats null as an explicit placeholder, the <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet generates a value for $null, just as it does for other objects that you pipe to it.</source>
          <target state="translated">Windows PowerShell에서 null을 명시적 자리 표시자로 처리 하기 때문에 <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet에 파이프 하는 다른 개체와 마찬가지로 $null에 대 한 값을 생성 합니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For more information about the $null automatic variable, see about_Automatic_Variables.</source>
          <target state="translated">$null 자동 변수에 대한 자세한 내용은 about_Automatic_Variables를 참조하세요.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 6 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 6 --------------------------</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>These commands gets the value of the <bpt id="p1">**</bpt>Path<ept id="p1">**</ept> property of all installed Windows PowerShell modules.</source>
          <target state="translated">이러한 명령은의 값을 가져옵니다는 <bpt id="p1">**</bpt>경로<ept id="p1">**</ept> 설치 된 Windows PowerShell 모듈의 모든 속성.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>They use the <bpt id="p1">**</bpt>MemberName<ept id="p1">**</ept> parameter to specify the <bpt id="p2">**</bpt>Path<ept id="p2">**</ept> property of modules.</source>
          <target state="translated">사용 하는 <bpt id="p1">**</bpt>MemberName<ept id="p1">**</ept> 매개 변수는 <bpt id="p2">**</bpt>경로<ept id="p2">**</ept> 모듈의 속성입니다.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The second command is equivalent to the first.</source>
          <target state="translated">두 번째 명령은 첫 번째 명령과 같습니다.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> alias of the <bpt id="p2">**</bpt>Foreach-Object<ept id="p2">**</ept> cmdlet and omits the name of the <bpt id="p3">**</bpt>MemberName<ept id="p3">**</ept> parameter, which is optional.</source>
          <target state="translated">사용 하 여는 <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> 의 별칭은 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> cmdlet의 이름을 생략 하 고는 <bpt id="p3">**</bpt>MemberName<ept id="p3">**</ept> 매개 변수는 선택 사항입니다.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet is very useful for getting property values, because it gets the value without changing the type, unlike the <bpt id="p2">**</bpt>Format<ept id="p2">**</ept> cmdlets or the Select-Object cmdlet, which change the property value type.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> 달리 형식을 변경 하지 않고 값을 가져오기 때문에 cmdlet은 속성 값을 가져오는 데 매우 유용는 <bpt id="p2">**</bpt>형식<ept id="p2">**</ept> cmdlet 또는 속성을 변경 하는 Select-object cmdlet으로 값 형식입니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>-------------------------- EXAMPLE 7 --------------------------</source>
          <target state="translated">-------------------------- EXAMPLE 7 --------------------------</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>These commands split two dot-separated module names into their component names.</source>
          <target state="translated">이 명령은 점으로 구분된 두 개의 모듈 이름을 해당 구성 요소 이름으로 분할합니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The commands call the <bpt id="p1">**</bpt>Split<ept id="p1">**</ept> method of strings.</source>
          <target state="translated">명령 호출의 <bpt id="p1">**</bpt>분할<ept id="p1">**</ept> 방법 문자열입니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The three commands use different syntax, but they are equivalent and interchangeable.</source>
          <target state="translated">세 명령은 서로 다른 구문을 사용하지만 동일하며 교환해서 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The first command uses the traditional syntax, which includes a script block and the current object operator ($_).</source>
          <target state="translated">첫 번째 명령은 스크립트 블록과 현재 개체 연산자($_)를 포함하는 일반적인 구문을 사용합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>It uses the dot syntax to specify the method and parentheses to enclose the delimiter argument.</source>
          <target state="translated">점 구문을 사용하여 메서드를 지정하고 괄호를 사용하여 구분 기호 인수를 묶습니다.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The second command uses the <bpt id="p1">**</bpt>MemberName<ept id="p1">**</ept> parameter to specify the <bpt id="p2">**</bpt>Split<ept id="p2">**</ept> method and the <bpt id="p3">**</bpt>ArgumentName<ept id="p3">**</ept> parameter to identify the dot (".") as the split delimiter.</source>
          <target state="translated">두 번째 명령은 <bpt id="p1">**</bpt>MemberName<ept id="p1">**</ept> 매개 변수는 <bpt id="p2">**</bpt>분할<ept id="p2">**</ept> 메서드 및 <bpt id="p3">**</bpt>ArgumentName<ept id="p3">**</ept> 점 연산자를 식별 하는 매개 변수 (".") 분할 구분 기호로.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The third command  uses the <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> alias of the <bpt id="p2">**</bpt>Foreach-Object<ept id="p2">**</ept> cmdlet and omits the names of the <bpt id="p3">**</bpt>MemberName<ept id="p3">**</ept> and <bpt id="p4">**</bpt>ArgumentList<ept id="p4">**</ept> parameters, which are optional.</source>
          <target state="translated">세 번째 명령은 <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> 의 별칭은 <bpt id="p2">**</bpt>Foreach-object<ept id="p2">**</ept> cmdlet의 이름은 생략 하 고는 <bpt id="p3">**</bpt>MemberName<ept id="p3">**</ept> 및 <bpt id="p4">**</bpt>ArgumentList<ept id="p4">**</ept> 선택적 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The output of these three commands, shown below, is identical.</source>
          <target state="translated">아래 표시된 세 명령의 출력은 동일합니다.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Split<ept id="p1">**</ept> is just one of many useful methods of strings.</source>
          <target state="translated"><bpt id="p1">**</bpt>분할<ept id="p1">**</ept> 문자열의 많은 유용한 메서드 중 하나일 뿐입니다.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>To see all of the properties and methods of strings, pipe a string to the Get-Member cmdlet.</source>
          <target state="translated">모든 속성 및 메서드를 보려면 문자열을 Get-member cmdlet에 대 한 문자열을 파이프 합니다.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>PARAMETERS</source>
          <target state="translated">매개 변수</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>-ArgumentList</source>
          <target state="translated">-ArgumentList</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Specifies the arguments to a method call.</source>
          <target state="translated">메서드 호출의 인수를 지정합니다.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>This parameter is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">이 매개 변수는 Windows PowerShell 3.0에서 도입되었습니다.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>-Begin</source>
          <target state="translated">-시작</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Specifies a script block that runs before processing any input objects.</source>
          <target state="translated">입력 개체를 처리하기 전에 실행되는 스크립트 블록을 지정합니다.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>-Confirm</source>
          <target state="translated">-Confirm</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Prompts you for confirmation before running the cmdlet.Prompts you for confirmation before running the cmdlet.</source>
          <target state="translated">이 cmdlet을 실행 하기 전에 확인 하면 메시지를 표시 합니다. 이 cmdlet을 실행 하기 전에 확인 하면 메시지를 표시 합니다.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>-End</source>
          <target state="translated">엔드</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Specifies a script block that runs after processing all input objects.</source>
          <target state="translated">모든 입력 개체를 처리한 후에 실행되는 스크립트 블록을 지정합니다.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>-InputObject</source>
          <target state="translated">-InputObject</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Specifies the input objects.</source>
          <target state="translated">입력 개체를 지정합니다.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>ForEach-Object runs the script block or operation statement on each input object.</source>
          <target state="translated">ForEach-Object는 각 입력 개체에 대해 스크립트 블록 또는 작업 문을 실행합니다.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Enter a variable that contains the objects, or type a command or expression that gets the objects.</source>
          <target state="translated">개체를 포함하는 변수를 입력하거나 개체를 가져오는 명령 또는 식을 입력하세요.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>When you use the InputObject parameter with ForEach-Object, instead of piping command results to ForEach-Object, the InputObject value-even if the value is a collection that is the result of a command, such as -InputObject (Get-Process)-is treated as a single object.</source>
          <target state="translated">Foreach-object로 명령 결과 파이핑 하는 대신 ForEach 개체와 함께 InputObject 매개 변수를 사용 하는 경우는 InputObject 값도 값이-InputObject (Get-process)와 같은 명령 결과인 컬렉션-단일 개체로 처리 됩니다.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Because InputObject cannot return individual properties from an array or collection of objects, it is recommended that if you use ForEach-Object to perform operations on a collection of objects for those objects that have specific values in defined properties, you use ForEach-Object in the pipeline, as shown in the examples in this topic.</source>
          <target state="translated">InputObject는 배열 또는 개체 컬렉션의 개별 속성을 반환할 수 없으므로 ForEach-Object를 사용하여 개체 컬렉션에서 정의된 속성에 특정 값이 있는 개체에 대해 작업을 수행하는 경우 이 항목의 예제와 같이 파이프라인에 ForEach-Object를 사용하는 것이 좋습니다.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>-MemberName</source>
          <target state="translated">-MemberName</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Specifies the property to get or the method to call.</source>
          <target state="translated">가져올 속성이나 호출할 메서드를 지정합니다.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Wildcard characters are permitted, but work only if the resulting string resolves to a unique value.</source>
          <target state="translated">와일드 카드 문자 허용 되지만 고유 값을 확인 하는 결과 문자열 하는 경우에 작동 합니다.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If, for example, you run Get-Process | ForEach -MemberName *Name, and more than one member exists with a name that contains the string Name--such as the ProcessName and Name properties--the command fails.</source>
          <target state="translated">경우, 예를 들어 실행할 있습니다 Get-process | ForEach MemberName * 이름-ProcessName 및 이름 속성-명령이 실패와 같은 문자열을 포함 하는 이름의 이름 및 둘 이상의 멤버가 존재 합니다.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>This parameter is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">이 매개 변수는 Windows PowerShell 3.0에서 도입되었습니다.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>-Process</source>
          <target state="translated">프로세스</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Specifies the operation that is performed on each input object.</source>
          <target state="translated">각 입력 개체에 대해 수행되는 작업을 지정합니다.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Enter a script block that describes the operation.</source>
          <target state="translated">작업을 설명하는 스크립트 블록을 입력합니다.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>-RemainingScripts</source>
          <target state="translated">-RemainingScripts</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Takes all script blocks that are not taken by the <bpt id="p1">**</bpt>Process<ept id="p1">**</ept> parameter.</source>
          <target state="translated">사용 되지 않은 모든 스크립트 블록은는 <bpt id="p1">**</bpt>프로세스<ept id="p1">**</ept> 매개 변수입니다.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This parameter is introduced in Windows PowerShell 3.0.</source>
          <target state="translated">이 매개 변수는 Windows PowerShell 3.0에서 도입되었습니다.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>-WhatIf</source>
          <target state="translated">-WhatIf</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Shows what would happen if the cmdlet runs.</source>
          <target state="translated">cmdlet이 실행될 경우 결과 동작을 표시합니다.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The cmdlet is not run.Shows what would happen if the cmdlet runs.</source>
          <target state="translated">Cmdlet은 실행 되지 않습니다. Cmdlet이 실행 되 면 어떻게 되는지를 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The cmdlet is not run.</source>
          <target state="translated">cmdlet이 실행되지 않습니다.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>CommonParameters</source>
          <target state="translated">CommonParameters</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This cmdlet supports the common parameters: -Debug, -ErrorAction, -ErrorVariable, -InformationAction, -InformationVariable, -OutVariable, -OutBuffer, -PipelineVariable, -Verbose, -WarningAction, and -WarningVariable.</source>
          <target state="translated">이 cmdlet은 공통 매개 변수:-디버그,-ErrorAction,-ErrorVariable,-InformationAction,-InformationVariable,-OutVariable,-OutBuffer,-PipelineVariable,-Verbose,-WarningAction 및-warningvariable을 지원 합니다.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For more information, see about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216).</source>
          <target state="translated">자세한 내용은 about_CommonParameters (http://go.microsoft.com/fwlink/?LinkID=113216)를 참조 합니다.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>INPUTS</source>
          <target state="translated">입력</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>System.Management.Automation.PSObject</source>
          <target state="translated">System.Management.Automation.PSObject</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>You can pipe any object to ForEach-Object.</source>
          <target state="translated">어떤 개체든 ForEach-Object로 파이프할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>OUTPUTS</source>
          <target state="translated">출력</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>System.Management.Automation.PSObject</source>
          <target state="translated">System.Management.Automation.PSObject</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The objects that ForEach-Object returns are determined by the input.</source>
          <target state="translated">ForEach-Object에서 반환하는 개체는 입력에 따라 결정됩니다.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>NOTES</source>
          <target state="translated">참고 사항</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ForEach-Object<ept id="p1">**</ept> cmdlet works much like the <bpt id="p2">**</bpt>Foreach<ept id="p2">**</ept> statement, except that you cannot pipe input to a <bpt id="p3">**</bpt>Foreach<ept id="p3">**</ept> statement.</source>
          <target state="translated"> <bpt id="p1">**</bpt>Foreach-object<ept id="p1">**</ept> cmdlet와 비슷하게 작동는 <bpt id="p2">**</bpt>Foreach<ept id="p2">**</ept> 문을 제외 하 고에 대 한 입력을 파이프할 수 없습니다는 <bpt id="p3">**</bpt>Foreach<ept id="p3">**</ept> 문입니다.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>For more information about the <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> statement, see about_Foreach (http://go.microsoft.com/fwlink/?LinkID=113229).</source>
          <target state="translated">에 대 한 자세한 내용은 <bpt id="p1">**</bpt>Foreach<ept id="p1">**</ept> 문을 참조 about_Foreach (http://go.microsoft.com/fwlink/?LinkID=113229).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>RELATED LINKS</source>
          <target state="translated">관련된 링크</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>