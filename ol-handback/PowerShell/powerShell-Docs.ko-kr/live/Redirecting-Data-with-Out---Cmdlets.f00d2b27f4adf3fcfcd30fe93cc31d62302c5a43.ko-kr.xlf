<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Redirecting-Data-with-Out---Cmdlets.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">955d00f61a8222ff83797fbc923357c6d85cad7a</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-39517ae" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Redirecting Data with Out   Cmdlets</source>
          <target state="translated">Out-* Cmdlet을 사용하여 데이터 리디렉션</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Redirecting Data with Out-* Cmdlets</source>
          <target state="translated">Out-* Cmdlet을 사용하여 데이터 리디렉션</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Windows PowerShell provides several cmdlets that let you control data output directly.</source>
          <target state="translated">Windows PowerShell에는 데이터 출력을 직접 제어할 수 있는 여러 가지 cmdlet이 있습니다.</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>These cmdlets share two important characteristics.</source>
          <target state="translated">이러한 cmdlet은 두 가지 중요한 특성을 공유합니다.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>First, they generally transform data to some form of text.</source>
          <target state="translated">첫째, 일반적으로 이러한 cmdlet은 데이터를 특정 텍스트 형식으로 변환합니다.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>They do this because they output the data to system components that require text input.</source>
          <target state="translated">이는 텍스트 입력을 필요로 하는 시스템 구성 요소에 데이터를 출력하기 위한 것입니다.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This means they need to represent the objects as text.</source>
          <target state="translated">즉, 개체를 텍스트로 표시해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Therefore, the text is formatted as you see it in the Windows PowerShell console window.</source>
          <target state="translated">따라서 Windows PowerShell 콘솔 창에 표시되는 대로 텍스트의 형식이 지정됩니다.</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Second, these cmdlets use the Windows PowerShell verb <bpt id="p1">**</bpt>Out<ept id="p1">**</ept> because they send information out from Windows PowerShell to somewhere else.</source>
          <target state="translated">둘째, 이러한 cmdlet은 Windows PowerShell에서 다른 위치로 정보를 내보내기 때문에 Windows PowerShell의 동사 <bpt id="p1">**</bpt>Out<ept id="p1">**</ept>을 사용합니다.</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out\-Host<ept id="p1">**</ept> cmdlet is no exception: the host window display is outside of Windows PowerShell.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out\-Host<ept id="p1">**</ept> cmdlet은 항상 호스트 창을 Windows PowerShell의 외부에 표시합니다.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This is important because when data is sent out of Windows PowerShell, it is actually removed.</source>
          <target state="translated">이는 Windows PowerShell에서 데이터를 내보내면 실제로 데이터가 제거되기 때문에 중요합니다.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can see this if you try to create a pipeline that pages data to the host window, and then attempt to format it as a list, as shown here:</source>
          <target state="translated">다음과 같이 데이터를 호스트 창으로 페이징하는 파이프라인을 만든 다음 목록 형식으로 지정해 보면 이 동작을 재현할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You might expect the command to display pages of process information in list format.</source>
          <target state="translated">이 명령을 실행하면 프로세스 정보 페이지가 목록 형식으로 표시되어야 하지만</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Instead, it displays the default tabular list:</source>
          <target state="translated">다음과 같이 기본 표 형식 목록으로 표시됩니다.</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out\-Host<ept id="p1">**</ept> cmdlet sends the data directly to the console, so the <bpt id="p2">**</bpt>Format\-List<ept id="p2">**</ept> command never receives anything to format.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out\-Host<ept id="p1">**</ept> cmdlet은 데이터를 콘솔에 직접 보내기 때문에 <bpt id="p2">**</bpt>Format\-List<ept id="p2">**</ept> 명령에는 서식을 지정할 데이터가 전달되지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The correct way to structure this command is to put the <bpt id="p1">**</bpt>Out\-Host<ept id="p1">**</ept> cmdlet at the end of the pipeline as shown below.</source>
          <target state="translated">이 명령을 구성하는 올바른 방법은 다음과 같이 <bpt id="p1">**</bpt>Out\-Host<ept id="p1">**</ept> cmdlet을 파이프라인 끝에 배치하는 것입니다.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This causes the process data to be formatted in a list before being paged and displayed.</source>
          <target state="translated">이렇게 하면 프로세스 데이터가 페이징되어 표시되기 전에 목록으로 형식이 지정됩니다.</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This applies to all of the <bpt id="p1">**</bpt>Out<ept id="p1">**</ept> cmdlets.</source>
          <target state="translated">이러한 내용은 모든 <bpt id="p1">**</bpt>Out<ept id="p1">**</ept> cmdlet에 적용되므로</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>Out<ept id="p1">**</ept> cmdlet should always appear at the end of the pipeline.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out<ept id="p1">**</ept> cmdlet을 항상 파이프라인 끝에 배치해야 합니다.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!NOTE]</ph> All the <bpt id="p1">**</bpt>Out<ept id="p1">**</ept> cmdlets render output as text, using the formatting in effect for the console window, including line length limits.</source>
          <target state="translated"><ph id="ph1">[!NOTE]</ph>모든 <bpt id="p1">**</bpt>Out<ept id="p1">**</ept> cmdlet은 줄 길이 제한과 같은 콘솔 창에 적용되는 형식을 사용하여 출력을 텍스트로 렌더링합니다.</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Paging Console Output (Out\-Host)</source>
          <target state="translated">콘솔 출력 페이징(Out\-Host)</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>By default, Windows PowerShell sends data to the host window, which is exactly what the Out\-Host cmdlet does.</source>
          <target state="translated">기본적으로 Windows PowerShell은 데이터를 호스트 창으로 보내는데, 이는 Out\-Host cmdlet이 수행하는 작업과 똑같습니다.</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The primary use for the Out\-Host cmdlet is paging data as we discussed earlier.</source>
          <target state="translated">Out\-Host cmdlet의 주된 용도는 앞에서 설명한 대로 데이터를 페이징하는 것입니다.</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For example, the following command uses Out\-Host to page the output of the Get\-Command cmdlet:</source>
          <target state="translated">예를 들어 다음 명령은 Out\-Host를 사용하여 Get\-Command cmdlet의 출력을 페이징합니다.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>You can also use the <bpt id="p1">**</bpt>more<ept id="p1">**</ept> function to page data.</source>
          <target state="translated"><bpt id="p1">**</bpt>more<ept id="p1">**</ept> 함수를 사용하여 데이터를 페이징할 수도 있습니다.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, <bpt id="p1">**</bpt>more<ept id="p1">**</ept> is a function that calls <bpt id="p2">**</bpt>Out\-Host \-Paging<ept id="p2">**</ept>.</source>
          <target state="translated">Windows PowerShell에서 <bpt id="p1">**</bpt>more<ept id="p1">**</ept>는 <bpt id="p2">**</bpt>Out\-Host \-Paging<ept id="p2">**</ept>을 호출하는 함수입니다.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following command demonstrates using the <bpt id="p1">**</bpt>more<ept id="p1">**</ept> function to page the output of Get\-Command:</source>
          <target state="translated">다음 명령은 <bpt id="p1">**</bpt>more<ept id="p1">**</ept> 함수를 사용하여 Get\-Command의 출력을 페이징하는 방법을 보여 줍니다.</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you include one or more filenames as arguments to the more function, the function will read the specified files and page their contents to the host:</source>
          <target state="translated">하나 이상의 파일 이름을 more 함수에 대한 인수로 포함하면 more 함수는 이러한 파일을 읽고 해당 내용을 호스트로 페이징합니다.</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Discarding Output (Out\-Null)</source>
          <target state="translated">출력 삭제(Out\-Null)</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out\-Null<ept id="p1">**</ept> cmdlet is designed to immediately discard any input it receives.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out\-Null<ept id="p1">**</ept> cmdlet은 수신한 입력을 즉시 삭제하도록 설계되었습니다.</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This is useful for discarding unnecessary data that you get as a side\-effect of running a command.</source>
          <target state="translated">이 cmdlet은 명령 실행의 부작용으로 수신되는 불필요한 데이터를 삭제하는 데 유용합니다.</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>When type the following command, you do not get anything back from the command:</source>
          <target state="translated">다음 명령을 입력하면 명령에서 아무 것도 반환되지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out\-Null<ept id="p1">**</ept> cmdlet does not discard error output.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out\-Null<ept id="p1">**</ept> cmdlet은 오류 출력을 삭제하지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>For example, if you enter the following command, a message is displayed informing you that Windows PowerShell does not recognize 'Is\-NotACommand':</source>
          <target state="translated">예를 들어 다음 명령을 입력하면 Windows PowerShell이 'Is\-NotACommand'를 인식할 수 없다는 메시지가 나타납니다.</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Printing Data (Out\-Printer)</source>
          <target state="translated">데이터 인쇄(Out\-Printer)</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You can print data by using the <bpt id="p1">**</bpt>Out\-Printer<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out\-Printer<ept id="p1">**</ept> cmdlet을 사용하여 데이터를 인쇄할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out\-Printer<ept id="p1">**</ept> cmdlet will use your default printer if you do not provide a printer name.</source>
          <target state="translated">프린터 이름을 제공하지 않으면 <bpt id="p1">**</bpt>Out\-Printer<ept id="p1">**</ept> cmdlet은 기본 프린터를 사용합니다.</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>You can use any Windows\-based printer by specifying its display name.</source>
          <target state="translated">표시 이름만 지정하면 아무 Windows 기반 컴퓨터나 사용할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>There is no need for any kind of printer port mapping or even a real physical printer.</source>
          <target state="translated">프린터 포트 매핑이나 심지어 실제 프린터도 필요하지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example, if you have the Microsoft Office document imaging tools installed, you can send the data to an image file by typing:</source>
          <target state="translated">예를 들어 Microsoft Office Document Imaging 도구가 설치되어 있으면 다음과 같이 입력하여 데이터를 이미지 파일로 보낼 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Saving Data (Out\-File)</source>
          <target state="translated">데이터 저장(Out\-File)</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can send output to a file instead of the console window by using the <bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet을 사용하여 출력을 콘솔 창이 아니라 파일로 보낼 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The following command line sends a list of processes to the file <bpt id="p1">**</bpt>C:\\temp\\processlist.txt<ept id="p1">**</ept>:</source>
          <target state="translated">다음 명령줄은 프로세스 목록을 <bpt id="p1">**</bpt>C:\\temp\\processlist.txt<ept id="p1">**</ept> 파일로 보냅니다.</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The results of using the <bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet may not be what you expect if you are used to traditional output redirection.</source>
          <target state="translated">이전의 출력 리디렉션에 익숙한 경우 <bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet을 사용하면 알고 있는 것과 다른 결과가 나타날 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>To understand its behavior, you must be aware of the context in which the <bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet operates.</source>
          <target state="translated">이 동작을 이해하려면 <bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet이 작동하는 컨텍스트를 알고 있어야 합니다.</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>By default, the <bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet creates a Unicode file.</source>
          <target state="translated">기본적으로 <bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet은 유니코드 파일을 만듭니다.</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This is the best default in the long run, but it means that tools that expect ASCII files will not work correctly with the default output format.</source>
          <target state="translated">이 형식은 최선의 기본 출력 형식이지만 이 기본 출력 형식을 사용할 경우 ASCII 파일을 출력하는 도구가 올바로 작동하지 않습니다.</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can change the default output format to ASCII by using the <bpt id="p1">**</bpt>Encoding<ept id="p1">**</ept> parameter:</source>
          <target state="translated">다음과 같이 <bpt id="p1">**</bpt>Encoding<ept id="p1">**</ept> 매개 변수를 사용하면 기본 출력 형식을 ASCII로 변경할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Out\-file<ept id="p1">**</ept> formats file contents to look like console output.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out\-file<ept id="p1">**</ept>은 콘솔에 표시되는 것처럼 파일 내용의 형식을 지정하기 때문에</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This causes the output to be truncated just as it is in a console window in most circumstances.</source>
          <target state="translated">대부분의 경우 콘솔 창에서처럼 출력이 잘립니다.</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>For example, if you run the following command:</source>
          <target state="translated">예를 들어 다음 명령을 실행할 수 있습니다.</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The output will look like this:</source>
          <target state="translated">출력은 다음과 같이 표시됩니다.</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>To get output that does not force line wraps to match the screen width, you can use the <bpt id="p1">**</bpt>Width<ept id="p1">**</ept> parameter to specify line width.</source>
          <target state="translated">출력할 때 화면 너비에 맞추기 위해 강제로 줄을 바꾸지 않으려면 <bpt id="p1">**</bpt>Width<ept id="p1">**</ept> 매개 변수를 사용하여 줄 너비를 지정하면 됩니다.</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Because <bpt id="p1">**</bpt>Width<ept id="p1">**</ept> is a 32\-bit integer parameter, the maximum value it can have is 2147483647.</source>
          <target state="translated"><bpt id="p1">**</bpt>Width<ept id="p1">**</ept>는 32비트 정수 매개 변수이기 때문에 에 지정할 수 있는 최대값은 2147483647입니다.</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Type the following to set the line width to this maximum value:</source>
          <target state="translated">줄 길이를 최대값으로 설정하려면 다음과 같이 입력합니다.</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet is most useful when you want to save output as it would have displayed on the console.</source>
          <target state="translated"><bpt id="p1">**</bpt>Out\-File<ept id="p1">**</ept> cmdlet은 콘솔에 표시된 상태로 출력을 저장하려는 경우에 가장 유용합니다.</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For finer control over output format, you need more advanced tools.</source>
          <target state="translated">출력 형식을 보다 자세히 제어하려면 고급 도구가 필요합니다.</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>We will look at those in the next chapter, along with some details about object manipulation.</source>
          <target state="translated">이러한 도구에 대해서는 다음 장에서 개체 조작에 대해 설명할 때 함께 다룹니다.</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>