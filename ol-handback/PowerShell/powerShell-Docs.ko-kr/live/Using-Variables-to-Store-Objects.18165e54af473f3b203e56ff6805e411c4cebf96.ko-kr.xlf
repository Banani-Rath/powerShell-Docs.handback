<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-56a7a5e" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c3bcf9dc6f70383e971d9c1ae75ec78860111de9</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\fundamental\Using-Variables-to-Store-Objects.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5034db062c90997f27524daaf96670de86ec6263</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Using Variables to Store Objects</source>
          <target state="translated">변수를 사용하여 개체 저장</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Using Variables to Store Objects</source>
          <target state="translated">변수를 사용하여 개체 저장</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Windows PowerShell works with objects.</source>
          <target state="translated">Windows PowerShell에서는 개체에 대한 작업을 수행합니다.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Windows PowerShell lets you create variables <ph id="ph1">\-</ph> essentially named objects <ph id="ph2">\-</ph> to preserve output to use later.</source>
          <target state="translated">Windows PowerShell에서는 이름이 기본적으로 지정되는 개체인 변수를 만들어 출력을 나중에 사용하기 위해 저장할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>If you are used to working with variables in other shells, remember that Windows PowerShell variables are objects, not text.</source>
          <target state="translated">다른 셸에서 변수에 대한 작업을 수행하는 데 익숙한 경우 Windows PowerShell 변수는 텍스트가 아닌 개체라는 사실에 주의해야 합니다.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Variables are always specified with the initial character $, and can include any alphanumeric characters or the underscore in their names.</source>
          <target state="translated">변수 이름은 항상 $ 문자로 시작되며 모든 영숫자 문자와 밑줄을 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Creating a Variable</source>
          <target state="translated">변수 만들기</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can create a variable by typing a valid variable name:</source>
          <target state="translated">변수를 만들려면 다음과 같이 유효한 변수 이름을 입력해야 합니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This returns no result because <bpt id="p1">**</bpt>$loc<ept id="p1">**</ept> does not have a value.</source>
          <target state="translated">이 경우 <bpt id="p1">**</bpt>$loc<ept id="p1">**</ept>에 지정된 값이 없기 때문에 아무 결과도 표시되지 않습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can create a variable and assign it a value in the same step.</source>
          <target state="translated">동일한 단계에서 변수를 만드는 작업과 변수에 값을 할당하는 작업을 수행할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Windows PowerShell only creates the variable if it does not exist; otherwise, it assigns the specified value to the existing variable.</source>
          <target state="translated">Windows PowerShell은 변수가 없으면 변수를 만들기만 하고, 변수가 있으면 기존 변수에 지정된 값을 할당합니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>To store your current location in the variable <bpt id="p1">**</bpt>$loc<ept id="p1">**</ept>, type:</source>
          <target state="translated"><bpt id="p1">**</bpt>$loc<ept id="p1">**</ept> 변수에 현재 위치를 저장하려면 다음과 같이 입력합니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>There is no output displayed when you type this command because the output is sent to $loc.</source>
          <target state="translated">이 명령을 입력하면 출력이 $loc에 보내지기 때문에 아무 결과도 표시되지 않습니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, displayed output is a side effect of the fact that data which is not otherwise directed always gets sent to the screen.</source>
          <target state="translated">출력이 표시된다면 이는 달리 리디렉션되지 않은 데이터가 항상 화면에 표시되기 때문에 발생하는 의도하지 않은 결과입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Typing $loc will show your current location:</source>
          <target state="translated">다음과 같이 $loc를 입력하면 현재 위치가 표시됩니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You can use <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept> to display information about the contents of variables.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Member<ept id="p1">**</ept>를 사용하여 변수의 내용에 대한 정보를 표시할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Piping $loc to Get<ph id="ph1">\-</ph>Member will show you that it is a <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> object, just like the output from Get<ph id="ph2">\-</ph>Location:</source>
          <target state="translated">다음과 같이 $loc를 Get<ph id="ph1">\-</ph>Member에 파이프하면 Get<ph id="ph2">\-</ph>Location을 입력한 것과 마찬가지로 변수에 <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> 개체가 포함되어 있는 것을 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Manipulating Variables</source>
          <target state="translated">변수 조작</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Windows PowerShell provides several commands to manipulate variables.</source>
          <target state="translated">Windows PowerShell에는 변수를 조작할 수 있는 여러 명령이 포함되어 있습니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can see a complete listing in a readable form by typing:</source>
          <target state="translated">다음과 같이 입력하면 이러한 명령의 전체 목록을 쉽게 확인할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In addition to the variables you create in your current Windows PowerShell session, there are several system<ph id="ph1">\-</ph>defined variables.</source>
          <target state="translated">현재 Windows PowerShell 세션에서 사용자가 직접 만든 변수 외에도 여러 시스템 정의 변수가 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">**</bpt>Remove<ph id="ph1">\-</ph>Variable<ept id="p1">**</ept> cmdlet to clear out all of the variables which are not controlled by Windows PowerShell.</source>
          <target state="translated"><bpt id="p1">**</bpt>Remove<ph id="ph1">\-</ph>Variable<ept id="p1">**</ept> cmdlet을 사용하여 Windows PowerShell에서 제어하지 않는 모든 변수를 지울 수 있습니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Type the following command to clear all variables:</source>
          <target state="translated">다음 명령을 입력하면 모든 변수를 지울 수 있습니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This will produce the confirmation prompt you see below.</source>
          <target state="translated">이 경우 다음과 같은 확인 메시지가 나타납니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If you then run the <bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Variable<ept id="p1">**</ept> cmdlet, you will see the remaining Windows PowerShell variables.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get<ph id="ph1">\-</ph>Variable<ept id="p1">**</ept> cmdlet을 실행하면 나머지 Windows PowerShell 변수를 볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Since there is also a variable Windows PowerShell drive, you can also display all Windows PowerShell variables by typing:</source>
          <target state="translated">또한 변수 Windows PowerShell 드라이브도 있으므로 다음과 같이 입력하면 모든 Windows PowerShell 변수를 표시할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Using Cmd.exe Variables</source>
          <target state="translated">Cmd.exe 변수 사용</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Although Windows PowerShell is not Cmd.exe, it runs in a command shell environment and can use the same variables available in any environment in Windows.</source>
          <target state="translated">Windows PowerShell은 Cmd.exe가 아니지만 명령 셸 환경에서 실행되며 Windows 환경에서 사용할 수 있는 것과 동일한 변수를 사용할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>These variables are exposed through a drive named <bpt id="p1">**</bpt>env<ept id="p1">**</ept>:.</source>
          <target state="translated">이러한 변수는 <bpt id="p1">**</bpt>env<ept id="p1">**</ept>:라는 드라이브를 통해 표시됩니다.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>You can view these variables by typing:</source>
          <target state="translated">다음과 같이 입력하면 이러한 변수를 볼 수 있습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Although the standard variable cmdlets are not designed to work with <bpt id="p1">**</bpt>env:<ept id="p1">**</ept> variables, you can still use them by specifying the <bpt id="p2">**</bpt>env:<ept id="p2">**</ept> prefix.</source>
          <target state="translated">표준 변수 cmdlet은 원래 <bpt id="p1">**</bpt>env:<ept id="p1">**</ept> 변수와 함께 사용하도록 설계되지 않았지만 <bpt id="p2">**</bpt>env:<ept id="p2">**</ept> 접두사를 지정하여 사용할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>For example, to see the operating system root directory, you can use the command<ph id="ph1">\-</ph>shell <bpt id="p1">**</bpt>%SystemRoot%<ept id="p1">**</ept> variable from within Windows PowerShell by typing:</source>
          <target state="translated">예를 들어 운영 체제 루트 디렉터리를 보려면 다음과 같이 입력하여 Windows PowerShell에서 명령 셸 <bpt id="p1">**</bpt>%SystemRoot%<ept id="p1">**</ept> 변수를 사용하면 됩니다.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You can also create and modify environment variables from within Windows PowerShell.</source>
          <target state="translated">또한 Windows PowerShell에서 환경 변수를 만들고 수정할 수도 있습니다.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Environment variables accessed from Windows PowerShell conform to the normal rules for environment variables elsewhere in Windows.</source>
          <target state="translated">Windows PowerShell에서 액세스하는 환경 변수는 다른 Windows 환경 변수에 대한 일반적인 규칙을 따릅니다.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>