<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7eea6b9b981e2e8d88a72f4fcf166ad003991768</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\4.0\Microsoft.PowerShell.Core\About\about_While.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8df022754f30c69867074f0a4b71e3c5a0d93eeb</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ed345791b02be043b1e1257f9482088076c67ce1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_While</source>
          <target state="translated">about_While</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About While</source>
          <target state="translated">에 대 한 시간이</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_While</source>
          <target state="translated">about_While</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_While</source>
          <target state="translated">about_While</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">간단한 설명</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes a language statement that you can use to run a command block based on the results of a conditional test.</source>
          <target state="translated">조건부 테스트의 결과 기반으로 하는 명령 블록을 실행 하는 데 사용할 수 있는 언어 문에 대해 설명 합니다.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">자세한 설명</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The While statement (also known as a While loop) is a language construct for creating a loop that runs commands in a command block as long as a conditional test evaluates to true.</source>
          <target state="translated">While 문 (라고도 While 루프)을 true로 평가 되는 조건 테스트 그대로 명령 블록에서 명령을 실행 하는 루프를 만들기는 언어 구문입니다.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The While statement is easier to construct than a For statement because its syntax is less complicated.</source>
          <target state="translated">While 문의 구문은 덜 복잡 하기 때문에 For 문 보다 구성 하기 쉽습니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In addition, it is more flexible than the Foreach statement because you specify a conditional test in the While statement to control how many times the loop runs.</source>
          <target state="translated">Foreach 문은 보다 더 유연 하다 또한 조건 테스트를 지정 하기 때문에 While 루프 횟수를 제어 하는 문을 실행 합니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The following shows the While statement syntax:</source>
          <target state="translated">다음은 While 문 구문:</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>When you run a While statement,  Windows PowerShell� evaluates the <ph id="ph1">&lt;condition&gt;</ph> section of the statement before entering the <ph id="ph2">&lt;statement list&gt;</ph> section.</source>
          <target state="translated">잠시 실행 하는 경우, Windows PowerShell 평가 되는 <ph id="ph1">&lt;condition&gt;</ph> 들어가기 전에 문의 섹션은 <ph id="ph2">&lt;statement list&gt;</ph> 섹션입니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The condition portion of the statement resolves to either true or false.</source>
          <target state="translated">보고서의 조건을 부분 true 또는 false를 확인합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>As long as the condition remains true,  Windows PowerShell reruns the <ph id="ph1">&lt;statement list&gt;</ph> section.</source>
          <target state="translated">Windows PowerShell을 다시 실행 된 조건이 true로 남아,으로 <ph id="ph1">&lt;statement list&gt;</ph> 섹션입니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;statement list&gt;</ph> section of the statement contains one or more commands that are run each time the loop is entered or repeated.</source>
          <target state="translated"> <ph id="ph1">&lt;statement list&gt;</ph> 문의 섹션에는 루프를 시작 하거나 반복 될 때마다 실행 되는 명령을 하나 이상 포함 되어 있습니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, the following While statement displays the numbers 1 through 3 if the $val variable has not been created or if the $val variable has been created and initialized to 0.</source>
          <target state="translated">예를 들어 다음 문은 $val 변수가 생성 되지 않은 경우 또는 $val 변수를 만들고 0으로 초기화 하는 경우 숫자 1-3 표시 하는 동안.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In this example, the condition ($val is not equal to 3) is true while $val <ph id="ph1">\=</ph> 0, 1, 2.</source>
          <target state="translated">이 예제에서는 조건 ($val은 3)은 $val 하는 동안 true <ph id="ph1">\=</ph> 0, 1, 2입니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Each time through the loop, $val is incremented by 1 using the <ph id="ph1">\+\+</ph> unary increment operator ($val<ph id="ph2">\+\+</ph>).</source>
          <target state="translated">반복할 때마다 $val 1를 사용 하 여 증가 된 <ph id="ph1">\+\+</ph> 단항 증가 연산자 ($val<ph id="ph2">\+\+</ph>).</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The last time through the loop, $val <ph id="ph1">\=</ph> 3.</source>
          <target state="translated">마지막으로 루프를 $val <ph id="ph1">\=</ph> 3입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>When $val equals 3, the condition statement evaluates to false, and the loop exits.</source>
          <target state="translated">$Val 3, 경우에 조건 문으로 false로 평가 하 고 루프 종료 합니다.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>To conveniently write this command at the  Windows PowerShell command prompt, you can enter it in the following way:</source>
          <target state="translated">이 명령은 Windows PowerShell 명령 프롬프트를 편리 하 게 작성 하려면 다음과 같은 방법으로 입력할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Notice that the semicolon separates the first command that adds 1 to $val from the second command that writes the value of $val to the console.</source>
          <target state="translated">세미콜론으로 구분 $val의 값을 콘솔에 작성 하는 두 번째 명령에서 $val에 1을 추가 하는 첫 번째 명령은 있는지 확인 합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>about_Comparison_Operators</source>
          <target state="translated">about_comparison_operators</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>about_Do</source>
          <target state="translated">about_Do</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>about_Foreach</source>
          <target state="translated">about_Foreach</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>about_For</source>
          <target state="translated">about_For</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>about_Language_Keywords</source>
          <target state="translated">about_Language_Keywords</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>