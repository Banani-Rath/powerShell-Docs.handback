<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ko-kr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67fc0a1ae3bba1fed7ba846dd601774ee8268276</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Break.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">96ef8ce26be1424de16362503a74c06e22eefffe</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa0dba048828eed5dd6a6486a27d382a58d84af6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Break</source>
          <target state="translated">나누기에 대 한</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>TOPIC</source>
          <target state="translated">항목</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">간단한 설명</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Describes a statement you can use to immediately exit Foreach, For, While, Do, or Switch statements.</source>
          <target state="translated">즉시, Foreach를 종료 하는 데 사용할 수는 문에 대해 설명 하는 동안 않거나 Switch 문입니다.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">자세한 설명</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When a Break statement appears in a loop, such as a Foreach, For, Switch, or While loop, the Break statement causes Windows PowerShell to immediately exit the loop.</source>
          <target state="translated">경우 Break 문을 같은 Foreach 루프에서에 대 한 스위치를 또는 표시에 즉시 Windows PowerShell Break 문을 루프 반면 루프를 종료 하면 됩니다.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In a Switch construct that does not loop, Break causes Windows PowerShell to exit the Switch code block.</source>
          <target state="translated">스위치 되는 구문에 반복 하지 않습니다 중단 원인 Windows PowerShell 스위치 코드 블록을 끝냅니다.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label that lets you exit embedded loops.</source>
          <target state="translated">Break 문을 포함 된 루프를 끝낼 수 있도록 하는 레이블을 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A label can specify any loop keyword, such as Foreach, For, or While, in a script.</source>
          <target state="translated">레이블을은 스크립트에서 Foreach, 또는 While,와 같은 모든 loop 키워드를 지정할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When you use a label, Break exits the specified loop.</source>
          <target state="translated">레이블을 사용 하면 중단 지정 된 루프를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Break exits the specified loop, regardless of which loop the Break statement is in.</source>
          <target state="translated">나누기는 루프에 관계 없이 Break 문을에 지정 된 루프를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following example shows how to use a Break statement to exit a For statement:</source>
          <target state="translated">다음 예제에서는 Break 문을 사용 하 여 종료 For 문 하는 방법을 보여 줍니다.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>for($i=1; $i -le 10; $i++) { Write-Host $i break }</source>
          <target state="translated">에 대 한 ($i = 1; $i-le 10; $i + +) {Write-host $i 나누기}</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In this example, the Break statement exits the For loop when the $i variable equals 1.</source>
          <target state="translated">이 예제에서는 Break 문을 $i 변수에 1 인 경우 For 루프를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Even though the For statement evaluates to True until $i is greater than 10, Windows PowerShell reaches the break statement the first time the For loop is run.</source>
          <target state="translated">$I 10 보다 큰 될 때까지 For 문이 True를 반환 하는 경우에 Windows PowerShell For 루프를 실행 하는 break 문을 첫 번째 시간에 도달 합니다.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It is more common to use the Break statement in a loop where an inner condition must be met.</source>
          <target state="translated">것이 내부 조건을 만족 해야 되는 루프에 Break 문을 사용 하 여 더 일반적입니다.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Consider the following Foreach statement example:</source>
          <target state="translated">다음과 같은 Foreach 문의 예제를 살펴보세요.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>$i=0 $varB = 10,20,30,40 foreach ($val in $varB) { $i++ if ($val -eq 30) { break } } Write-Host "30 was found in array position $i"</source>
          <target state="translated">$i 0 $varB = 10,20,30,40 foreach ($varB에서 $val) = {$i + + 경우 (30 $val-eq) {나누기}} Write-host "30"를 찾을 수 $i 배열 위치에서</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach statement iterates the $varB array.</source>
          <target state="translated">이 예제에서는 Foreach 문은 $varB 배열을 반복합니다.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Each time the code block is run, the $i variable is incremented by 1.</source>
          <target state="translated">코드 블록 실행 될 때마다 $i 변수에 1 씩 증가 합니다.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The If statement evaluates to False the first two times the loop is run.</source>
          <target state="translated">문의 결과가 False 인 경우 첫 번째는 루프에 두 번 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The third time the loop is run, $i equals 3, and the $val variable equals 30.</source>
          <target state="translated">루프를 실행 하 고 세 번째 $i 3, 같음 및 $val 변수가 30입니다.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>At this point, the Break statement runs, and the Foreach loop exits.</source>
          <target state="translated">이 시점에서 Break 문 실행 및 Foreach 루프가 종료 합니다.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You break out of the other looping statements in the same way you break out of the Foreach loop.</source>
          <target state="translated">Foreach 루프를 중단 하는 동일한 방식으로에서 다른 반복 문을에서 중단 합니다.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In the following example, the Break statement exits a While statement when a DivideByZeroException exception is trapped using the Trap statement.</source>
          <target state="translated">다음 예제에서는 Break 문을 종료 시간이 Trap 문을 사용 하 여 DivideByZeroException 예외를 트래핑 하는 경우에 문입니다.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>$i = 3 while ($true) { trap [DivideByZeroException] { Write-Host "divide by zero trapped" break } 1 / $i-- }</source>
          <target state="translated">$i = 3 ($true) 하는 동안 {트래핑 [DivideByZeroException] {Write-host "포착 하는 0으로 나누기" break} 1 /-$i}</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label.</source>
          <target state="translated">Break 문의 레이블을 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If you use the Break keyword with a label, Windows PowerShell exits the labeled loop instead of exiting the current loop.</source>
          <target state="translated">Break 키워드를 사용 하 여 레이블이 있는 경우 Windows PowerShell 현재 루프를 종료 하지 않고 레이블이 지정 된 루프를 종료 합니다.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The syntax for a label is as follows (this example shows a label in a While loop):</source>
          <target state="translated">레이블에 대 한 구문은 다음과 같습니다 (이 예제는 잠시 후에 레이블을 표시 루프):</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>:myLabel while (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</source>
          <target state="translated">: 동안 myLabel (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The label is a colon followed by a name that you assign.</source>
          <target state="translated">레이블을 할당 하는 이름 뒤에 오는 콜론입니다.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The label must be the first token in a statement, and it must be followed by the looping keyword, such as While.</source>
          <target state="translated">레이블은 문에서 첫 번째 토큰 해야 하 고 뒤에 야 반복 키워드와 같은 동안.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, only loop keywords, such as Foreach, For, and While can have a label.</source>
          <target state="translated">Windows PowerShell에서만 루프, Foreach, 예:, 및 키워드 동안 레이블을 포함할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Break moves execution out of the labeled loop.</source>
          <target state="translated">레이블이 지정 된 루프 밖으로 이동 합니다. 실행을 중단 합니다.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In embedded loops, this has a different result than the Break keyword has when it is used by itself.</source>
          <target state="translated">포함 된 루프가 키워드는 자체적으로 사용 하는 경우 중단 된 것과 다른 결과 있습니다.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This schematic example has a While statement with a For statement:</source>
          <target state="translated">이 구조 예제에 잠시 For 문 사용 하 여 문:</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>:myLabel while (&lt;condition 1&gt;) { for ($item in $items) { if (&lt;condition 2&gt;) { break myLabel } $item = $x   # A statement inside the For-loop } } $a = $c  # A statement after the labeled While-loop</source>
          <target state="translated">: (&lt; 조건 1 &gt;) 하는 동안 myLabel {($items에서 $item)에 대 한 {경우 (&lt; 조건 2 &gt;) {myLabel 철회} $item = $x # A 문에 For 루프 내}} $는 While 루프는 레이블이 지정 된 다음 $c # A 문을 =</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If condition 2 evaluates to True, the execution of the script skips down to the statement after the labeled loop.</source>
          <target state="translated">조건 2를 True로 평가 되 면 스크립트를 실행 하는 레이블이 지정 된 루프 뒤의 문으로 아래쪽으로 건너뜁니다.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the example, execution starts again with the statement "$a = $c".</source>
          <target state="translated">예제에서는 실행 다시 시작 문을 사용 하 여 "$는 $c =".</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can nest many labeled loops, as shown in the following schematic example.</source>
          <target state="translated">다음 계통도 예제와 같이 많은 레이블이 지정 된 루프를 중첩할 수 있습니다.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>:red while (<ph id="ph1">&lt;condition1&gt;</ph>) { :yellow while (<ph id="ph2">&lt;condition2&gt;</ph>) { while (<ph id="ph3">&lt;condition3&gt;</ph>) { if ($a) {break} if ($b) {break red} if ($c) {break yellow} } After innermost loop } After "yellow" loop } After "red" loop</source>
          <target state="translated">: 동안 빨간색 (<ph id="ph1">&lt;condition1&gt;</ph>) {: 하는 동안 노란색 (<ph id="ph2">&lt;condition2&gt;</ph>) {동안 (<ph id="ph3">&lt;condition3&gt;</ph>) {경우 ($는) {나누기} 하는 경우 ($b) {나누기 빨간색} 하는 경우 ($c) {나누기 노란색}} 가장 안쪽의 루프 후} "노란색" 루프 후} "red" 루프 후</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If the $b variable evaluates to True, execution of the script resumes after the loop that is labeled "red".</source>
          <target state="translated">$B 변수를 True로 평가 되 면 스크립트 실행 "red" 레이블이 있는 루프가 다시 시작 합니다.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the $c variable evaluates to True, execution of the script control resumes after the loop that is labeled "yellow".</source>
          <target state="translated">$C 변수를 True로 평가 되 면 "노란색" 레이블이 있는 루프 후 스크립트 컨트롤의 실행이 다시 시작 합니다.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If the $a variable evaluates to True, execution resumes after the innermost loop.</source>
          <target state="translated">$ 변수를 True로 평가 되 면 가장 안쪽의 루프 후 실행을 다시 시작 합니다.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>No label is needed.</source>
          <target state="translated">레이블이 없는 필요 합니다.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Windows PowerShell does not limit how far labels can resume execution.</source>
          <target state="translated">Windows PowerShell 얼마나 멀리 떨어진 레이블을 실행을 재개할 수를 제한 하지 않습니다.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The label can even pass control across script and function call boundaries.</source>
          <target state="translated">레이블을 통해 전달할 수 있는 컨트롤 스크립트 및 함수 호출 경계입니다.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The Break keyword is used to leave the Switch construct.</source>
          <target state="translated">Break 키워드 스위치 구문을 유지 하는 데 사용 됩니다.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, the following Switch statement uses Break statements to test for the most specific condition:</source>
          <target state="translated">예를 들어, 다음 Switch 문은 Break 문을 사용 하 여 가장 구체적인 조건에 대 한 테스트.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>$var = "word2" switch -regex ($var) { "word2" { Write-Host "Exact" $_ break }</source>
          <target state="translated">$var "word2" 스위치 regex ($var) = {"word2" {Write-host "Exact" $_ 나누기}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>"word.*" { Write-Host "Match on the prefix" $_ break }</source>
          <target state="translated">"word.*" {Write-host "접두사를 기준으로 일치" $_ 나누기}</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>"w.*" { Write-Host "Match on at least the first letter" $_ break }</source>
          <target state="translated">"w.*" {Write-host "최소한 첫 글자를 기준으로 일치" $_ 나누기}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>default { Write-Host "No match" $_ break } }</source>
          <target state="translated">기본 {Write-host "일치 항목이 없으면" $_ 나누기}}</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In this example, the $var variable is created and initialized to a string value of "word2".</source>
          <target state="translated">이 예제에서는 $var 변수 생성 되어 "word2"의 문자열 값으로 초기화 합니다.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The Switch statement uses the Regex class to match the variable value first with the term "word2".</source>
          <target state="translated">Switch 문은 Regex 클래스를 사용 하 여 변수 값을 먼저 "word2" 라는 용어와 일치 하도록 합니다.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>(The Regex class is a regular expression Microsoft .NET Framework class.) Because the variable value and the first test in the Switch statement match, the first code block in the Switch statement runs.</source>
          <target state="translated">(Regex 클래스는 정규식 Microsoft.NET Framework 클래스입니다.) 첫 번째 코드 블록는 변수 값과 첫 번째 테스트는 Switch 문 일치에서 하므로 Switch 문이 실행 됩니다.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When Windows PowerShell reaches the first Break statement, the Switch statement exits.</source>
          <target state="translated">Windows PowerShell Break 문을 첫 번째에 도달 하면 Switch 문을 종료 합니다.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If the four Break statements are removed from the example, all four conditions are met.</source>
          <target state="translated">4 개의 Break 문을 예제에서 제거 되 모든 네 가지 조건이 충족 합니다.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This example uses the break statement to display results when the most specific condition is met.</source>
          <target state="translated">이 예제에서는 가장 구체적인 조건이 충족 되 면 결과 표시 하려면 break 문을 사용 합니다.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">참고 항목</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>about_Comparison_Operators about_Continue about_For about_Foreach about_Switch about_Throw about_Trap about_Try_Catch_Finally about_While</source>
          <target state="translated">about_Comparison_Operators about_continue를 참조 하세요 about_For about_Foreach about_Switch about_Throw about_Trap about_Try_Catch_Finally about_While</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>