<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-4fb33c9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e1bf444d7657b66422dab3eb8dbeef5e4d581b4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Working-With-Files-Folders-and-Registry-Keys.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d1cdc25f9dcf6b772d4d68a88bd6e09bddd766bb</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Working With Files Folders and Registry Keys</source>
          <target state="translated">Работа с файлами, папками и разделами реестра</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,командлет</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Working With Files, Folders and Registry Keys</source>
          <target state="translated">Работа с файлами, папками и разделами реестра</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Windows PowerShell uses the noun <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> to refer to items found on a Windows PowerShell drive.</source>
          <target state="translated">Windows PowerShell использует существительное <bpt id="p1">**</bpt>Item<ept id="p1">**</ept>, чтобы ссылаться на элементы, найденные на диске Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>When dealing with the Windows PowerShell FileSystem provider, an <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> might be a file, a folder, or the Windows PowerShell drive.</source>
          <target state="translated">При работе с поставщиком FileSystem Windows PowerShell <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> может быть файлом, папкой или диском Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Listing and working with these items is a critical basic task in most administrative settings, so we want to discuss these tasks in detail.</source>
          <target state="translated">Создание списков элементов и работа с ними является критически важной задачей в большинстве административных учреждений, поэтому необходимо подробно обсудить ее.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Enumerating Files, Folders, and Registry Keys (Get-ChildItem)</source>
          <target state="translated">Перечисление файлов, папок и разделов реестра (Get-ChildItem)</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Since getting a collection of items from a particular location is such a common task, the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet is designed specifically to return all items found within a container such as a folder.</source>
          <target state="translated">Так как получение коллекции элементов из определенного расположения является обычной задачей, командлет <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> разработан специально для возврата всех элементов, найденных в контейнере, например в папке.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If you want to return all files and folders that are contained directly within the folder C:<ph id="ph1">\\</ph>Windows, type:</source>
          <target state="translated">Если необходимо вернуть все файлы и папки, которые находятся непосредственно в папке C:<ph id="ph1">\\</ph>Windows, введите:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The listing looks similar to what you would see when you enter the <bpt id="p1">**</bpt>dir<ept id="p1">**</ept> command in <bpt id="p2">**</bpt>Cmd.exe<ept id="p2">**</ept>, or the <bpt id="p3">**</bpt>ls<ept id="p3">**</ept> command in a UNIX command shell.</source>
          <target state="translated">Списки выглядят аналогично тем спискам, которые появляются при вводе команды <bpt id="p1">**</bpt>dir<ept id="p1">**</ept> в <bpt id="p2">**</bpt>Cmd.exe<ept id="p2">**</ept> или команды <bpt id="p3">**</bpt>ls<ept id="p3">**</ept> в командной оболочке UNIX.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can perform very complex listings by using parameters of the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">С помощью параметров командлета <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> можно создавать очень сложные списки.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>We will look at a few scenarios next.</source>
          <target state="translated">Далее рассмотрим несколько сценариев.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can see the syntax the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet by typing:</source>
          <target state="translated">Синтаксис командлета <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> можно увидеть, введя:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>These parameters can be mixed and matched to get highly customized output.</source>
          <target state="translated">Эти параметры можно скомбинировать и сопоставить для получения настраиваемых выходных данных.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Listing all Contained Items (-Recurse)</source>
          <target state="translated">Перечисление всех элементов в контейнере (-Recurse)</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>To see both the items inside a Windows folder and any items that are contained within the subfolders, use the <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</source>
          <target state="translated">Чтобы увидеть оба элемента в папке Windows и все элементы во вложенных папках, используйте параметр <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> для <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The listing displays everything within the Windows folder and the items in its subfolders.</source>
          <target state="translated">В списке отображается все, что находится в папке Windows, а также элементы в ее вложенных папках.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Filtering Items by Name (-Name)</source>
          <target state="translated">Фильтрация элементов по имени (-Name)</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To display only the names of items, use the <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get-Childitem<ept id="p2">**</ept>:</source>
          <target state="translated">Чтобы отобразить только имена элементов, используйте параметр <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> для <bpt id="p2">**</bpt>Get-Childitem<ept id="p2">**</ept>:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Forcibly Listing Hidden Items (-Force)</source>
          <target state="translated">Принудительное перечисление скрытых элементов (-Force)</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Items that are normally invisible in File Explorer or Cmd.exe are not displayed in the output of a <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> command.</source>
          <target state="translated">В выходных данных команды <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> не отображаются элементы, которые обычно невидимы в проводнике или Cmd.exe.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>To display hidden items, use the <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</source>
          <target state="translated">Чтобы показать скрытые элементы, используйте параметр <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> для <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This parameter is named Force because you can forcibly override the normal behavior of the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> command.</source>
          <target state="translated">Этот параметр называется Force, так как позволяет принудительно переопределить обычное поведение команды <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Force is a widely used parameter that forces an action that a cmdlet would not normally perform, although it will not perform any action that compromises the security of the system.</source>
          <target state="translated">Параметр Force широко используется для принудительного выполнения действия командлетом. Тем не менее, он не будет выполнять действия, компрометирующие систему безопасности.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Matching Item Names with Wildcards</source>
          <target state="translated">Сопоставление имен элементов с подстановочными знаками</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>The Get-ChildItem<ept id="p1">**</ept> command accepts wildcards in the path of the items to list.</source>
          <target state="translated">Команда <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> допускает подстановочные знаки в пути к перечисляемым элементам.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Because wildcard matching is handled by the Windows PowerShell engine, all cmdlets that accepts wildcards use the same notation and have the same matching behavior.</source>
          <target state="translated">Так как сопоставление с подстановочными знаками обрабатывается подсистемой Windows PowerShell, все командлеты, которые принимают подстановочные знаки, используют одну нотацию и имеют одно поведение сопоставления.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell wildcard notation includes:</source>
          <target state="translated">В нотацию подстановочных знаков Windows PowerShell входит:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Asterisk (<ph id="ph1">\*</ph>)matches zero or more occurrences of any character.</source>
          <target state="translated">Звездочка (<ph id="ph1">\*</ph>) — соответствует нулю или большему количеству вхождений любого символа.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Question mark (?) matches exactly one character.</source>
          <target state="translated">знак вопроса (?) — соответствует ровно одному символу;</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Left bracket (<ph id="ph1">\[</ph>) character and right bracket (]) character surround a set of characters to be matched.</source>
          <target state="translated">Открывающая квадратная скобка (<ph id="ph1">\[</ph>) и закрывающая квадратная скобка (]) — заключают в себя набор символов для сопоставления.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Here are some examples of how wildcard specification works.</source>
          <target state="translated">Далее приводится несколько примеров работы спецификации из подстановочных знаков.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To find all files in the Windows directory with the suffix <bpt id="p1">**</bpt>.log<ept id="p1">**</ept> and exactly five characters in the base name, enter the following command:</source>
          <target state="translated">Чтобы найти в каталоге Windows все файлы, имеющие суффикс <bpt id="p1">**</bpt>.log<ept id="p1">**</ept> и ровно пять символов в основном имени, введите следующую команду:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To find all files that begin with the letter <bpt id="p1">**</bpt>x<ept id="p1">**</ept> in the Windows directory, type:</source>
          <target state="translated">Чтобы найти в каталоге Windows все файлы с именами, начинающимися на букву <bpt id="p1">**</bpt>x<ept id="p1">**</ept>, введите:</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>To find all files whose names begin with <bpt id="p1">**</bpt>x<ept id="p1">**</ept> or <bpt id="p2">**</bpt>z<ept id="p2">**</ept>, type:</source>
          <target state="translated">Чтобы найти все файлы с именами, начинающимися на <bpt id="p1">**</bpt>x<ept id="p1">**</ept> или <bpt id="p2">**</bpt>z<ept id="p2">**</ept>, введите:</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Excluding Items (-Exclude)</source>
          <target state="translated">Исключение элементов (-Exclude)</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You can exclude specific items by using the <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> parameter of Get-ChildItem.</source>
          <target state="translated">Вы можете исключить определенные элементы с помощью параметра <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> для Get-ChildItem.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This lets you perform complex filtering in a single statement.</source>
          <target state="translated">Это позволит вам выполнить сложную фильтрацию в одном операторе.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, suppose you are trying to find the Windows Time Service DLL in the System32 folder, and all you can remember about the DLL name is that it begins with "W" and has "32" in it.</source>
          <target state="translated">Например, предположим, что вы пытаетесь найти библиотеку службы времени Windows в папке System32 и все, что вам известно об имени библиотеки, — то, что оно начинается на W и содержит "32".</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>An expression like <bpt id="p1">**</bpt>w<ph id="ph1">\&amp;</ph>#42;32<ph id="ph2">\&amp;</ph>#42;.dll<ept id="p1">**</ept> will find all DLLs that satisfy the conditions, but it may also return the Windows 95 and 16-bit Windows compatibility DLLs that include "95" or "16" in their names.</source>
          <target state="translated">Выражение <bpt id="p1">**</bpt>w<ph id="ph1">\&amp;</ph>#42;32<ph id="ph2">\&amp;</ph>#42;.dll<ept id="p1">**</ept> найдет все библиотеки DLL, удовлетворяющие условию, но может также вернуть библиотеки Windows 95 и библиотеки, совместимые с 16-разрядной версией Windows, в именах которых содержится "95" или "16".</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can omit files that have any of these numbers in their names by using the <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> parameter with the pattern <bpt id="p2">**</bpt><ph id="ph1">\&amp;</ph>#42;<ph id="ph2">\[</ph>9516]<ph id="ph3">\&amp;</ph>#42;<ept id="p2">**</ept>:</source>
          <target state="translated">Файлы с такими числами в именах можно пропустить, используя параметр <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> с шаблоном <bpt id="p2">**</bpt><ph id="ph1">\&amp;</ph>#42;<ph id="ph2">\[</ph>9516]<ph id="ph3">\&amp;</ph>#42;<ept id="p2">**</ept>:</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>PS&gt; Get-ChildItem -Path C:\WINDOWS\System32\w<bpt id="p1">*</bpt>32<ept id="p1">*</ept>.dll -Exclude <bpt id="p2">*</bpt>[9516]<ept id="p2">*</ept> Directory: Microsoft.PowerShell.Core\FileSystem::C:\WINDOWS\System32 Mode                LastWriteTime     Length Name ----                -------------     ------ ---- -a---        2004-08-04   8:00 AM     174592 w32time.dll -a---        2004-08-04   8:00 AM      22016 w32topl.dll -a---        2004-08-04   8:00 AM     101888 win32spl.dll -a---        2004-08-04   8:00 AM     172032 wldap32.dll -a---        2004-08-04   8:00 AM     264192 wow32.dll -a---        2004-08-04   8:00 AM      82944 ws2_32.dll -a---        2004-08-04   8:00 AM      42496 wsnmp32.dll -a---        2004-08-04   8:00 AM      22528 wsock32.dll -a---        2004-08-04   8:00 AM      18432 wtsapi32.dll</source>
          <target state="translated">PS&gt; Get-ChildItem -Path C:\WINDOWS\System32\w<bpt id="p1">*</bpt>32<ept id="p1">*</ept>.dll -Exclude <bpt id="p2">*</bpt>[9516]<ept id="p2">*</ept> Directory: Microsoft.PowerShell.Core\FileSystem::C:\WINDOWS\System32 Mode                LastWriteTime     Length Name ----                -------------     ------ ---- -a---        2004-08-04   8:00 AM     174592 w32time.dll -a---        2004-08-04   8:00 AM      22016 w32topl.dll -a---        2004-08-04   8:00 AM     101888 win32spl.dll -a---        2004-08-04   8:00 AM     172032 wldap32.dll -a---        2004-08-04   8:00 AM     264192 wow32.dll -a---        2004-08-04   8:00 AM      82944 ws2_32.dll -a---        2004-08-04   8:00 AM      42496 wsnmp32.dll -a---        2004-08-04   8:00 AM      22528 wsock32.dll -a---        2004-08-04   8:00 AM      18432 wtsapi32.dll</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Mixing Get-ChildItem Parameters</source>
          <target state="translated">Смешение параметров Get-ChildItem</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can use several of the parameters of the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet in the same command.</source>
          <target state="translated">В одной команде можно использовать несколько параметров <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Before you mix parameters, be sure that you understand wildcard matching.</source>
          <target state="translated">Перед тем как комбинировать параметры, убедитесь, что понимаете принципы сопоставления подстановочных знаков.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For example, the following command returns no results:</source>
          <target state="translated">Например, следующая команда не возвращает результатов:</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>There are no results, even though there are two DLLs that begin with the letter "z" in the Windows folder.</source>
          <target state="translated">Результаты отсутствуют, даже если существуют две библиотеки, которые начинаются на букву z в папке Windows.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>No results were returned because we specified the wildcard as part of the path.</source>
          <target state="translated">Результаты не возвращены, так как подстановочный знак указан как часть пути.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Even though the command was recursive, the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet restricted the items to those that are in the Windows folder with names ending with ".dll".</source>
          <target state="translated">Хотя команда и была рекурсивной, командлет <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> ограничил элементы до тех, которые находятся в папке Windows с именами, заканчивающимися на .dll.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>To specify a recursive search for files whose names match a special pattern, use the <bpt id="p1">**</bpt>-Include<ept id="p1">**</ept> parameter.</source>
          <target state="translated">Чтобы указать рекурсивный поиск для файлов, имена которых соответствуют специальному шаблону, используйте параметр <bpt id="p1">**</bpt>-Include<ept id="p1">**</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>