<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b91e3bbb40b2b5eddd1e43be568773c850a9b8e0</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-2072b6e" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>New language features in PowerShell 5.0</source>
          <target state="translated">Новые возможности языка в PowerShell 5.0</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>PowerShell 5.0 introduces the following new language elements in Windows PowerShell:</source>
          <target state="translated">В PowerShell 5.0 появились следующие новые элементы языка для Windows PowerShell:</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Class keyword</source>
          <target state="translated">Ключевое слово Class</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>class<ept id="p1">**</ept> keyword defines a new class.</source>
          <target state="translated">Ключевое слово <bpt id="p1">**</bpt>class<ept id="p1">**</ept> определяет новый класс.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This is a true .NET Framework type.</source>
          <target state="translated">Это подлинный тип .NET Framework.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Class members are public, but only public within the module scope.</source>
          <target state="translated">Члены класса являются открытыми, но только в рамках области модуля.</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You can't refer to the type name as a string (for example, <ph id="ph1">`New-Object`</ph> doesn't work), and in this release, you can't use a type literal (for example, <ph id="ph2">`[MyClass]`</ph>) outside the script/module file in which the class is defined.</source>
          <target state="translated">Вы не можете ссылаться на имя типа в виде строки (например, <ph id="ph1">`New-Object`</ph> не работает), а также использовать литерал типа (например, <ph id="ph2">`[MyClass]`</ph>) за пределами файла сценария или модуля, где определен этот класс.</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Enum keyword and enumerations</source>
          <target state="translated">Ключевое слово Enum и перечисления</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Support for the <bpt id="p1">**</bpt>enum<ept id="p1">**</ept> keyword has been added, which uses newline as the delimiter.</source>
          <target state="translated">Добавлена поддержка ключевого слова <bpt id="p1">**</bpt>enum<ept id="p1">**</ept>, где символ новой строки используется в качестве разделителя.</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Current limitations: you cannot define an enumerator in terms of itself, but you can initialize an enum in terms of another enum, as shown in the following example.</source>
          <target state="translated">Текущие ограничения: перечислитель нельзя определить относительно самого себя, но можно инициализировать перечисление относительно другого перечисления, как показано в приведенном ниже примере.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Also, the base type cannot currently be specified; it is always [int].</source>
          <target state="translated">Кроме того, в настоящее время нельзя задать базовый тип (всегда [int]).</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>An enumerator value must be a parse time constant; you cannot set it to the result of an invoked command.</source>
          <target state="translated">Значение перечислителя должно быть константой времени анализа. Для него нельзя задать результат вызванной команды.</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Enums support arithmetic operations, as shown in the following example.</source>
          <target state="translated">Перечисления поддерживают арифметические операции, как показано в следующем примере:</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Import-DscResource</source>
          <target state="translated">Import-DscResource</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Import-DscResource<ept id="p1">**</ept> is now a true dynamic keyword.</source>
          <target state="translated"><bpt id="p1">**</bpt>Import-DscResource<ept id="p1">**</ept> теперь является подлинным динамическим ключевым словом.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>PowerShell parses the specified module’s root module, searching for classes that contain the <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> attribute.</source>
          <target state="translated">PowerShell анализирует корневой модуль указанного модуля, выполняя поиск классов, которые содержат атрибут <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>ImplementingAssembly</source>
          <target state="translated">ImplementingAssembly</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A new field, <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept>, has been added to ModuleInfo.</source>
          <target state="translated">В ModuleInfo добавлено новое поле <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>It is set to the dynamic assembly created for a script module if the script defines classes, or the loaded assembly for binary modules.</source>
          <target state="translated">Ему присваивается динамическая сборка, созданная для модуля сценариев, если скрипт определяет классы, или загруженная сборка для двоичных модулей.</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It is not set when ModuleType = Manifest.</source>
          <target state="translated">Оно не задано, когда ModuleType = Manifest.</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Reflection on the <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept> field discovers resources in a module.</source>
          <target state="translated">Отражение поля <bpt id="p1">**</bpt>ImplementingAssembly<ept id="p1">**</ept> обнаруживает ресурсы в модуле.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>This means you can discover resources written in either PowerShell or other managed languages.</source>
          <target state="translated">Это означает, что можно обнаруживать ресурсы, созданные в PowerShell или в любых других управляемых языках.</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Fields with initializers:</source>
          <target state="translated">Поля с инициализаторами:</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Static is supported; it works like an attribute, as do the type constraints, so it can be specified in any order.</source>
          <target state="translated">Поддерживается Static, который выступает в качестве атрибута, как и ограничения типов, и поэтому может быть указан в любом порядке.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>A type is optional.</source>
          <target state="translated">Тип не является обязательным.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>All members are public.</source>
          <target state="translated">Все члены являются открытыми.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Constructors and instantiation</source>
          <target state="translated">Конструкторы и создание экземпляров</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Windows PowerShell classes can have constructors; they have the same name as their class.</source>
          <target state="translated">Классы Windows PowerShell могут иметь конструкторы, имя которых совпадает с именем их класса.</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Constructors can be overloaded.</source>
          <target state="translated">Конструкторы могут быть перегружены.</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Static constructors are supported.</source>
          <target state="translated">Поддерживаются статические конструкторы.</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Properties with initialization expressions are initialized before running any code in a constructor.</source>
          <target state="translated">Свойства с выражениями инициализации инициализируются перед выполнением любого кода в конструкторе.</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Static properties are initialized before the body of a static constructor, and instance properties are initialized before the body of the non-static constructor.</source>
          <target state="translated">Статические свойства инициализируются до основной части статического конструктора, а свойства экземпляра инициализируются до основной части нестатического конструктора.</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Currently, there is no syntax for calling a constructor from another constructor (like the C\# syntax ": this()").</source>
          <target state="translated">В настоящее время не существует синтаксис для вызова конструктора из другого конструктора (такой как синтаксис C\# ": this()").</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The workaround is to define a common Init method.</source>
          <target state="translated">Обходной путь заключается в определении общего метода Init.</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following are ways of instantiating classes in this release.</source>
          <target state="translated">Ниже приведены способы создания экземпляров классов в этом выпуске.</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Instantiating by using the default constructor.</source>
          <target state="translated">Создание экземпляров с помощью конструктора по умолчанию.</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Note that New-Object is not supported in this release.</source>
          <target state="translated">Обратите внимание, что New-Object не поддерживается в этом выпуске.</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Calling a constructor with a parameter</source>
          <target state="translated">Вызов конструктора с параметром:</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Passing an array to a constructor with multiple parameters</source>
          <target state="translated">Передача массива в конструктор с несколькими параметрами:</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In this release, New-Object does not work with classes defined in Windows PowerShell.</source>
          <target state="translated">В этом выпуске New-Object не работает с классами, определенными в Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Also for this release, the type name is only visible lexically, meaning it is not visible outside of the module or script that defines the class.</source>
          <target state="translated">Кроме того, в нем имя типа отображается только лексически, то есть оно не отображается за пределами модуля или сценария, определяющего класс.</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Functions can return instances of a class defined in Windows PowerShell, and instances work well outside of the module or script.</source>
          <target state="translated">Функции могут возвращать экземпляры класса, определенного в Windows PowerShell, и они прекрасно работают за пределами модуля или сценария.</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>lists constructors, so you can view overloads like any other method.</source>
          <target state="translated">выводит список конструкторов, чтобы перегрузки можно было просматривать как и любой другой метод.</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The performance of this syntax is also considerably faster than New-Object.</source>
          <target state="translated">Производительность этого синтаксиса значительно выше по сравнению с New-Object.</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The pseudo-static method named <bpt id="p1">**</bpt>new<ept id="p1">**</ept> works with .NET types, as shown in the following example.</source>
          <target state="translated">Псевдостатический метод с именем <bpt id="p1">**</bpt>new<ept id="p1">**</ept> работает с типами .NET, как показано в следующем примере:</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can now see constructor overloads with Get-Member, or as shown in this example:</source>
          <target state="translated">Теперь можно просмотреть перегрузки конструктора с помощью Get-Member или так, как показано в этом примере:</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Методы</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>A Windows PowerShell class method is implemented as a ScriptBlock that has only an end block.</source>
          <target state="translated">Метод класса Windows PowerShell реализуется как ScriptBlock, имеющий только конечный блок.</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>All methods are public.</source>
          <target state="translated">Все методы являются открытыми.</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The following shows an example of defining a method named <bpt id="p1">**</bpt>DoSomething<ept id="p1">**</ept></source>
          <target state="translated">Ниже приведен пример определения метода с именем <bpt id="p1">**</bpt>DoSomething<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Method invocation:</source>
          <target state="translated">Вызов метода:</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Overloaded methods--that is, those that are named the same as an existing method, but differentiated by their specified values--are also supported.</source>
          <target state="translated">Поддерживаются и перегруженные методы, которые называются так же, как и существующий метод, но отличаются от него заданными значениями.</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Свойства</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>All properties are public.</source>
          <target state="translated">Все свойства являются открытыми.</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Properties require either a newline or semicolon.</source>
          <target state="translated">Для свойств требуется точка с запятой или новая строка.</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If no object type is specified, the property type is object.</source>
          <target state="translated">Если тип объекта не указан, тип свойства является объектом.</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Properties that use validation attributes or argument transformation attributes (e.g. <ph id="ph1">`[ValidateSet("aaa")]`</ph>) work as expected.</source>
          <target state="translated">Свойства, использующие атрибуты проверки или атрибуты преобразования аргументов (например, <ph id="ph1">`[ValidateSet("aaa")]`</ph>) работают должным образом.</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Hidden</source>
          <target state="translated">Hidden</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A new keyword, <bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept>, has been added.</source>
          <target state="translated">Было добавлено новое ключевое слово <bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Hidden<ept id="p1">**</ept> can be applied to properties and methods (including constructors).</source>
          <target state="translated">Оно <bpt id="p1">**</bpt><ept id="p1">**</ept> может применяться к свойствам и методам (включая конструкторы).</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Hidden members are public, but do not appear in the output of Get-Member unless the -Force parameter is added.</source>
          <target state="translated">Члены Hidden являются открытыми, но отображаются в выходных данных Get-Member только при использовании параметра -Force.</target>         
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Hidden members are not included when tab completing or using Intellisense unless the completion occurs in the class defining the hidden member.</source>
          <target state="translated">Элементы Hidden не учитываются при заполнении нажатием клавиши TAB или использовании Intellisense, если только такая операция не выполняется в классе, определяющем элемент Hidden.</target>         
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A new attribute, <bpt id="p1">**</bpt>System.Management.Automation.HiddenAttribute<ept id="p1">**</ept> has been added so that C# code can have the same semantics within Windows PowerShell.</source>
          <target state="translated">Добавлен новый атрибут <bpt id="p1">**</bpt>System.Management.Automation.HiddenAttribute<ept id="p1">**</ept>, чтобы код C# мог иметь ту же семантику в Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Return types</source>
          <target state="translated">Типы возвращаемых значений</target>         
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Return type is a contract; the return value is converted to the expected type.</source>
          <target state="translated">Тип возвращаемого значения является контрактом; возвращаемое значение преобразуется к ожидаемому типу.</target>         
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If no return type is specified, the return type is void.</source>
          <target state="translated">Если тип возвращаемого значения не указан, ему присваивается значение void.</target>         
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>There is no streaming of objects; objects cannot be written to the pipeline either intentionally or by accident.</source>
          <target state="translated">Потоковая передача объектов отсутствует; записать объекты в конвейер специально или случайно невозможно.</target>         
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Атрибуты</target>         
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Two new attributes, <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> and <bpt id="p2">**</bpt>DscProperty<ept id="p2">**</ept> have been added.</source>
          <target state="translated">Добавлены два новых атрибута — <bpt id="p1">**</bpt>DscResource<ept id="p1">**</ept> и <bpt id="p2">**</bpt>DscProperty<ept id="p2">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Lexical scoping of variables</source>
          <target state="translated">Лексическая область переменных</target>         
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The following shows an example of how lexical scoping works in this release.</source>
          <target state="translated">Ниже приведен пример того, как работает лексическая область в этом выпуске.</target>         
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>End-to-End Example</source>
          <target state="translated">Комплексный пример</target>         
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The following example creates several new, custom classes to implement an HTML dynamic style sheet language (DSL).</source>
          <target state="translated">Следующий пример создает несколько новых пользовательских классов для реализации языка динамических таблиц стилей (DSL) HTML.</target>         
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Then, the example adds helper functions to create specific element types as part of the element class, such as heading styles and tables, because types cannot be used outside the scope of a module.</source>
          <target state="translated">Затем пример добавляет вспомогательные функции для создания определенных типов элементов в рамках класса элементов, таких как стили заголовков и таблицы, так как типы нельзя использовать за пределами области действия модуля.</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>