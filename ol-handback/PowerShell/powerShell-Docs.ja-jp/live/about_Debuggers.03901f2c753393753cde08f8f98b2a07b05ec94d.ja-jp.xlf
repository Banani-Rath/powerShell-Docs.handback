<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5860fff87e8bd9511ffd02ee8c3c180095874062</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Debuggers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">70c3e204a65fa25d004d8dd86fda2d2e8143b1b5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d08eb5c290e8115c8fcfa118dc56a6beea7adf1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell コマンドレット</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Debuggers</source>
          <target state="translated">デバッガーについて</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">概要</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes the Windows PowerShell debugger.</source>
          <target state="translated">Windows PowerShell のデバッガーについて説明します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細説明</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Debugging is the process of examining a script while it is running to identify and correct errors in the script instructions.</source>
          <target state="translated">デバッグは、プロセスを特定し、スクリプトの手順でエラーを修正して実行中にスクリプトを調べることです。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can help you examine and identify errors and inefficiencies in your scripts, functions, commands, Windows PowerShell workflows, Windows PowerShell Desired State Configuration (DSC) configurations, or expressions.</source>
          <target state="translated">Windows PowerShell のデバッガーを確認し、エラーと、スクリプト、関数、コマンド、Windows PowerShell ワークフロー、Windows PowerShell Desired State Configuration (DSC) の構成、または式の非効率性を識別できます。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, the Windows PowerShell debugger has been updated to debug scripts, functions, workflows, commands, configurations, or expressions that are running in either the console or Windows PowerShell ISE on remote computers.</source>
          <target state="translated">Windows PowerShell 5.0 以降、Windows PowerShell のデバッガーがデバッグ スクリプト、関数、ワークフロー、コマンド、構成、またはリモート コンピューターで、コンソールまたは Windows PowerShell ISE のいずれかで実行されている式に更新されました。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can run Enter-PSSession to start an interactive remote PowerShell session in which you can set breakpoints and debug script files and commands on the remote computer.</source>
          <target state="translated">対話型リモート PowerShell セッションを開始するブレークポイントを設定し、スクリプト ファイルと、リモート コンピューター上のコマンドをデバッグするには、Enter-pssession を実行することができます。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running a script or command on a remote computer.</source>
          <target state="translated">Enter-pssession 機能に再接続し、スクリプトまたはコマンドを実行しているリモート コンピューターで、切断されたセッションを入力できるように更新されました。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">スクリプトの実行がブレークポイントに達する場合、クライアント セッションは自動的にデバッガーを起動します。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If the disconnected session that is running a script has already hit a breakpoint, and is stopped at the breakpoint, Enter-PSSession automatically starts the command-line debugger, after you reconnect to the session.</source>
          <target state="translated">このオプションをスクリプトを実行して、切断されたセッションが、ブレークポイントにヒットが既にがブレークポイントで停止している場合、セッションに再接続する後に自動的に、Enter-pssession はコマンド ライン デバッガーを開始します。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can also be used to debug Windows PowerShell workflows, in either the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">Windows PowerShell のデバッガーは、いずれか、Windows PowerShell コンソールまたは Windows PowerShell ISE での Windows PowerShell ワークフローをデバッグすることもできます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can debug within running jobs or processes, either locally or remotely.</source>
          <target state="translated">Windows PowerShell 5.0 以降は、ローカルまたはリモートでは、ジョブまたはプロセスを実行している内でデバッグできます。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can use the features of the Windows PowerShell debugger to examine a Windows PowerShell script, function, command, workflow, or expression while it is running.</source>
          <target state="translated">Windows PowerShell のデバッガーの機能を使用すると、実行中に、Windows PowerShell スクリプト、関数、コマンド、ワークフロー、または式を確認します。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger includes a set of cmdlets that let you set breakpoints, manage breakpoints, and view the call stack.</source>
          <target state="translated">Windows PowerShell のデバッガーには、ブレークポイントを設定し、ブレークポイントを管理する、呼び出し履歴を表示するのに便利なコマンドレットのセットが含まれています。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Debugger Cmdlets The Windows PowerShell debugger includes the following set of cmdlets:</source>
          <target state="translated">コマンドレットの Windows PowerShell のデバッガーにはデバッガーには、次のコマンドレットのセットが含まれています。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Set-PsBreakpoint:     Sets breakpoints on lines, variables, and commands.</source>
          <target state="translated">Set-psbreakpoint: は、行、変数、およびコマンドのブレークポイントを設定します。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Get-PsBreakpoint:     Gets breakpoints in the current session.</source>
          <target state="translated">Get-psbreakpoint: は、現在のセッション内のブレークポイントを取得します。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint: Turns off breakpoints in the current session.</source>
          <target state="translated">Disable-psbreakpoint: は、現在のセッションで、ブレークポイント オフにします。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Enable-PsBreakpoint:  Re-enables breakpoints in the current session.</source>
          <target state="translated">Enable-psbreakpoint: は、現在のセッションで、ブレークポイントを再度有効なります。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Remove-PsBreakpoint:  Deletes breakpoints from the current session.</source>
          <target state="translated">Remove-psbreakpoint: は、現在のセッションからブレークポイントを削除します。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Get-PsCallStack:      Displays the current call stack.</source>
          <target state="translated">Get-pscallstack: は、現在の呼び出し履歴を表示します。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Starting and Stopping the Debugger To start the debugger, set one or more breakpoints.</source>
          <target state="translated">開始および停止するデバッガーは、デバッガーを起動、1 つまたは複数のブレークポイントを設定します。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Then, run the script, command, or function that you want to debug.</source>
          <target state="translated">次に、スクリプト、コマンド、またはデバッグする関数を実行します。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When you reach a breakpoint, execution stops, and control is turned over to the debugger.</source>
          <target state="translated">ブレークポイント、実行が停止し、コントロールに到達するときは、デバッガーにでになっています。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To stop the debugger, run the script, command, or function until it is complete.</source>
          <target state="translated">デバッガーを停止するが完了するまで、スクリプト、コマンド、または関数を実行します。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Or, type "stop" or "t".</source>
          <target state="translated">または、「停止」または"t"を入力します。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Debugger Commands When you use the debugger in the Windows PowerShell console, use the following commands to control the execution.</source>
          <target state="translated">デバッガーのコマンドとする Windows PowerShell コンソールで、デバッガーを使用して、次のコマンドを使用して、実行を制御します。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell ISE, use commands on the Debug menu.</source>
          <target state="translated">Windows PowerShell ISE では、[デバッグ] メニューのコマンドを使用します。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Note: For information about how to use the debugger in other host applications, see the host application documentation.</source>
          <target state="translated">注: 他のホスト アプリケーションで、デバッガーを使用する方法については、ホスト アプリケーションのマニュアルを参照してください。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>s, Step-into        Executes the next statement and then stops.</source>
          <target state="translated">s、ステップ イン、次のステートメントと実行、停止します。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>v, Step-over        Executes the next statement, but skips functions and invocations.</source>
          <target state="translated">v、ステップ オーバーの実行、次のステートメントでは、関数、および呼び出しはスキップします。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">スキップしたステートメントは実行されますが、ステップ スルーされることはありません。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Ctrl+Break (Break All in ISE)  Breaks into a running script within either the Windows PowerShell console, or Windows PowerShell ISE.</source>
          <target state="translated">Ctrl キーを押しながら Break (すべて中断 ISE で)、Windows PowerShell コンソールまたは Windows PowerShell ISE 内で実行中のスクリプトに改ページする]</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Note that Ctrl+Break in Windows PowerShell 2.0, 3.0, and 4.0 closes the program.</source>
          <target state="translated">Windows PowerShell 2.0、3.0、および 4.0 で ctrl キーを押しながら Break が、プログラムを終了することに注意してください。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Break All works on both local and remote interactively-running scripts.</source>
          <target state="translated">ローカルおよびリモートの対話形式で実行されているスクリプトですべての動作を中断します。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>o, Step-out         Steps out of the current function; up one level if nested.</source>
          <target state="translated">o、現在の関数からステップ アウトの手順上の入れ子になった場合の 1 つのレベルです。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If in the main body, it continues to the end or the next breakpoint.</source>
          <target state="translated">メインの本文の場合は引き続き末尾または次のブレークポイントです。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">スキップしたステートメントは実行されますが、ステップ スルーされることはありません。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>c, Continue         Continues to run until the script is complete or until the next breakpoint is reached.</source>
          <target state="translated">c、スクリプトが完了するまで、または、次のブレークポイントに到達するまでに実行する継続を続行します。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">スキップしたステートメントは実行されますが、ステップ スルーされることはありません。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>l, List             Displays the part of the script that is executing.</source>
          <target state="translated">l、リストには、実行されているスクリプトの一部が表示されます。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By default, it displays the current line, five previous lines, and 10 subsequent lines.</source>
          <target state="translated">既定では、現在の行、前の 5 つの行およびそれ以降は 10 行を表示します。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To continue listing the script, press ENTER.</source>
          <target state="translated">一覧表示するスクリプトを続行するには、enter キーを押します。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph>, List         Displays 16 lines of the script beginning with the line number specified by <ph id="ph2">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph>, 、スクリプトの先頭で指定された行番号と一覧表示の 16 行 <ph id="ph2">&lt;m&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, List     Displays <ph id="ph3">&lt;n&gt;</ph> lines of the script, beginning with the line number specified by <ph id="ph4">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, 、リストの表示 <ph id="ph3">&lt;n&gt;</ph> 行で指定された行番号で始まるスクリプトの <ph id="ph4">&lt;m&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>q, Stop, Exit       Stops executing the script, and exits the debugger.</source>
          <target state="translated">q は、終了位置が、スクリプトの実行を停止し、デバッガーを終了します。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If you are debugging a job by running the Debug-Job cmdlet, the Exit command detaches the debugger, and allows the job to continue running.</source>
          <target state="translated">デバッグ ジョブ コマンドレットを実行して、ジョブをデバッグする場合、終了コマンドは、デバッガーをデタッチし、継続して実行するジョブを使用します。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>k, Get-PsCallStack  Displays the current call stack.</source>
          <target state="translated">k、Get-pscallstack 表示現在の呼び出し履歴。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Repeats the last command if it was Step (s), Step-over (v), or List (l).</source>
          <target state="translated">手順 (s)、ステップ オーバー (v) または (l)] ボックスの一覧があった場合は、最後のコマンドを繰り返します。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Otherwise, represents a submit action.</source>
          <target state="translated">それ以外の場合、送信アクションを表します。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>?, h                Displays the debugger command Help.</source>
          <target state="translated">?、h は、デバッガー コマンドのヘルプを表示します。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To exit the debugger, you can use Stop (q).</source>
          <target state="translated">デバッガーを終了するには、停止 (q) を使用できます。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can run the Exit command to exit a nested debugging session that you started by running either Debug-Job or Debug-Runspace.</source>
          <target state="translated">Windows PowerShell 5.0 以降、デバッグ ジョブまたはデバッグ実行空間のいずれかを実行して開始した入れ子になったのデバッグ セッションを終了する [終了] コマンドを実行できます。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>By using these debugger commands, you can run a script, stop on a point of concern, examine the values of variables and the state of the system, and continue running the script until you have identified a problem.</source>
          <target state="translated">これらのデバッガー コマンドを使用すると、スクリプトを実行する、重要なポイントで停止、変数と、システムの状態の値を確認でき、問題を特定できるまで、スクリプトの実行を継続できます。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>NOTE:  If you step into a statement with a redirection operator, such as "&gt;", the Windows PowerShell debugger steps over all remaining statements in the script.</source>
          <target state="translated">注: かどうかにステップ インするステートメントで、リダイレクト演算子など、"&gt;"、Windows PowerShell のデバッガーをステップ オーバー、スクリプト内の残りのすべてのステートメントです。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Displaying the Values of script Variables</source>
          <target state="translated">スクリプト変数の値を表示します。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>While you are in the debugger, you can also enter commands, display the value of variables, use cmdlets, and run scripts at the command line.</source>
          <target state="translated">デバッガーもコマンドを入力して、変数の値を表示、コマンドレットを使用でき、コマンドラインでスクリプトを実行できます。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can display the current value of all variables in the script that is being debugged, except for the following automatic variables:</source>
          <target state="translated">次の自動変数以外、デバッグ対象のスクリプトでは、すべての変数の現在の値を表示できます。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>$Args $Input $MyInvocation $PSBoundParameters</source>
          <target state="translated">$Args $Input $MyInvocation $PSBoundParameters</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you try to display the value of any of these variables, you get the value of that variable for in an internal pipeline the debugger uses, not the value of the variable in the script.</source>
          <target state="translated">これらの変数のいずれかの値を表示しようとする場合は、スクリプト内の変数の値ではなく、デバッガーが使う内部パイプラインでその変数の値を取得します。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To display the value these variables for the script that is being debugged, in the script, assign the value of the automatic variable to a new variable.</source>
          <target state="translated">スクリプトで、値がデバッグされるスクリプトのこれらの変数を表示するには、新しい変数に、自動変数の値を割り当てます。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Then you can display the value of the new variable.</source>
          <target state="translated">新しい変数の値を表示します。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>$scriptArgs = $Args $scriptArgs</source>
          <target state="translated">$scriptArgs $scriptArgs $Args を =</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In the example in this topic, the value of the $MyInvocation variable is reassigned as follows:</source>
          <target state="translated">このトピックの例では、$MyInvocation 変数の値が次のように再割り当ています。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">$scriptname $MyInvocation.MyCommand.Path =</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Debugger Environment When you reach a breakpoint, you enter the debugger environment.</source>
          <target state="translated">デバッガーの環境と、ブレークポイントに到達すると、入力デバッガー環境です。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The command prompt changes so that it begins with "<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:".</source>
          <target state="translated">コマンド プロンプトを変更で始まるように"<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:"です。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If you are debugging a workflow, the prompt is "[WFDBG]".</source>
          <target state="translated">ワークフローをデバッグする場合、プロンプトは"[WFDBG]"にします。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can customize the prompt.</source>
          <target state="translated">プロンプトをカスタマイズすることができます。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Also, in some host applications, such as the Windows PowerShell console, (but not in Windows PowerShell Integrated Scripting Environment [ISE]), a nested prompt opens for debugging.</source>
          <target state="translated">また、Windows PowerShell コンソールなど、一部のホスト アプリケーション (が Windows PowerShell Integrated Scripting Environment [ISE] ではなく)、デバッグの入れ子になったプロンプトを開きます。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can detect the nested prompt by the repeating greater-than characters (ASCII 62) that appear at the command prompt.</source>
          <target state="translated">大きいの繰り返しを入れ子になったプロンプトを検出する-コマンド プロンプトで表示される文字 (ASCII 62) よりもします。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For example, the following is the default debugging prompt in the Windows PowerShell console:</source>
          <target state="translated">たとえば、既定の Windows PowerShell コンソールでプロンプトをデバッグは、次のように。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can find the nesting level by using the $NestedPromptLevel automatic variable.</source>
          <target state="translated">$NestedPromptLevel 自動変数を使用して入れ子のレベルが表示されます。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Additionally, an automatic variable, $PSDebugContext, is defined in the local scope.</source>
          <target state="translated">さらに、自動変数、$PSDebugContext は、ローカル スコープで定義されます。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use the presence of the $PsDebugContext variable to determine whether you are in the debugger.</source>
          <target state="translated">$PsDebugContext 変数の存在を使用すると、デバッガーが起動するかどうかを決定します。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">たとえば、次のように入力します。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>if ($psdebugcontext) {"Debugging"} else {"Not Debugging"}</source>
          <target state="translated">場合 ($psdebugcontext) {「デバッグ」} else {「デバッグしていない」}</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can use the value of the $PSDebugContext variable in your debugging.</source>
          <target state="translated">$PSDebugContext 変数の値は、デバッグで使用できます。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Name   CommandLineParameters  UnboundArguments  Location</source>
          <target state="translated">CommandLineParameters UnboundArguments 場所の名前</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>=      {}                     {}                C:\ps-test\vote.ps1 (1)</source>
          <target state="translated">= {} {} C:\ps-test\vote.ps1 (1)</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Debugging and Scope Breaking into the debugger does not change the scope in which you are operating, but when you reach a breakpoint in a script, you move into the script scope.</source>
          <target state="translated">デバッグと、デバッガーに割り込むことをスコープでを運用しているが、スクリプト内のブレークポイントに達すると、スコープが変更されず、スクリプト スコープに移動します。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The script scope is a child of the scope in which you ran the debugger.</source>
          <target state="translated">スクリプトのスコープは、デバッガーを実行したスコープの子です。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To find the variables and aliases that are defined in the script scope, use the Scope parameter of the Get-Alias or Get-Variable cmdlets.</source>
          <target state="translated">変数およびスクリプトのスコープで定義されているエイリアスを検索するには、Get-alias または Get-variable コマンドレットのスコープのパラメーターを使用します。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the variables in the local (script) scope:</source>
          <target state="translated">たとえば、次のコマンドは、(スクリプト) をローカル スコープで変数を取得します。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>get-variable -scope 0</source>
          <target state="translated">get 変数のスコープを 0</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">ようにコマンドを省略することができます。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>gv -s 0</source>
          <target state="translated">gv-s 0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This is a useful way to see only the variables that you defined in the script and that you defined while debugging.</source>
          <target state="translated">これは、スクリプトで定義されていること、およびデバッグ中に定義されている変数のみを表示する便利な方法です。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Debugging at the Command Line When you set a variable breakpoint or a command breakpoint, you can set the breakpoint only in a script file.</source>
          <target state="translated">変数のブレークポイントまたはコマンドのブレークポイントを設定するコマンド ラインときにデバッグ、スクリプト ファイルでのみブレークポイントを設定できます。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>However, by default, the breakpoint is set on anything that runs in the current session.</source>
          <target state="translated">ただし、既定では、現在のセッションで実行されているすべてのブレークポイントが設定します。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For example, if you set a breakpoint on the $name variable, the debugger breaks on any $name variable in any script, command, function, script cmdlet or expression that you run until you disable or remove the breakpoint.</source>
          <target state="translated">たとえば、$name 変数、スクリプト、コマンド、関数、スクリプトのコマンドレットまたは式で $name 変数に、デバッガーは中断にブレークポイントを設定した場合は、無効にするか、ブレークポイントを削除するまでを行います。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This allows you to debug your scripts in a more realistic context in which they might be affected by functions, variables, and other scripts in the session and in the user's profile.</source>
          <target state="translated">これによりより現実的なコンテキストでこれらの影響を受ける関数、変数、およびその他のスクリプト、セッションでは、ユーザーのプロファイルで、スクリプトをデバッグできます。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Line breakpoints are specific to script files, so they are set only in script files.</source>
          <target state="translated">行のブレークポイントは、スクリプト ファイルでのみ設定されているようにスクリプト ファイルに固有です。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Debugging Workflows The Windows PowerShell 4.0 debugger can be used to debug Windows PowerShell workflows, either in the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">デバッグのワークフロー、Windows PowerShell 4.0 デバッガーを使用して、Windows PowerShell コンソールまたは Windows PowerShell ISE で Windows PowerShell ワークフローをデバッグします。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>There are some limitations with using the Windows PowerShell debugger to debug workflows.</source>
          <target state="translated">Windows PowerShell のデバッガーを使用してワークフローをデバッグすると、いくつかの制限があります。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>-- You can view workflow variables while you are in the debugger, but setting workflow variables from within the debugger is not supported.</source>
          <target state="translated">ワークフローの変数は、間に、デバッガーでは、デバッガー内からワークフロー変数の設定がサポートされていません-表示できます。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>-- Tab completion when stopped in the workflow debugger is not available.</source>
          <target state="translated">--タブ補完ワークフロー デバッガーで停止したときに使用できません。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>-- Workflow debugging works only with synchronous running of workflows from a Windows PowerShell script.</source>
          <target state="translated">-ワークフローのデバッグは、Windows PowerShell スクリプトからワークフローの同期の実行でのみ機能します。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You cannot debug workflows if they are running as a job (with the –AsJob parameter).</source>
          <target state="translated">(AsJob パラメーター) を使用して、ジョブとして実行されている場合は、ワークフローをデバッグすることはできません。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>-- Other nested debugging scenarios--such as a workflow calling another workflow, or a workflow calling a script--are not implemented.</source>
          <target state="translated">-別のワークフローを呼び出すワークフローや、スクリプトを呼び出すワークフローなどの入れ子になったその他のデバッグ シナリオ---は実装されていません。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example demonstrates debugging a workflow.</source>
          <target state="translated">ワークフローのデバッグは、次の例です。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Note that when the debugger steps into the workflow function, the debugger prompt changes to [WFDBG].</source>
          <target state="translated">デバッガー ワークフロー関数にステップ イン、デバッガーのプロンプトは、[WFDBG] に変更されたときにことに注意してください。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Set-PSBreakpoint -Script C:\TestWFDemo1.ps1 -Line 8</source>
          <target state="translated">PS c: &gt; Set-psbreakpoint-C:\TestWFDemo1.ps1 をスクリプトの 8 行</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>ID Script           Line Command    Variable     Action</source>
          <target state="translated">ID スクリプト行コマンドの変数のアクション</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>0 TestWFDemo1.ps1   8</source>
          <target state="translated">0 TestWFDemo1.ps1 8</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>PS C:&gt; C:\TestWFDemo1.ps1 Entering debug mode.</source>
          <target state="translated">PS c: &gt; デバッグ モードの C:\TestWFDemo1.ps1 を入力します。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">-H を使用またはでしょうか。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">ヘルプを参照します。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\TestWFDemo1.ps1:8'</source>
          <target state="translated">'C:\TestWFDemo1.ps1:8' の行のブレークポイントにヒットします。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>At C:\TestWFDemo1.ps1:8 char:5</source>
          <target state="translated">C:\TestWFDemo1.ps1:8 char: 5</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Now writing output:"</source>
          <target state="translated">Write-output は、InputObject"出力を書き込むようになりました"。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~</source>
          <target state="translated">+!を含める ~ ~ ~</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>3:</source>
          <target state="translated">3:</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4: ワークフロー SampleWorkflowTest 5: {6: param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>8:*     Write-Output -InputObject "Now writing output:" 9:      Write-Output -Input $MyOutput</source>
          <target state="translated">8: * Write-output InputObject"出力を書き込むようになりました:"9: Write-output - 入力 $MyOutput</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: Write-output InputObject"PowerShell プロセスを取得します"12: Get-process - 名前の powershell。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: Write-output-inputobject「ワークフロー機能完了します」。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # ワークフロー関数を呼び出す 18:「こんにちは」を SampleWorkflowTest 方法について</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Hello</source>
          <target state="translated">こんにちは</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Now writing output: At C:\TestWFDemo1.ps1:9 char:5</source>
          <target state="translated">出力を書き込むようになりました: で C:\TestWFDemo1.ps1:9 char: 5</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Write-Output -Input $MyOutput</source>
          <target state="translated">Write-output - $MyOutput の入力</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~</source>
          <target state="translated">+!を含める ~</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4: ワークフロー SampleWorkflowTest 5: {6: param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>8:      Write-Output -InputObject "Now writing output:" 9:*     Write-Output -Input $MyOutput</source>
          <target state="translated">8: Write-output InputObject"出力を書き込むようになりました:"9: * Write-output - 入力 $MyOutput</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: Write-output InputObject"PowerShell プロセスを取得します"12: Get-process - 名前の powershell。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: Write-output-inputobject「ワークフロー機能完了します」。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # ワークフロー関数を呼び出す 18:「こんにちは」を SampleWorkflowTest 方法について</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Hello At C:\TestWFDemo1.ps1:11 char:5</source>
          <target state="translated">こんにちはに C:\TestWFDemo1.ps1:11 char: 5</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Get PowerShell process:"</source>
          <target state="translated">Write-output は、InputObject"PowerShell プロセスを取得します"。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~~~~~</source>
          <target state="translated">+!を含める ~ ~ ~</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Get PowerShell process:</source>
          <target state="translated">PowerShell プロセスを取得します。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)   WS(K) VM(M)   CPU(s)     Id ProcessName    PSComputerName</source>
          <target state="translated">Npm (k) の pm (k) ws (k) の vm (m) [CPU Id の ProcessName PSComputerName を処理します。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>433      35   106688   128392   726     2.67   7124 powershell    localhost 499      44   134244   172096   787     2.79   7452 powershell    localhost Workflow function complete.</source>
          <target state="translated">433 35 106688 128392 726 2.67「7124 powershell localhost 499 44 134244 172096 787 2.79 7452 powershell localhost 完全なワークフローに機能します。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Debugging Functions When you set a breakpoint on a function that has Begin, Process, and End sections, the debugger breaks at the first line of each section.</source>
          <target state="translated">Begin、Process、および最後のセクションを持つ関数にブレークポイントを設定すると関数のデバッグ、デバッガーは、各セクションの最初の行で中断します。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">たとえば、次のように入力します。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>function test-cmdlet { begin { write-output "Begin" } process { write-output "Process" } end { write-output "End" } }</source>
          <target state="translated">機能テスト コマンドレット {開始 {write-output は、"Begin"} {write-output は、「プロセス」} のプロセス終了 {write-output は、"End"}}</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; set-psbreakpoint -command test-cmdlet</source>
          <target state="translated">C:\PS &gt;、set-psbreakpoint-テスト コマンドレットのコマンド</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; test-cmdlet</source>
          <target state="translated">C:\PS &gt; テスト コマンドレット</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Begin Entering debug mode.</source>
          <target state="translated">デバッグ モードの入力を開始します。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">-H を使用またはでしょうか。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">ヘルプを参照します。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">コマンドのブレークポイントにヒット ' プロンプト: テスト-コマンドレット '</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">テスト コマンドレット</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Process Entering debug mode.</source>
          <target state="translated">デバッグ モードの入力を処理します。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">-H を使用またはでしょうか。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">ヘルプを参照します。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">コマンドのブレークポイントにヒット ' プロンプト: テスト-コマンドレット '</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">テスト コマンドレット</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>End Entering debug mode.</source>
          <target state="translated">入力するデバッグ モードを終了します。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">-H を使用またはでしょうか。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">ヘルプを参照します。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">コマンドのブレークポイントにヒット ' プロンプト: テスト-コマンドレット '</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">テスト コマンドレット</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS&gt;</source>
          <target state="translated"><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS &gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Debugging Remote Scripts Starting in Windows PowerShell 5.0, you can run the Windows PowerShell debugger in a remote session, in either the console, or Windows PowerShell ISE.</source>
          <target state="translated">Windows PowerShell 5.0 でスクリプトをリモート起動をデバッグするには、コンソール、または Windows PowerShell ISE のいずれかでのリモート セッションで Windows PowerShell のデバッガーを実行できます。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running on a remote computer, and currently running a script.</source>
          <target state="translated">Enter-pssession 機能に再接続し、切断されたセッションはリモート コンピューターで実行されている現在実行して、スクリプトを入力できるように更新されました。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">スクリプトの実行がブレークポイントに達する場合、クライアント セッションは自動的にデバッガーを起動します。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following is an example that shows how this works, with breakpoints set in a script at lines 6, 11, 22, and 25.</source>
          <target state="translated">この数式の動作、6、11、22、および 25 行をスクリプトに設定されたブレークポイントとを示す例を次に示します。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Note that in the example, when the debugger starts, there are two identifying prompts: the name of the computer on which the session is running, and the DBG prompt that lets you know you are in debugging mode.</source>
          <target state="translated">例では、デバッガーの起動時には 2 つの識別プロンプト: セッションが実行されているコンピューターとデバッグ モードでは通知する DBG プロンプトの名前。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Enter-Pssession -Cn localhost</source>
          <target state="translated">Enter-pssession-Cn localhost</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>ID Script          Line     Command          Variable          Action</source>
          <target state="translated">ID スクリプト行コマンドの変数のアクション</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>0 ttest19.ps1          6 1 ttest19.ps1          11 2 ttest19.ps1          22 3 ttest19.ps1          25</source>
          <target state="translated">0 ttest19.ps1 6 1 ttest19.ps1 11 2 ttest19.ps1 22 3 ttest19.ps1 25</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\psscripts\ttest19.ps1:11'</source>
          <target state="translated">'C:\psscripts\ttest19.ps1:11' の行のブレークポイントにヒットします。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:11 char:1</source>
          <target state="translated">C:\psscripts\ttest19.ps1:11 char: 1</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>$winRMName = "WinRM"</source>
          <target state="translated">$winRMName ="WinRM"</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>6:      1..5 | foreach { sleep 1; Write-Output "hello2day $_" } 7:  }</source>
          <target state="translated">6: 1..5 |foreach {スリープ 1 になります。Write-output「hello2day $_」} 7:}</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>8:</source>
          <target state="translated">8:</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>9:  $count = 10 10:  $psName = "PowerShell" 11:* $winRMName = "WinRM" 12:  $myVar = 102</source>
          <target state="translated">9: $count = 10 10: $psName ="PowerShell"11: * $winRMName ="WinRM"12: $myVar 102 =</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>14:  for ($i=0; $i -lt $count; $i++) 15:  { 16:      sleep 1 17:      Write-Output "Loop iteration is: $i" 18:      Write-Output "MyVar is $myVar"</source>
          <target state="translated">14: の ($i = 0; $i lt $count; $i++) 15: {16: 1 17 をスリープ状態: Write-output"ループのイテレーション: $i"18: Write-output「MyVar は $myVar」</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>20:      hello2day</source>
          <target state="translated">20: hello2day</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>21:</source>
          <target state="translated">21:</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:12 char:1</source>
          <target state="translated">C:\psscripts\ttest19.ps1:12 char: 1</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>$myVar = 102</source>
          <target state="translated">$myVar 102 =</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>PS C:\psscripts&gt;</source>
          <target state="translated">PS C:\psscripts &gt;</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Examples This test script detects the version of the operating system and displays a system-appropriate message.</source>
          <target state="translated">例をこのテスト スクリプトは、オペレーティング システムのバージョンを検出し、システムに応じたメッセージが表示されます。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It includes a function, a function call, and a variable.</source>
          <target state="translated">関数、関数呼び出し、および変数が含まれています。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The following command displays the contents of the test script file:</source>
          <target state="translated">次のコマンドは、テスト スクリプト ファイルの内容を表示します。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>c:&gt;\PS-test&gt;  get-content test.ps1</source>
          <target state="translated">c: &gt; \PS-test &gt;、get-content test.ps1</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>function psversion { "Windows PowerShell " + $psversiontable.psversion if ($psversiontable.psversion.major -lt 2) { "Upgrade to Windows PowerShell 2.0!"</source>
          <target state="translated">関数の psversion {"Windows PowerShell"+ $psversiontable.psversion 場合 ($psversiontable.psversion.major lt 2) {「アップグレードには、Windows PowerShell 2.0!」</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>} else { "Have you run a background job today (start-job)?"</source>
          <target state="translated">} else {「がジョブを実行するバック グラウンド今日 (ジョブの開始) ですか?」</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>} }</source>
          <target state="translated">} }</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path psversion "Done $scriptname."</source>
          <target state="translated">$scriptname = $MyInvocation.MyCommand.Path psversion「$scriptname を完了します」。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>To start, set a breakpoint at a point of interest in the script, such as a line, command, variable, or function.</source>
          <target state="translated">開始するには、行、コマンド、変数、関数などのスクリプトで関係のある時点で、ブレークポイントを設定します。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Start by creating a line breakpoint on the first line of the Test.ps1 script in the current directory.</source>
          <target state="translated">まず、現在のディレクトリで、Test.ps1 スクリプトの最初の行の行のブレークポイントを作成します。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -line 1 -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt;、set-psbreakpoint-行 1 - スクリプト test.ps1</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">このコマンドは、省略形</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; spb 1 -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; spb 1-s test.ps1</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The command returns a line-breakpoint object (System.Management.Automation.LineBreakpoint).</source>
          <target state="translated">このコマンドは、行のブレークポイント オブジェクト (System.Management.Automation.LineBreakpoint) を返します。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Column     : 0 Line       : 1 Action     : Enabled    : True HitCount   : 0 Id         : 0 Script     : C:\ps-test\test.ps1 ScriptName : C:\ps-test\test.ps1</source>
          <target state="translated">列: 行: 1 つのアクション: 有効になっているヒット カウントを True: 0 Id: 0 スクリプト: C:\ps-test\test.ps1 ScriptName: C:\ps-test\test.ps1。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">これで、スクリプトを起動します。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>When the script reaches the first breakpoint, the breakpoint message indicates that the debugger is active.</source>
          <target state="translated">スクリプトでは、最初のブレークポイントに達すると、ブレークポイント メッセージでは、デバッガーがアクティブであることを示します。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>It describes the breakpoint and previews the first line of the script, which is a function declaration.</source>
          <target state="translated">ブレークポイントをについて説明し、関数宣言であると、スクリプトの最初の行をプレビューします。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The command prompt also changes to indicate that the debugger has control.</source>
          <target state="translated">コマンド プロンプトは、デバッガーがコントロールを持っているを示すためにも変更されます。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The preview line includes the script name and the line number of the previewed command.</source>
          <target state="translated">プレビューの行には、スクリプトの名前とプレビューを表示したコマンドの行番号が含まれています。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Entering debug mode.</source>
          <target state="translated">デバッグ モードにするとします。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">-H を使用またはでしょうか。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">ヘルプを参照します。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\ps-test\test.ps1:1'</source>
          <target state="translated">'C:\ps-test\test.ps1:1' の行のブレークポイントにヒットします。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>test.ps1:1   function psversion {</source>
          <target state="translated">test.ps1:1 関数 psversion {</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Use the Step command (s) to execute the first statement in the script and to preview the next statement.</source>
          <target state="translated">ステップ コマンド (s) を使用して、スクリプトの最初のステートメントを実行する次のステートメントをプレビューできます。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The next statement uses the $MyInvocation automatic variable to set the value of the $ScriptName variable to the path and file name of the script file.</source>
          <target state="translated">次のステートメントでは、$MyInvocation 自動変数を使用して、スクリプト ファイルのパスとファイル名に $ScriptName 変数の値を設定します。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:11  $scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">DBG &gt; s test.ps1:11 $scriptname $MyInvocation.MyCommand.Path =</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is not populated, but you can verify the value of the variable by displaying its value.</source>
          <target state="translated">この時点では、$ScriptName 変数は設定されませんが、その値を表示することで、変数の値を確認することができます。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>In this case, the value is $null.</source>
          <target state="translated">この場合、値は $null です。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Use another Step command (s) to execute the current statement and to preview the next statement in the script.</source>
          <target state="translated">現在のステートメントを実行して、スクリプトの次のステートメントをプレビューするもう 1 つのステップのコマンド (s) を使用します。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The next statement calls the PsVersion function.</source>
          <target state="translated">次のステートメントでは、PsVersion 関数を呼び出します。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is populated, but you verify the value of the variable by displaying its value.</source>
          <target state="translated">この時点では、$ScriptName 変数が設定されますが、その値を表示することで、変数の値を確認します。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>In this case, the value is set to the script path.</source>
          <target state="translated">この場合、値は、スクリプトのパスに設定されます。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Use another Step command to execute the function call.</source>
          <target state="translated">もう 1 つのステップのコマンドを使用すると、関数呼び出しを実行できます。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Press ENTER, or type "s" for Step.</source>
          <target state="translated">キーを押し、またはステップの"s"を入力します。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:2       "Windows PowerShell " + $psversiontable.psversion</source>
          <target state="translated">DBG &gt; s test.ps1:2"Windows PowerShell"+ $psversiontable.psversion</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The debug message includes a preview of the statement in the function.</source>
          <target state="translated">デバッグ メッセージには、関数内のステートメントのプレビューが含まれています。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>To execute this statement and to preview the next statement in the function, you can use a Step command.</source>
          <target state="translated">このステートメントを実行して、関数の次のステートメントをプレビューするには、ステップのコマンドを使用することができます。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>But, in this case, use a Step-Out command (o).</source>
          <target state="translated">しかし、ステップ アウト コマンド (o) をここでは、使用します。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>It completes the execution of the function (unless it reaches a breakpoint) and steps to the next statement in the script.</source>
          <target state="translated">(ない場合、ブレークポイントに達する)、関数の実行が完了して、スクリプトでは、次のステートメントにステップです。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>DBG&gt; o Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; Windows PowerShell 2.0 があるジョブを実行するバック グラウンド今日 (ジョブの開始) o でしょうか。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">「完了」$scriptname"test.ps1:13</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Because we are on the last statement in the script, the Step, Step-Out, and Continue commands have the same effect.</source>
          <target state="translated">スクリプトでは、このステップでは、最後のステートメントであるためステップ アウトと続行コマンドが同じ効果があります。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>In this case, use Step-Out (o).</source>
          <target state="translated">この場合は、ステップ アウト (o) を使用します。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1 PS C:\ps-test&gt;</source>
          <target state="translated">実行 C:\ps-test\test.ps1 PS C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The Step-Out command executes the last command.</source>
          <target state="translated">ステップ アウト] コマンドは、最後のコマンドを実行します。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The standard command prompt indicates that the debugger has exited and returned control to the command processor.</source>
          <target state="translated">標準のコマンド プロンプトでは、デバッガーが終了し、コマンド プロセッサに制御を返したことを示します。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Now, run the debugger again.</source>
          <target state="translated">これで、デバッガーを再度実行します。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>First, to delete the current breakpoint, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">最初に、現在のブレークポイントを削除するには、Get-psbreakpoint と Remove-psbreakpoint コマンドレットを使用します。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>(If you think you might reuse the breakpoint, use the Disable-PsBreakpoint cmdlet instead of Remove-PsBreakpoint.)</source>
          <target state="translated">(ブレークポイントを再利用することがある場合は、使用、Disable-psbreakpoint コマンドレット Remove-psbreakpoint ではなく)。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test &gt; Get-psbreakpoint |Remove-psbreakpoint</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">このコマンドは、省略形</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; gbp | rbp</source>
          <target state="translated">PS C:\ps-test &gt; gbp |rbp</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Or, run the command by writing a function, such as the following function:</source>
          <target state="translated">または、次の関数などの関数を記述して、コマンドを実行します。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>function delbr { gbp | rbp }</source>
          <target state="translated">関数の delbr {gbp | rbp}</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Now, create a breakpoint on the $scriptname variable.</source>
          <target state="translated">ここで、$scriptname 変数にブレークポイントを作成します。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -variable scriptname -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt;、set-psbreakpoint-変数 scriptname-test.ps1 スクリプトを作成</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">ようにコマンドを省略することができます。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -v scriptname -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; sbp-v scriptname-s test.ps1</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">これで、スクリプトを起動します。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The script reaches the variable breakpoint.</source>
          <target state="translated">スクリプトでは、変数のブレークポイントに到達します。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The default mode is Write, so execution stops just before the statement that changes the value of the variable.</source>
          <target state="translated">既定のモードは、変数の値を変更するステートメントの直前に実行が停止するための書き込み、です。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Variable breakpoint on 'C:\ps-test\test.ps1:$scriptname' (Write access)</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1 ヒット変数ブレークポイント 'C:\ps-test\test.ps1:$scriptname' (書き込みアクセス)</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>test.ps1:11  $scriptname = $MyInvocation.mycommand.path</source>
          <target state="translated">test.ps1:11 $scriptname $MyInvocation.mycommand.path =</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Display the current value of the $scriptname variable, which is $null.</source>
          <target state="translated">$Null になっている $scriptname 変数の現在の値を表示します。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to execute the statement that populates the variable.</source>
          <target state="translated">ステップ コマンド (s) を使用すると、変数を設定するステートメントを実行できます。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Then, display the new value of the $scriptname variable.</source>
          <target state="translated">次に、$scriptname 変数の新しい値を表示します。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to preview the next statement in the script.</source>
          <target state="translated">ステップ コマンド (s) を使用すると、スクリプトの次のステートメントをプレビューできます。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>The next statement is a call to the PsVersion function.</source>
          <target state="translated">次のステートメントは、PsVersion 関数への呼び出しです。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>To skip the function but still execute it, use a Step-Over command (v).</source>
          <target state="translated">関数をスキップするが、まだ実行して、ステップ オーバー コマンド (v) を使用します。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>If you are already in the function when you use Step-Over, it is not effective.</source>
          <target state="translated">いる場合、関数にステップ オーバーを使用すると、有効ではありません。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The function call is displayed, but it is not executed.</source>
          <target state="translated">関数呼び出しが表示されますは実行されません。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>DBG&gt; v Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; Windows PowerShell 2.0 があるジョブを実行するバック グラウンド今日 (ジョブの開始) v でしょうか。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">「完了」$scriptname"test.ps1:13</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The Step-Over command executes the function, and it previews the next statement in the script, which prints the final line.</source>
          <target state="translated">ステップ オーバー] コマンドは、関数を実行し、最後の行を印刷すると、スクリプトの次のステートメントをプレビューします。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Use a Stop command (t) to exit the debugger.</source>
          <target state="translated">Stop コマンド (t) を使用して、デバッガーを終了します。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The command prompt reverts to the standard command prompt.</source>
          <target state="translated">コマンド プロンプトは、標準のコマンド プロンプトに戻ります。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>C:\ps-test&gt;</source>
          <target state="translated">C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>To delete the breakpoints, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">ブレークポイントを削除するには、Get-psbreakpoint と Remove-psbreakpoint コマンドレットを使用します。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test &gt; Get-psbreakpoint |Remove-psbreakpoint</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Create a new command breakpoint on the PsVersion function.</source>
          <target state="translated">PsVersion 関数に新しいコマンドのブレークポイントを作成します。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Set-PsBreakpoint -command psversion -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; Set-psbreakpoint-コマンド psversion-test.ps1 スクリプトを作成</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command to:</source>
          <target state="translated">次のコマンドを省略することができます。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -c psversion -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; sbp-c psversion-s test.ps1</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">スクリプトを実行します。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test &gt; 'C:\ps-test\test.ps1:psversion' に.\test.ps1 ヒット コマンドのブレークポイント</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>The script reaches the breakpoint at the function call.</source>
          <target state="translated">スクリプトでは、関数呼び出しにブレークポイントに到達します。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>At this point, the function has not yet been called.</source>
          <target state="translated">この時点で、関数がまだ呼び出されていません。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>This gives you the opportunity to use the Action parameter of Set-PsBreakpoint to set conditions for the execution of the breakpoint or to perform preparatory or diagnostic tasks, such as starting a log or invoking a diagnostic or security script.</source>
          <target state="translated">これにより、ブレークポイントを実行するための条件を設定するか、ログの開始などの診断やセキュリティのスクリプトを呼び出して、準備、または診断タスクを実行する、Set-psbreakpoint のアクション パラメーターを使用することです。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>To set an action, use a Continue command (c) to exit the script, and a Remove-PsBreakpoint command to delete the current breakpoint.</source>
          <target state="translated">アクションを設定するには、スクリプトを終了する続行コマンド (c) と、現在のブレークポイントを削除する Remove-psbreakpoint コマンドを使用します。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>(Breakpoints are read-only, so you cannot add an action to the current breakpoint.)</source>
          <target state="translated">(ブレークポイントは読み取り専用ので、アクションは、現在のブレークポイントを追加することはできません。)</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>DBG&gt; c Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; c Windows PowerShell 2.0 があるジョブを実行するバック グラウンド今日 (ジョブの開始) でしょうか。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1</source>
          <target state="translated">元に戻す C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; get-psbreakpoint | remove-psbreakpoint PS C:\ps-test&gt;</source>
          <target state="translated">PS C:\ps-test &gt; get psbreakpoint |削除 psbreakpoint PS C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Now, create a new command breakpoint with an action.</source>
          <target state="translated">これで、アクションを新しいコマンドのブレークポイントを作成します。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The following command sets a command breakpoint with an action that logs the value of the $scriptname variable when the function is called.</source>
          <target state="translated">次のコマンドは、関数が呼び出されたときに $scriptname 変数の値をログに記録するアクションをコマンドのブレークポイントを設定します。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Because the Break keyword is not used in the action, execution does not stop.</source>
          <target state="translated">Break キーワードが使用されないため、アクション、実行は停止されません。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the line-continuation character.)</source>
          <target state="translated">(バックティック (') は、行連結文字です)。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -command psversion -script test.ps1  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname is $scriptname."</source>
          <target state="translated">PS C:\ps-test &gt;、set-psbreakpoint-コマンド psversion-test.ps1 スクリプト  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname は $scriptname"。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>` -path action.log}</source>
          <target state="translated">-パス action.log}</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>You can also add actions that set conditions for the breakpoint.</source>
          <target state="translated">ブレークポイントの条件を設定するアクションを追加することもできます。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>In the following command, the command breakpoint is executed only if the execution policy is set to RemoteSigned, the most restrictive policy that still permits you to run scripts.</source>
          <target state="translated">次のコマンドでは、実行ポリシーが RemoteSigned、まだスクリプトを実行することができるようにする最も制限の厳しいポリシーに設定されている場合にのみコマンドのブレークポイントが実行されます。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the continuation character.)</source>
          <target state="translated">(バックティック (') は、連結文字です)。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -script test.ps1 -command psversion ` -action { if ((get-executionpolicy) -eq "RemoteSigned") { break }}</source>
          <target state="translated">PS C:\ps-test &gt;、set-psbreakpoint-test.ps1 スクリプトのコマンド psversion '-アクション {場合 ((get-executionpolicy)-eq"RemoteSigned") {中断}}</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The Break keyword in the action directs the debugger to execute the breakpoint.</source>
          <target state="translated">Break キーワードのアクションでは、デバッガーがブレークポイントの実行を指示します。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>You can also use the Continue keyword to direct the debugger to execute without breaking.</source>
          <target state="translated">また、デバッガーを中断せず実行を指示するのに Continue キーワードを使用することができます。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Because the default keyword is Continue, you must specify Break to stop execution.</source>
          <target state="translated">Default キーワードが続行のためには、実行を停止するブレークを指定してください。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">スクリプトを実行します。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test &gt; 'C:\ps-test\test.ps1:psversion' に.\test.ps1 ヒット コマンドのブレークポイント</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Because the execution policy is set to RemoteSigned, execution stops at the function call.</source>
          <target state="translated">実行ポリシーが RemoteSigned に設定されているために、関数呼び出しで実行が停止します。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>At this point, you might want to check the call stack.</source>
          <target state="translated">この時点では、コール スタックをチェックすることができます。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Use the Get-PsCallStack cmdlet or the Get-PsCallStack debugger command (k).</source>
          <target state="translated">Get-pscallstack コマンドレットまたは Get-pscallstack デバッガー コマンド (k) を使用します。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The following command gets the current call stack.</source>
          <target state="translated">次のコマンドは、現在の呼び出し履歴を取得します。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>DBG&gt; k 2: prompt 1: .\test.ps1: $args=[] 0: prompt: $args=[]</source>
          <target state="translated">DBG &gt; k 2: プロンプト 1:.\test.ps1: $args = 0: プロンプト: $args =</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>This example demonstrates just a few of the many ways to use the Windows PowerShell debugger.</source>
          <target state="translated">この例では、Windows PowerShell のデバッガーを使用するさまざまな方法のほんの一部を示します。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>For more information about the debugger cmdlets, type the following command:</source>
          <target state="translated">デバッガーのコマンドレットに関する詳細については、次のコマンドを入力してください。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>help &lt;cmdlet-name&gt; -full</source>
          <target state="translated">&lt; コマンドレット名 &gt; をヘルプ - 完全</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>For example, type:</source>
          <target state="translated">たとえば、次のように入力します。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>help set-psbreakpoint -full</source>
          <target state="translated">ヘルプ、set-psbreakpoint-完全</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Other Debugging Features in Windows PowerShell</source>
          <target state="translated">Windows PowerShell の他のデバッグ機能</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>In addition to the Windows PowerShell debugger, Windows PowerShell includes several other features that you can use to debug scripts and functions.</source>
          <target state="translated">Windows PowerShell のデバッガーだけでなく Windows PowerShell には、スクリプトと関数をデバッグに使用できるその他のいくつかの機能が含まれます。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>-- Windows PowerShell Integrated Scripting Environment (ISE) includes an interactive graphical debugger.</source>
          <target state="translated">-Windows PowerShell Integrated Scripting Environment (ISE) には、対話型グラフィカルなデバッガーが含まれています。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>For more information, start Windows PowerShell ISE and press F1.</source>
          <target state="translated">詳細については、Windows PowerShell ISE を開始し、f1 キーを押します。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>-- The Set-PSDebug cmdlet offers very basic script debugging features, including stepping and tracing.</source>
          <target state="translated">--Set-psdebug コマンドレットは、非常に基本的なスクリプトのステップ実行などの機能のデバッグとトレースを提供します。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>-- Use the Set-StrictMode cmdlet to detect references to uninitialized variables, to references to non-existent properties of an object, and to function syntax that is not valid.</source>
          <target state="translated">-無効な関数の構文におよび、オブジェクトの存在しないプロパティへの参照を初期化されていない変数への参照を検出するために、Set-strictmode コマンドレットを使用します。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>-- Add diagnostic statements to a script, such as statements that display the value of variables, statements that read input from the command line, or statements that report the current instruction.</source>
          <target state="translated">--変数の値を表示するステートメント、コマンド ラインからの入力を読み取るステートメント、または現在の命令を報告するステートメントなどのスクリプトに診断ステートメントを追加します。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Use the cmdlets that contain the Write verb for this task, such as Write-Host, Write-Debug, Write-Warning, and Write-Verbose.</source>
          <target state="translated">Write-host、Write-debug Write-warning など、このタスクに対する書き込みの動詞と Write-verbose を含んでいるコマンドレットを使用します。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">関連項目</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint Enable-PsBreakpoint Get-PsBreakpoint Get-PsCallStack Remove-PsBreakpoint Set-PsBreakpoint Set-PsDebug Set-Strictmode Write-Debug Write-Verbose</source>
          <target state="translated">Disable-psbreakpoint の有効化-PsBreakpoint Get-psbreakpoint Get-PsCallStack Remove-psbreakpoint Set-psbreakpoint Set-psdebug の設定-Strictmode、Write-debug Write-verbose</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>