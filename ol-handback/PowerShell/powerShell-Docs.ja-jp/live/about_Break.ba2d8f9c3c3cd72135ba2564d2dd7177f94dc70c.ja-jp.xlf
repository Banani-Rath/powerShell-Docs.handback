<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df04528dc48f2b74101b4c4c2195e24ad9dcfa68</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\3.0\Microsoft.PowerShell.Core\About\about_Break.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0e1f26447d3c72892f189317fc31ac98536d95d6</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa0dba048828eed5dd6a6486a27d382a58d84af6</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell コマンドレット</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Break</source>
          <target state="translated">中断について</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>TOPIC</source>
          <target state="translated">トピック</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>about_Break</source>
          <target state="translated">about_Break</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">概要</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Describes a statement you can use to immediately exit Foreach, For, While, Do, or Switch statements.</source>
          <target state="translated">すぐに、Foreach を終了するのに使用できるステートメントについて説明には、または Switch ステートメントです。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細説明</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>When a Break statement appears in a loop, such as a Foreach, For, Switch, or While loop, the Break statement causes Windows PowerShell to immediately exit the loop.</source>
          <target state="translated">Break ステートメントに表示されるなど、Foreach ループ、スイッチ、またはループ、Break ステートメントをすぐに Windows PowerShell の発生中に、ループを終了する場合。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In a Switch construct that does not loop, Break causes Windows PowerShell to exit the Switch code block.</source>
          <target state="translated">スイッチ構成体は、区切りによってスイッチを終了する Windows PowerShell はコード ブロックです。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label that lets you exit embedded loops.</source>
          <target state="translated">Break ステートメントでは、埋め込みループが終了するようにするラベルを含めることができます。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A label can specify any loop keyword, such as Foreach, For, or While, in a script.</source>
          <target state="translated">ラベルは、スクリプトで、Foreach ループまたは While をなどの任意のループ キーワードを指定できます。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>When you use a label, Break exits the specified loop.</source>
          <target state="translated">ラベルを使用するときに中断は、指定されたループを終了します。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Break exits the specified loop, regardless of which loop the Break statement is in.</source>
          <target state="translated">中断は、Break ステートメントが、どのループに関係なく、指定されたループを終了します。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following example shows how to use a Break statement to exit a For statement:</source>
          <target state="translated">次の例では、Break ステートメントを使用して、For ステートメントを終了する方法を示します。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>for($i=1; $i -le 10; $i++) { Write-Host $i break }</source>
          <target state="translated">($i = 1; $i-le 10; $i++) {Write-host $i 中断}</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In this example, the Break statement exits the For loop when the $i variable equals 1.</source>
          <target state="translated">この例では、Break ステートメントは、$i 変数が 1 の場合に、For ループを終了します。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Even though the For statement evaluates to True until $i is greater than 10, Windows PowerShell reaches the break statement the first time the For loop is run.</source>
          <target state="translated">For ステートメントが True に評価するは、$i が 10 を超える場合でも Windows PowerShell に、For ループを実行する中断最初のステートメントに達しました。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>It is more common to use the Break statement in a loop where an inner condition must be met.</source>
          <target state="translated">これは、内部の条件を満たす必要のあるループ内で Break ステートメントを使用する方が一般的です。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Consider the following Foreach statement example:</source>
          <target state="translated">Foreach ステートメントの次の例を考慮してください。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>$i=0 $varB = 10,20,30,40 foreach ($val in $varB) { $i++ if ($val -eq 30) { break } } Write-Host "30 was found in array position $i"</source>
          <target state="translated">$i = 0 $varB = 10、20、30、40 foreach ($varB で $val) {$i++ 場合 ($val-eq 30) {中断}} Write-host「30 を配列の位置が $i 見つかりました」</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In this example, the Foreach statement iterates the $varB array.</source>
          <target state="translated">この例では、Foreach ステートメントは、$varB 配列を反復処理します。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Each time the code block is run, the $i variable is incremented by 1.</source>
          <target state="translated">コード ブロックを実行するたびに $i 変数は 1 ずつインクリメントされます。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The If statement evaluates to False the first two times the loop is run.</source>
          <target state="translated">場合、ステートメントの評価が False、最初に 2 回のループを実行します。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The third time the loop is run, $i equals 3, and the $val variable equals 30.</source>
          <target state="translated">ループを実行すると、もう一度 $i 稼働第 3、$val 変数 30 です。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>At this point, the Break statement runs, and the Foreach loop exits.</source>
          <target state="translated">この時点では、Break ステートメントが実行されて、Foreach ループとが終了します。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You break out of the other looping statements in the same way you break out of the Foreach loop.</source>
          <target state="translated">Foreach ループを抜けると同じ方法で、他のループ ステートメントから解除します。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In the following example, the Break statement exits a While statement when a DivideByZeroException exception is trapped using the Trap statement.</source>
          <target state="translated">Break ステートメントを次の例には、しばらくを終了する Trap ステートメントを使用して DivideByZeroException 例外がトラップされるステートメントです。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>$i = 3 while ($true) { trap [DivideByZeroException] { Write-Host "divide by zero trapped" break } 1 / $i-- }</source>
          <target state="translated">$i ($true) 中に 3 を = {[DivideByZeroException] {Write-host「トラップ 0 による除算」break} トラップ 1/$i--}</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>A Break statement can include a label.</source>
          <target state="translated">Break ステートメントでは、ラベルを含めることができます。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If you use the Break keyword with a label, Windows PowerShell exits the labeled loop instead of exiting the current loop.</source>
          <target state="translated">ラベルが、Break キーワードを使用する場合、Windows PowerShell は、現在のループを終了せずに、ラベル付きのループを終了します。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The syntax for a label is as follows (this example shows a label in a While loop):</source>
          <target state="translated">ラベルの構文は次のように、(この例では、ラベルを表示しばらくループ)。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>:myLabel while (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</source>
          <target state="translated">: 中に myLabel (<ph id="ph1">&lt;condition&gt;</ph>) { <ph id="ph2">&lt;statement list&gt;</ph>}</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The label is a colon followed by a name that you assign.</source>
          <target state="translated">ラベルは、コロンの後に名前を指定します。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The label must be the first token in a statement, and it must be followed by the looping keyword, such as While.</source>
          <target state="translated">ラベルは、ステートメントの最初のトークンである必要があり、続けてくださいループ キーワードなど中です。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, only loop keywords, such as Foreach, For, and While can have a label.</source>
          <target state="translated">Windows PowerShell にのみループなどのキーワード、Foreach、および、中にはラベルを設定できます。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Break moves execution out of the labeled loop.</source>
          <target state="translated">ラベル付きのループからの移動の実行を中断します。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In embedded loops, this has a different result than the Break keyword has when it is used by itself.</source>
          <target state="translated">埋め込みループ内でキーワードには、単独で使用している場合、中断とは異なる結果があります。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This schematic example has a While statement with a For statement:</source>
          <target state="translated">この図の例では While ステートメントのステートメントで。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>:myLabel while (&lt;condition 1&gt;) { for ($item in $items) { if (&lt;condition 2&gt;) { break myLabel } $item = $x   # A statement inside the For-loop } } $a = $c  # A statement after the labeled While-loop</source>
          <target state="translated">: &lt; 条件 1 &gt;) の中に myLabel {($items で $item) の {場合 (&lt; 条件 2 &gt;) {中断 myLabel} $item $x # A ステートメントは、For ループ内の =}} $、= $c # A ステートメント ラベル付きの While ループの後</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If condition 2 evaluates to True, the execution of the script skips down to the statement after the labeled loop.</source>
          <target state="translated">2 の条件が True になる場合、ステートメント ラベルの付いたループの後に、スクリプトの実行をスキップします。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In the example, execution starts again with the statement "$a = $c".</source>
          <target state="translated">例では、実行が開始されるもう一度ステートメントを使用して"$、$c ="です。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can nest many labeled loops, as shown in the following schematic example.</source>
          <target state="translated">次の図の例で示すように、多くのラベル付けされたループを入れ子にできます。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>:red while (<ph id="ph1">&lt;condition1&gt;</ph>) { :yellow while (<ph id="ph2">&lt;condition2&gt;</ph>) { while (<ph id="ph3">&lt;condition3&gt;</ph>) { if ($a) {break} if ($b) {break red} if ($c) {break yellow} } After innermost loop } After "yellow" loop } After "red" loop</source>
          <target state="translated">: 中に赤い (<ph id="ph1">&lt;condition1&gt;</ph>) {: 中に黄色 (<ph id="ph2">&lt;condition2&gt;</ph>) {中に (<ph id="ph3">&lt;condition3&gt;</ph>) {場合 ($、) {中断} 場合 ($b) {中断赤} 場合 ($c) {中断黄色}} 最も内側のループの後}「黄色」ループ後}「赤」ループの後</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If the $b variable evaluates to True, execution of the script resumes after the loop that is labeled "red".</source>
          <target state="translated">$B 変数は、True に評価されると、"red"というラベルが付いたループの後、スクリプトの実行が再開されます。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If the $c variable evaluates to True, execution of the script control resumes after the loop that is labeled "yellow".</source>
          <target state="translated">$C 変数では、True に評価されると、「黄色」というラベルが付いたループの後にスクリプト コントロールの実行が再開されます。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If the $a variable evaluates to True, execution resumes after the innermost loop.</source>
          <target state="translated">$A 変数の評価が True の場合は、最も内側のループの後に実行が再開されます。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>No label is needed.</source>
          <target state="translated">ラベルは必要ありません。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Windows PowerShell does not limit how far labels can resume execution.</source>
          <target state="translated">Windows PowerShell では、ラベルが実行を再開するまでは制限されません。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The label can even pass control across script and function call boundaries.</source>
          <target state="translated">ラベルもコントロール間で渡せるスクリプトおよび関数呼び出しの境界です。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The Break keyword is used to leave the Switch construct.</source>
          <target state="translated">Break キーワードを使用して、スイッチ構造のままにします。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, the following Switch statement uses Break statements to test for the most specific condition:</source>
          <target state="translated">たとえば、次の Switch ステートメントは、特定の状況をテストする Break ステートメントを使用します。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>$var = "word2" switch -regex ($var) { "word2" { Write-Host "Exact" $_ break }</source>
          <target state="translated">$var ="word2"スイッチ regex ($var) {"word2"{Write-host"Exact"$_ 中断}</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>"word.*" { Write-Host "Match on the prefix" $_ break }</source>
          <target state="translated">"word.*"{Write-host「プレフィックスに一致する」$_ 中断}</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>"w.*" { Write-Host "Match on at least the first letter" $_ break }</source>
          <target state="translated">"w.*"{Write-host「には、少なくとも最初の文字に一致する」$_ 中断}</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>default { Write-Host "No match" $_ break } }</source>
          <target state="translated">既定 {Write-host「一致する」$_ 中断}}</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In this example, the $var variable is created and initialized to a string value of "word2".</source>
          <target state="translated">この例では、$var 変数が作成され、"word2"の文字列値に初期化します。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The Switch statement uses the Regex class to match the variable value first with the term "word2".</source>
          <target state="translated">Switch ステートメントでは、"word2"という用語と変数の値を最初に一致するのに正規表現クラスを使用します。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>(The Regex class is a regular expression Microsoft .NET Framework class.) Because the variable value and the first test in the Switch statement match, the first code block in the Switch statement runs.</source>
          <target state="translated">(正規表現クラスとは、正規表現の Microsoft .NET Framework クラスのことです)。変数の値と、スイッチ ステートメント一致している最初のテストでは、最初のコード ブロックので、Switch ステートメントが実行されます。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When Windows PowerShell reaches the first Break statement, the Switch statement exits.</source>
          <target state="translated">Windows PowerShell では、最初の Break ステートメントに達すると、Switch ステートメントが終了します。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>If the four Break statements are removed from the example, all four conditions are met.</source>
          <target state="translated">例では、次の 4 つの Break ステートメントは、次の 4 つのすべての条件が満たされた時点です。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This example uses the break statement to display results when the most specific condition is met.</source>
          <target state="translated">この例では、break ステートメントを使用して、特定の条件が満たされた場合、結果を表示します。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">関連項目</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>about_Comparison_Operators about_Continue about_For about_Foreach about_Switch about_Throw about_Trap about_Try_Catch_Finally about_While</source>
          <target state="translated">about_Comparison_Operators「about_Continue about_For about_Foreach about_Switch about_Throw about_Trap about_Try_Catch_Finally about_While</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>