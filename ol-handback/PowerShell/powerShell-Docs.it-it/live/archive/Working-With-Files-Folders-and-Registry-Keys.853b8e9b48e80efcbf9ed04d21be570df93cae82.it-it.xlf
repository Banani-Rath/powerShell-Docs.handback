<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Working-With-Files-Folders-and-Registry-Keys.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c2d203fee4e1595498c666d4060e7a1060b2aa4d</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-39517ae" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Working With Files Folders and Registry Keys</source>
          <target state="translated">Uso di file, cartelle e chiavi del Registro di sistema</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Working With Files, Folders and Registry Keys</source>
          <target state="translated">Gestione di file, cartelle e chiavi del Registro di sistema</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Windows PowerShell uses the noun <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> to refer to items found on a Windows PowerShell drive.</source>
          <target state="translated">Windows PowerShell usa il sostantivo <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> per fare riferimento agli elementi presenti in un'unità di Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When dealing with the Windows PowerShell FileSystem provider, an <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> might be a file, a folder, or the Windows PowerShell drive.</source>
          <target state="translated">Nel caso del provider FileSystem di Windows PowerShell, il sostantivo <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> può fare riferimento a un file, a una cartella o all'unità di Windows PowerShell.</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Listing and working with these items is a critical basic task in most administrative settings, so we want to discuss these tasks in detail.</source>
          <target state="translated">La visualizzazione e l'uso di questi elementi rappresentano attività di base fondamentali nella maggior parte delle impostazioni amministrative, quindi verranno descritte in dettaglio.</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Enumerating Files, Folders, and Registry Keys (Get\-ChildItem)</source>
          <target state="translated">Enumerazione di file, cartelle e chiavi del Registro di sistema (Get-ChildItem)</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Since getting a collection of items from a particular location is such a common task, the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet is designed specifically to return all items found within a container such as a folder.</source>
          <target state="translated">Poiché il recupero di una raccolta di elementi da una specifica posizione è un'attività molto comune, il cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> è stato progettato specificamente per restituire tutti gli elementi presenti in un contenitore, ad esempio una cartella.</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you want to return all files and folders that are contained directly within the folder C:\\Windows, type:</source>
          <target state="translated">Se si vuole restituire tutti i file e le cartelle contenuti direttamente nella cartella C:\Windows, digitare:</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The listing looks similar to what you would see when you enter the <bpt id="p1">**</bpt>dir<ept id="p1">**</ept> command in <bpt id="p2">**</bpt>Cmd.exe<ept id="p2">**</ept>, or the <bpt id="p3">**</bpt>ls<ept id="p3">**</ept> command in a UNIX command shell.</source>
          <target state="translated">L'elenco visualizzato è simile a quello che si otterrebbe immettendo il comando <bpt id="p1">**</bpt>dir<ept id="p1">**</ept> in <bpt id="p2">**</bpt>Cmd.exe<ept id="p2">**</ept> o il comando <bpt id="p3">**</bpt>ls<ept id="p3">**</ept> in una shell di comandi di UNIX.</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can perform very complex listings by using parameters of the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">È possibile ottenere elenchi molto complessi usando i parametri del cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>We will look at a few scenarios next.</source>
          <target state="translated">Verranno esaminati alcuni scenari in seguito.</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can see the syntax the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet by typing:</source>
          <target state="translated">È possibile visualizzare la sintassi del cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> digitando:</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>These parameters can be mixed and matched to get highly customized output.</source>
          <target state="translated">Questi parametri possono essere combinati in vari modi per ottenere un output estremamente personalizzato.</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Listing all Contained Items (\-Recurse)</source>
          <target state="translated">Elenco di tutti gli elementi contenuti (-Recurse)</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>To see both the items inside a Windows folder and any items that are contained within the subfolders, use the <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get\-ChildItem<ept id="p2">**</ept>.</source>
          <target state="translated">Per visualizzare sia gli elementi all'interno di una cartella di Windows sia quelli contenuti nelle sottocartelle, usare il parametro <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> di <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The listing displays everything within the Windows folder and the items in its subfolders.</source>
          <target state="translated">L'elenco visualizza tutto il contenuto della cartella di Windows e tutti gli elementi delle relative sottocartelle.</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Filtering Items by Name (\-Name)</source>
          <target state="translated">Filtraggio degli elementi per nome (-Name)</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To display only the names of items, use the <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get\-Childitem<ept id="p2">**</ept>:</source>
          <target state="translated">Per visualizzare solo i nomi degli elementi, usare il parametro <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> di <bpt id="p2">**</bpt>Get-Childitem<ept id="p2">**</ept>:</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Forcibly Listing Hidden Items (\-Force)</source>
          <target state="translated">Visualizzazione forzata degli elementi nascosti (-Force)</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Items that are normally invisible in File Explorer or Cmd.exe are not displayed in the output of a <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> command.</source>
          <target state="translated">Gli elementi che sono in genere invisibili in Esplora file o in Cmd.exe non vengono visualizzati nell'output di un comando <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>To display hidden items, use the <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get\-ChildItem<ept id="p2">**</ept>.</source>
          <target state="translated">Per visualizzare gli elementi nascosti, usare il parametro <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> di <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This parameter is named Force because you can forcibly override the normal behavior of the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> command.</source>
          <target state="translated">Questo parametro si chiama Force perché è possibile eseguire forzatamente l'override del normale comportamento del comando <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Force is a widely used parameter that forces an action that a cmdlet would not normally perform, although it will not perform any action that compromises the security of the system.</source>
          <target state="translated">Force è un parametro ampiamente usato che forza un'azione che un cmdlet non eseguirebbe normalmente, anche se non esegue nessuna azione che comprometterebbe la sicurezza del sistema.</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Matching Item Names with Wildcards</source>
          <target state="translated">Ricerca di corrispondenze con i nomi degli elementi tramite caratteri jolly</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>The Get\-ChildItem<ept id="p1">**</ept> command accepts wildcards in the path of the items to list.</source>
          <target state="translated">Il comando <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> accetta i caratteri jolly nel percorso degli elementi da elencare.</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Because wildcard matching is handled by the Windows PowerShell engine, all cmdlets that accepts wildcards use the same notation and have the same matching behavior.</source>
          <target state="translated">Poiché la corrispondenza tramite caratteri jolly viene gestita dal motore di Windows PowerShell, tutti i cmdlet che accettano caratteri jolly usano la stessa notazione e hanno lo stesso comportamento.</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell wildcard notation includes:</source>
          <target state="translated">La notazione dei caratteri jolly di Windows PowerShell include:</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Asterisk (\*)matches zero or more occurrences of any character.</source>
          <target state="translated">L'asterisco (*) trova la corrispondenza con zero o più occorrenze di qualsiasi carattere.</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Question mark (?) matches exactly one character.</source>
          <target state="translated">Il punto interrogativo (?) trova la corrispondenza con un unico carattere.</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Left bracket (\[) character and right bracket (]) character surround a set of characters to be matched.</source>
          <target state="translated">La parentesi quadra sinistra ([) e quella destra (]) racchiudono un set di caratteri con cui trovare la corrispondenza.</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Here are some examples of how wildcard specification works.</source>
          <target state="translated">Ecco alcuni esempi del funzionamento dei caratteri jolly.</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>To find all files in the Windows directory with the suffix <bpt id="p1">**</bpt>.log<ept id="p1">**</ept> and exactly five characters in the base name, enter the following command:</source>
          <target state="translated">Per trovare tutti i file nella directory Windows con il suffisso <bpt id="p1">**</bpt>.log<ept id="p1">**</ept> e un nome di base costituito esattamente da cinque caratteri, immettere il comando seguente:</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To find all files that begin with the letter <bpt id="p1">**</bpt>x<ept id="p1">**</ept> in the Windows directory, type:</source>
          <target state="translated">Per trovare tutti i file che iniziano con la lettera <bpt id="p1">**</bpt>x<ept id="p1">**</ept> nella directory Windows, digitare:</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To find all files whose names begin with <bpt id="p1">**</bpt>x<ept id="p1">**</ept> or <bpt id="p2">**</bpt>z<ept id="p2">**</ept>, type:</source>
          <target state="translated">Per trovare tutti i file che iniziano con <bpt id="p1">**</bpt>x<ept id="p1">**</ept> o <bpt id="p2">**</bpt>z<ept id="p2">**</ept>, digitare:</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Excluding Items (\-Exclude)</source>
          <target state="translated">Esclusione di elementi (-Exclude)</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>You can exclude specific items by using the <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> parameter of Get\-ChildItem.</source>
          <target state="translated">È possibile escludere specifici elementi usando il parametro <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> di Get-ChildItem.</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This lets you perform complex filtering in a single statement.</source>
          <target state="translated">In questo modo è possibile eseguire complesse operazioni di filtro in un'unica istruzione.</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example, suppose you are trying to find the Windows Time Service DLL in the System32 folder, and all you can remember about the DLL name is that it begins with "W" and has "32" in it.</source>
          <target state="translated">Si supponga ad esempio di voler trovare la DLL Windows Time Service nella cartella System32 e che non si ricordi il nome della DLL, ma solo che inizia con "W" e che contiene "32".</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>An expression like <bpt id="p1">**</bpt>w\&amp;#42;32\&amp;#42;.dll<ept id="p1">**</ept> will find all DLLs that satisfy the conditions, but it may also return the Windows 95 and 16\-bit Windows compatibility DLLs that include "95" or "16" in their names.</source>
          <target state="translated">Con un'espressione come <bpt id="p1">**</bpt>w*;32*.dll<ept id="p1">**</ept> sarà possibile trovare tutte le DLL che soddisfano le condizioni, ma i risultati potrebbero restituire anche le DLL di compatibilità di Windows per Windows 95 e con Windows a 16 bit che includono "95" o "16" nei relativi nomi.</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can omit files that have any of these numbers in their names by using the <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> parameter with the pattern <bpt id="p2">**</bpt>\&amp;#42;\[9516]\&amp;#42;<ept id="p2">**</ept>:</source>
          <target state="translated">È possibile omettere i file i cui nomi contengono questi numeri usando il parametro <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> con il modello <bpt id="p2">**</bpt>*[9516]*<ept id="p2">**</ept>:</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>PS&gt; Get-ChildItem -Path C:\WINDOWS\System32\w<bpt id="p1">*</bpt>32<ept id="p1">*</ept>.dll -Exclude <bpt id="p2">*</bpt>[9516]<ept id="p2">*</ept> Directory: Microsoft.PowerShell.Core\FileSystem::C:\WINDOWS\System32 Mode                LastWriteTime     Length Name ----                -------------     ------ ---- -a---        2004-08-04   8:00 AM     174592 w32time.dll -a---        2004-08-04   8:00 AM      22016 w32topl.dll -a---        2004-08-04   8:00 AM     101888 win32spl.dll -a---        2004-08-04   8:00 AM     172032 wldap32.dll -a---        2004-08-04   8:00 AM     264192 wow32.dll -a---        2004-08-04   8:00 AM      82944 ws2_32.dll -a---        2004-08-04   8:00 AM      42496 wsnmp32.dll -a---        2004-08-04   8:00 AM      22528 wsock32.dll -a---        2004-08-04   8:00 AM      18432 wtsapi32.dll</source>
          <target state="translated">PS&gt; Get-ChildItem -Path C:\WINDOWS\System32\w<bpt id="p1">*</bpt>32<ept id="p1">*</ept>.dll -Exclude <bpt id="p2">*</bpt>[9516]<ept id="p2">*</ept> Directory: Microsoft.PowerShell.Core\FileSystem::C:\WINDOWS\System32 Mode                LastWriteTime     Length Name ----                -------------     ------ ---- -a---        2004-08-04   8:00 AM     174592 w32time.dll -a---        2004-08-04   8:00 AM      22016 w32topl.dll -a---        2004-08-04   8:00 AM     101888 win32spl.dll -a---        2004-08-04   8:00 AM     172032 wldap32.dll -a---        2004-08-04   8:00 AM     264192 wow32.dll -a---        2004-08-04   8:00 AM      82944 ws2_32.dll -a---        2004-08-04   8:00 AM      42496 wsnmp32.dll -a---        2004-08-04   8:00 AM      22528 wsock32.dll -a---        2004-08-04   8:00 AM      18432 wtsapi32.dll</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Mixing Get\-ChildItem Parameters</source>
          <target state="translated">Combinazione di parametri Get-ChildItem</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can use several of the parameters of the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet in the same command.</source>
          <target state="translated">È possibile usare diversi parametri del cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> nello stesso comando.</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Before you mix parameters, be sure that you understand wildcard matching.</source>
          <target state="translated">Prima di combinare i parametri, assicurarsi di comprendere la ricerca di corrispondenze con caratteri jolly.</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, the following command returns no results:</source>
          <target state="translated">Ad esempio, il comando seguente non restituisce risultati:</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There are no results, even though there are two DLLs that begin with the letter "z" in the Windows folder.</source>
          <target state="translated">Non ci sono risultati, nonostante ci siano due DLL che iniziano con la lettera "z" nella cartella Windows.</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>No results were returned because we specified the wildcard as part of the path.</source>
          <target state="translated">Il motivo è che nel percorso è stato specificato il carattere jolly.</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Even though the command was recursive, the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet restricted the items to those that are in the Windows folder with names ending with ".dll".</source>
          <target state="translated">Anche se il comando è ricorsivo, il cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> restituisce solo gli elementi che si trovano nella cartella Windows e i cui nomi terminano con ".dll".</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To specify a recursive search for files whose names match a special pattern, use the <bpt id="p1">**</bpt>\-Include<ept id="p1">**</ept> parameter.</source>
          <target state="translated">Per specificare una ricerca ricorsiva dei file i cui nomi corrispondono a un modello specifico, usare il parametro <bpt id="p1">**</bpt>-Include<ept id="p1">**</ept>.</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>