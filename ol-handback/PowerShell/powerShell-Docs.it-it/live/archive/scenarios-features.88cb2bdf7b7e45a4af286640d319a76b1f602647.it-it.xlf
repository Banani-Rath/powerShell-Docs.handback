<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="it-it">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-22243b3" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9341b7fc3feea20cc2434065c3e512d1a8dd2b54</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wmf\5.1\scenarios-features.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>New Scenarios and Features in WMF 5.1 (Preview)</source>
          <target state="translated">Nuovi scenari e funzionalità in WMF 5.1 (anteprima)</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>New Scenarios and Features in WMF 5.1 (Preview)</source>
          <target state="translated">Nuovi scenari e funzionalità in WMF 5.1 (anteprima)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Note: This information is preliminary and subject to change.</source>
          <target state="translated">Nota: queste informazioni sono provvisorie e soggette a modifiche.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>PowerShell Editions</source>
          <target state="translated">Edizioni di PowerShell</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Starting with version 5.1, PowerShell is available in different editions which denote varying feature sets and platform compatibility.</source>
          <target state="translated">A partire dalla versione 5.1, PowerShell è disponibile in diverse edizioni che indicano vari set di funzionalità e compatibilità della piattaforma.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Desktop Edition:<ept id="p1">**</ept> Built on .NET Framework and provides compatibility with scripts and modules targeting versions of PowerShell running on full footprint editions of Windows such as Server Core and Windows Desktop.</source>
          <target state="translated"><bpt id="p1">**</bpt>Desktop Edition:<ept id="p1">**</ept> è basata su .NET Framework e fornisce compatibilità con script e moduli destinati a versioni di PowerShell che eseguono edizioni footprint complete di Windows, ad esempio Server Core e Windows Desktop.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Core Edition:<ept id="p1">**</ept> Built on .NET Core and provides compatibility with scripts and modules targeting versions of PowerShell running on reduced footprint editions of Windows such as Nano Server and Windows IoT.</source>
          <target state="translated"><bpt id="p1">**</bpt>Core Edition:<ept id="p1">**</ept> è basata su .NET Core e fornisce compatibilità con script e moduli destinati a versioni di PowerShell che eseguono edizioni footprint ridotte di Windows, ad esempio Nano Server e Windows IoT.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Learn more about using PowerShell Editions</source>
          <target state="translated">Altre informazioni sull'uso delle edizioni di PowerShell</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Determine running edition of PowerShell</source>
          <target state="translated">Determinare l'edizione di PowerShell in esecuzione</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Declare a module's compatibility to specific PowerShell versions</source>
          <target state="translated">Dichiarare la compatibilità di un modulo con versioni specifiche di PowerShell</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Filter Get-Module results by CompatiblePSEditions</source>
          <target state="translated">Filtrare i risultati di Get-Module in base a CompatiblePSEditions</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Prevent script execution unless run on a comaptible edition of PowerShell</source>
          <target state="translated">Impedire l'esecuzione di script a meno che non vengano eseguiti in un'edizione compatibile di PowerShell</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Module Analysis Cache</source>
          <target state="translated">Modulo Analysis Cache</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Starting with WMF 5.1, PowerShell provides control over the file that is used to cache data about a module, such as the commands it exports.</source>
          <target state="translated">A partire da WMF 5.1, PowerShell fornisce il controllo sul file che viene usato per memorizzare nella cache i dati relativi a un modulo, ad esempio i comandi esportati.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>By default, this cache is stored in the file <ph id="ph1">`${env:LOCALAPPDATA}\Microsoft\Windows\PowerShell\ModuleAnalysisCache`</ph>.</source>
          <target state="translated">Per impostazione predefinita, questa cache è archiviata nel file <ph id="ph1">`${env:LOCALAPPDATA}\Microsoft\Windows\PowerShell\ModuleAnalysisCache`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The cache is typically read at startup while searching for a command and is written on a background thread sometime after a module is imported.</source>
          <target state="translated">La cache viene in genere letta all'avvio durante la ricerca di un comando e viene scritta in un thread in background ad un certo punto dopo l'importazione di un modulo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>To change the default location of the cache, set the environment variable PSModuleAnalysisCachePath before starting PowerShell.</source>
          <target state="translated">Per modificare il percorso predefinito della cache, impostare la variabile di ambiente PSModuleAnalysisCachePath prima di avviare PowerShell.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Changes to this environment variable will only affect children processes.</source>
          <target state="translated">Le modifiche apportate a questa variabile di ambiente influiranno solo sui processi figlio.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The value should name a full path (including filename) that PowerShell has permission to create and write files.</source>
          <target state="translated">Il valore deve denominare un percorso completo (nome di file incluso) per il quale PowerShell dispone dell'autorizzazione per creare e scrivere file.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To disable the file cache, set this value to an invalid location, for example:</source>
          <target state="translated">Per disabilitare la cache del file, impostare questo valore su un percorso non valido, ad esempio:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This sets the path to an invalid device.</source>
          <target state="translated">Questo imposta il percorso su un dispositivo non valido.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Iff PowerShell can't write to the path, no error is returned, but you can see error reporting via a tracer:</source>
          <target state="translated">Se PowerShell non riesce a scrivere nel percorso, non verrà restituito alcun errore. Sarà tuttavia possibile visualizzare una segnalazione errori mediante un'utilità di traccia:</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>When writing out the cache, PowerShell will check for modules that no longer exist to avoid an unnecessarily large cache.</source>
          <target state="translated">Quando si scrive nella cache, PowerShell controllerà i moduli non più disponibili per evitare di aumentare inutilmente le dimensioni della cache.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Sometimes these checks are not desirable, in which case you can turn them off by setting</source>
          <target state="translated">Talvolta questi controlli non sono consigliabili. In questo caso, è possibile disattivarli impostando</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Setting this environment variable will take effect immediately in the current process.</source>
          <target state="translated">L'impostazione di questa variabile di ambiente avrà effetto immediato nel processo corrente.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Specifying module version</source>
          <target state="translated">Specifica della versione del modulo</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, <ph id="ph1">`using module`</ph> behaves the same way as other module-related constructions in PowerShell.</source>
          <target state="translated">In WMF 5.1 <ph id="ph1">`using module`</ph> si comporta esattamente come altre costruzioni correlate ai moduli di PowerShell.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Previously, you had no way to specify a particular module version; if there were multiple versions present, this resulted in an error.</source>
          <target state="translated">In precedenza, non era possibile specificare una versione particolare del modulo. Se erano presenti più versioni, veniva restituito un errore.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In WMF 5.1:</source>
          <target state="translated">In WMF 5.1:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`ModuleSpecification`</ph> <bpt id="p1">[</bpt>hashtable<ept id="p1">](https://msdn.microsoft.com/en-us/library/jj136290(v=vs.85).aspx)</ept>.</source>
          <target state="translated">L'utente può usare la <bpt id="p1">[</bpt>tabella hash<ept id="p1">](https://msdn.microsoft.com/en-us/library/jj136290(v=vs.85).aspx)</ept> <ph id="ph1">`ModuleSpecification`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This hashtable has the same format as <ph id="ph1">`Get-Module -FullyQualifiedName`</ph>.</source>
          <target state="translated">Questa tabella hash ha lo stesso formato di <ph id="ph1">`Get-Module -FullyQualifiedName`</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Esempio:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If there are multiple versions of the module, PowerShell uses the <bpt id="p1">**</bpt>same resolution logic<ept id="p1">**</ept> as <ph id="ph1">`Import-Module`</ph> and doesn't return an error--the same behavior as <ph id="ph2">`Import-Module`</ph> and <ph id="ph3">`Import-DscResource`</ph>.</source>
          <target state="translated">Se sono presenti più versioni del modulo, PowerShell usa la <bpt id="p1">**</bpt>stessa logica di risoluzione<ept id="p1">**</ept> di <ph id="ph1">`Import-Module`</ph> e non restituisce un errore. Comportamento analogo a <ph id="ph2">`Import-Module`</ph> e <ph id="ph3">`Import-DscResource`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>PowerShell console improvements</source>
          <target state="translated">Miglioramenti apportati alla console di PowerShell</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following changes have been made to Powershell.exe in WMF 5.1 to improve the console experience:</source>
          <target state="translated">Per migliorare l'uso della console, sono state apportate a powershell.exe in WMF 5.1 le modifiche seguenti:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>VT100 support</source>
          <target state="translated">Supporto per VT100</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Windows 10 added support for <bpt id="p1">[</bpt>VT100 escape sequences<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/desktop/mt638032(v=vs.85).aspx)</ept>.</source>
          <target state="translated">Windows 10 ha aggiunto il supporto per le <bpt id="p1">[</bpt>sequenze di escape VT100<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/desktop/mt638032(v=vs.85).aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>PowerShell will ignore certain VT100 formatting escape sequences when calculating table widths.</source>
          <target state="translated">Quando si calcola la larghezza delle tabelle, PowerShell ignorerà determinate sequenze di escape di formattazione VT100.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>PowerShell also added a new API that can be used in formatting code to determine if VT100 is supported.</source>
          <target state="translated">PowerShell ha inoltre aggiunto una nuova API che può essere usata per la formattazione di codice in modo da determinare se VT100 è supportato.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Here is a complete <bpt id="p1">[</bpt>example<ept id="p1">](https://gist.github.com/lzybkr/dcb973dccd54900b67783c48083c28f7)</ept> that can be used to highlight matches from Select-String.</source>
          <target state="translated">Ecco un <bpt id="p1">[</bpt>esempio<ept id="p1">](https://gist.github.com/lzybkr/dcb973dccd54900b67783c48083c28f7)</ept> completo che può essere usato per evidenziare le corrispondenze di Select-String.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Save the example in a file named <ph id="ph1">`MatchInfo.format.ps1xml`</ph>, then to use it, in your profile or elsewhere, run <ph id="ph2">`Update-FormatData -Prepend MatchInfo.format.ps1xml`</ph>.</source>
          <target state="translated">Salvare l'esempio in un file denominato <ph id="ph1">`MatchInfo.format.ps1xml`</ph> quindi per usarlo, nel profilo o altrove, eseguire <ph id="ph2">`Update-FormatData -Prepend MatchInfo.format.ps1xml`</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Note that VT100 escape sequences are only supported starting with the Windows 10 Anniversary update; they are not supported on earlier systems.</source>
          <target state="translated">Si noti che le sequenze di escape VT100 sono supportate solo a partire dall'aggiornamento Aniversary di Windows 10. Non sono supportate nei sistemi precedenti.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Vi mode support in PSReadline</source>
          <target state="translated">Supporto della modalità vi in PSReadline</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>PSReadline<ept id="p1">](https://github.com/lzybkr/PSReadLine)</ept> adds support for vi mode.</source>
          <target state="translated"><bpt id="p1">[</bpt>PSReadline<ept id="p1">](https://github.com/lzybkr/PSReadLine)</ept> aggiunge il supporto per la modalità vi.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>To use vi mode, run <ph id="ph1">`Set-PSReadline -EditMode vi`</ph>.</source>
          <target state="translated">Per usare la modalità vi, eseguire <ph id="ph1">`Set-PSReadline -EditMode vi`</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Redirected stdin w/ interactive input</source>
          <target state="translated">Stdin reindirizzato con input interattivo</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In earlier versions, starting PowerShell with <ph id="ph1">`powershell -File -`</ph> was required when stdin was redirected and you wanted to enter commands interactively.</source>
          <target state="translated">Nelle versioni precedenti, veniva richiesto l'avvio di PowerShell con <ph id="ph1">`powershell -File -`</ph> quando stdin veniva reindirizzato e si volevano immettere i comandi in modo interattivo.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>With WMF 5.1, this hard to discover option is no longer necessary, you can start powershell without any options, e.g. <ph id="ph1">`powershell`</ph>.</source>
          <target state="translated">Con WMF 5.1, questa opzione di difficile individuazione non è più necessaria. È infatti possibile avviare PowerShell senza opzioni, ad esempio <ph id="ph1">`powershell`</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Note that PSReadline does not currently supported redirected stdin, and the builtin commanding line editing experience with redirected stdin is extremely limited, e.g. arrow keys don't work.</source>
          <target state="translated">Si noti che PSReadline al momento non supporta stdin reindirizzato e la funzionalità di modifica della riga di comando integrata con stdin reindirizzato è estremamente limitata, ad esempio non è possibile usare i tasti di direzione.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A future release of PSReadline should address this issue.</source>
          <target state="translated">Questo problema verrà risolto nella versione successiva di PSReadline.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>PowerShell engine improvements</source>
          <target state="translated">Miglioramenti apportati al motore PowerShell</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The following improvements to the core PowerShell engine have been implemented in WMF 5.1:</source>
          <target state="translated">I miglioramenti seguenti apportati al motore di PowerShell principale sono stati implementati in WMF 5.1:</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Prestazioni</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Performance has improved in some important areas:</source>
          <target state="translated">Le prestazioni sono migliorate in alcune aree importanti:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Startup</source>
          <target state="translated">Avvio</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Pipelining to cmdlets like ForEach-Object and Where-Object is approximately 50% faster</source>
          <target state="translated">Pipelining ai cmdlet quali ForEach-Object e Where-Object più veloce del 50% circa</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Some example improvements (your results may vary depending your your hardware):</source>
          <target state="translated">Alcuni miglioramenti di esempio (i risultati possono variare in base all'hardware):</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Scenario</source>
          <target state="translated">Scenario</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>5.0 Time (ms)</source>
          <target state="translated">5.0 - Tempo (ms)</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>5.1 Time (ms)</source>
          <target state="translated">5.1 - Tempo (ms)</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>900</source>
          <target state="translated">900</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>250</source>
          <target state="translated">250</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>First ever PowerShell run:</source>
          <target state="translated">Prima esecuzione di PowerShell:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>30000</source>
          <target state="translated">30000</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>13000</source>
          <target state="translated">13000</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Command analysis cache built:</source>
          <target state="translated">Cache di analisi del comando integrata:</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>7000</source>
          <target state="translated">7000</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>520</source>
          <target state="translated">520</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>`1..1000000</source>
          <target state="translated">'1..1000000</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>% { }`</source>
          <target state="translated">% { }'</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>1400</source>
          <target state="translated">1400</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>750</source>
          <target state="translated">750</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>One change related to startup might impact some unsupported scenarios.</source>
          <target state="translated">Una modifica correlata all'avvio può avere impatto su alcuni scenari non supportati.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>PowerShell no longer reads the files <ph id="ph1">`$pshome\*.ps1xml`</ph> - these files have been converted to C# to avoid some file and CPU overhead of processing the XML files.</source>
          <target state="translated">PowerShell non legge i file <ph id="ph1">`$pshome\*.ps1xml`</ph>: questi file sono stati convertiti in C# per evitare il sovraccarico dell'elaborazione di file XML da parte di alcuni file e della CPU.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The files still exist to support V2 side-by-side, so if you change the file contents, it will not have any effect to V5, only V2.</source>
          <target state="translated">I file supportano ancora V2 side-by-side, pertanto se si modifica il contenuto del file, la modifica non avrà alcun impatto su V5, ma solo su V2.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Note that changing the contents of these files was never a supported scenario.</source>
          <target state="translated">Si noti che la modifica dei contenuti di questi file non ha mai costituito uno scenario supportato.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Another visible change is how PowerShell caches the exported commands and other information for modules that are installed on a system.</source>
          <target state="translated">Un'altra modifica evidente riguarda la modalità di memorizzazione nella cache dei comandi esportati e di altre informazioni relative ai moduli installati in un sistema da parte di PowerShell.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Previous, this cache was stored in the directory <ph id="ph1">`$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\CommandAnalysis`</ph>.</source>
          <target state="translated">In precedenza, la cache veniva archiviata nella directory <ph id="ph1">`$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\CommandAnalysis`</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, the cache is a single file <ph id="ph1">`$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\ModuleAnalysisCache`</ph>.</source>
          <target state="translated">In WMF 5.1, la cache è un singolo file <ph id="ph1">`$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\ModuleAnalysisCache`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>analysis_cache.md<ept id="p1">]()</ept> for more details.</source>
          <target state="translated">Per altre informazioni dettagliate, vedere <bpt id="p1">[</bpt>analysis_cache.md<ept id="p1">]()</ept>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Bug fixes</source>
          <target state="translated">Correzioni di bug</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following notable bugs were fixed:</source>
          <target state="translated">Sono stati corretti i bug importanti seguenti:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Module auto-discovery fully honors</source>
          <target state="translated">Rispetto completo del modulo auto-discovery</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Module auto-discovery (loading modules automatically without an explicit Import-Module when calling a command) was introduced in WMF 3.</source>
          <target state="translated">In WMF 3 è stato introdotto il modulo auto-discovery (caricamento automatico di moduli senza un'istanza esplicita di Import-Module quando si chiama un comando).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When introduced, PowerShell checked for commands in <ph id="ph1">`$PSHome\Modules`</ph> before using <ph id="ph2">`$env:PSModulePath`</ph>.</source>
          <target state="translated">Quando è stata introdotta tale versione, PowerShell cercava i comandi in <ph id="ph1">`$PSHome\Modules`</ph> prima di usare <ph id="ph2">`$env:PSModulePath`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>WMF 5.1 changes this behavior to honor <ph id="ph1">`$env:PSModulePath`</ph> completely.</source>
          <target state="translated">WMF 5.1 modifica questo comportamento per rispettare <ph id="ph1">`$env:PSModulePath`</ph> completamente.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This allows for a user-authored module that defines commands provided by PowerShell (e.g. <ph id="ph1">`Get-ChildItem`</ph>) to be auto-loaded and correctly overriding the built-in command.</source>
          <target state="translated">In questo modo, un modulo creato dall'utente che definisce i comandi di PowerShell (ad esempio <ph id="ph1">`Get-ChildItem`</ph>) può essere caricato automaticamente e può sostituire correttamente il comando integrato.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>File redirection no longer hard-codes</source>
          <target state="translated">Reindirizzamento del file non più come hardcoded</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In all previous versions of PowerShell, it was impossible to control the file encoding used by the file redirection operator, e.g. <ph id="ph1">`get-childitem &gt; out.txt`</ph> because PowerShell added <ph id="ph2">`-Encoding Unicode`</ph>.</source>
          <target state="translated">In tutte le versioni precedenti di PowerShell, non era possibile controllare la codifica del file usato dall'operatore di reindirizzamento di file, ad esempio <ph id="ph1">`get-childitem &gt; out.txt`</ph> perché PowerShell aveva aggiunto <ph id="ph2">`-Encoding Unicode`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Starting with WMF 5.1, you can now change the file encoding of redirection by setting <ph id="ph1">`$PSDefaultParameterValues`</ph>, e.g.</source>
          <target state="translated">A partire da WMF 5.1, è ora possibile modificare la codifica del file di reindirizzamento impostando <ph id="ph1">`$PSDefaultParameterValues`</ph>, ad esempio</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Fixed a regression in accessing members of</source>
          <target state="translated">Correzione di una regressione nell'accesso dei membri di</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>A regression introduced in WMF 5.0 broke accessing members of <ph id="ph1">`System.Reflection.RuntimeType`</ph>, e.g. <ph id="ph2">`[int].ImplementedInterfaces`</ph>.</source>
          <target state="translated">Una regressione introdotta in WMF 5.0 interrompeva l'accesso ai membri di <ph id="ph1">`System.Reflection.RuntimeType`</ph>, ad esempio <ph id="ph2">`[int].ImplementedInterfaces`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>This bug has been fixed in WMF5.1.</source>
          <target state="translated">Questo bug è stato risolto in WMF 5.1.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Fixed some issues with COM objects</source>
          <target state="translated">Risolti alcuni problemi con gli oggetti COM</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>WMF 5.0 introduced a new COM binder for invoking methods on COM objects and accessing properties of COM objects.</source>
          <target state="translated">In WMF 5.0 è stato introdotto un nuovo strumento di associazione COM per richiamare metodi su oggetti COM e accedere alle proprietà degli oggetti COM.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This new binder improved performance significantly but also introduced some bugs which have been fixed in WMF5.1.</source>
          <target state="translated">Questo nuovo strumento di associazione ha migliorato in modo significativo le prestazioni e ha inoltre introdotto alcuni bug che sono stati corretti in WMF 5.1.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Argument conversions were not always performed correctly</source>
          <target state="translated">Le conversioni di argomenti non venivano sempre eseguite correttamente</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>In the following example:</source>
          <target state="translated">Nell'esempio seguente:</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The SendKeys method expects a string, but PowerShell did not convert the char to a string, deferring the conversion to IDispatch::Invoke, which uses VariantChangeType to do the conversion, which in this example resulted in sending the keys '1', '7', and '3' instead of the expected Volume.Mute key.</source>
          <target state="translated">Il metodo SendKeys prevede una stringa, ma PowerShell non converte il carattere in una stringa, rinviando la conversione a IDispatch::Invoke che usa VariantChangeType per eseguire la conversione. In questo esempio, ciò ha comportato l'invio di chiavi '1', '7' e '3' anziché la chiave Volume.Mute prevista.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Enumerable COM objects not always handled correctly</source>
          <target state="translated">Gli oggetti COM enumerabili non venivano sempre gestiti correttamente</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PowerShell normally enumerates most enumerable objects, but a regression introduced in WMF 5.0 prevented the enumeration of COM objects that implement IEnumerable.</source>
          <target state="translated">PowerShell in genere enumera la maggior parte degli oggetti enumerabili, ma una regressione introdotta in WMF 5.0 impediva l'enumerazione di oggetti COM che implementano IEnumerable.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In the above example, WMF 5.0 incorrectly wrote the Scripting.Dictionary to the pipeline instead of enumerating the key value pairs.</source>
          <target state="translated">Nell'esempio precedente, WMF 5.0 ha scritto in modo errato Scripting.Dictionary nella pipeline anziché enumerare le coppie chiave-valore.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>was not allowed inside classes</source>
          <target state="translated">non è consentito all'interno delle classi</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>WMF5 introduced classes with validation of type literals used in classes.</source>
          <target state="translated">In WMF 5 sono state introdotte classi con la convalida dei valori letterali di tipo per le classi.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>looks like a type literal but is not a true .Net type.</source>
          <target state="translated">è simile a un valore letterale di tipo ma non è un tipo .Net.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>WMF5 incorrectly reported an error on <ph id="ph1">`[ordered]`</ph> inside a class:</source>
          <target state="translated">WMF 5 restituiva erroneamente un errore relativo a <ph id="ph1">`[ordered]`</ph> in una classe:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Help on About topics with multiple versions does not work</source>
          <target state="translated">Supporto non funzionante sugli argomenti della Guida con più versioni</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Before WMF 5.1, if you had multiple versions of a module installed and they all shared a help topic, for example, about_PSReadline, <ph id="ph1">`help about_PSReadline`</ph> would return multiple topics with no obvious way to view the real help.</source>
          <target state="translated">Prima di WMF 5.1, se erano installate più versioni di un modulo e tutte condividevano un argomento della Guida, ad esempio about_PSReadline, <ph id="ph1">`help about_PSReadline`</ph> restituiva più argomenti e non era possibile visualizzare la Guida vera e propria.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>WMF 5.1 fixes this by returning the help for the latest version of the topic.</source>
          <target state="translated">In WMF 5.1 il problema è stato risolto restituendo la Guida per la versione più recente dell'argomento.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Get-Help does not provide a way to specify which version you want help for.</source>
          <target state="translated">Get-Help non fornisce un modo per specificare la versione per la quale si vuole visualizzare la Guida.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>To work around this, navigate to the modules directory and view the help directly with a tool like your favorite editor.</source>
          <target state="translated">Per risolvere il problema, passare alla directory dei moduli e visualizzare la Guida direttamente con uno strumento come il proprio editor preferito.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>OneGet improvements</source>
          <target state="translated">Miglioramenti apportati a OneGet</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>WMF 5.1 includes a number of fixes and improvements to address some of the user experience gaps in the WMF 5.0 release.</source>
          <target state="translated">WMF 5.1 include una serie di correzioni e miglioramenti per risolvere alcuni dei problemi rilevati dagli utenti della versione WMF 5.0.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Version alias removed</source>
          <target state="translated">Rimozione dell'alias della versione</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Scenario<ept id="p1">**</ept>: If you have version 1.0 and 2.0 of a package, P1, installed on your system, and you want to uninstall version 1.0, you would run "uninstall-package -name P1 -version 1.0" and expect version 1.0 to be uninstalled after running the cmdlet.</source>
          <target state="translated"><bpt id="p1">**</bpt>Scenario<ept id="p1">**</ept>: se si dispone delle versioni 1.0 e 2.0 di un pacchetto, P1, installate nel sistema e si vuole disinstallare la versione 1.0, è necessario eseguire "uninstall-package -name P1 -version 1.0" e attendere che la versione 1.0 venga disinstallata dopo l'esecuzione del cmdlet.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>However the result is that version 2.0 gets uninstalled.</source>
          <target state="translated">Tuttavia, il risultato è che viene disinstallata la versione 2.0.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This occurs because the "-version" parameter is an alias of the "-minimumversion" parameter.</source>
          <target state="translated">Ciò si verifica perché il parametro "-version" è un alias del parametro "-minimumversion".</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>When OneGet is looking for a qualified package with the minimum version of 1.0, it returns the latest version.</source>
          <target state="translated">Quando OneGet esegue la ricerca di un pacchetto qualificato con la versione minima 1.0, restituisce la versione più recente.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>This behavior is expected in normal cases because finding the latest version is usually the desired result.</source>
          <target state="translated">Questo comportamento è previsto nei casi normali, perché trovare la versione più recente è in genere il risultato desiderato.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>However, it should not apply to the uninstall-package case.</source>
          <target state="translated">Tuttavia, non dovrebbe applicarsi al caso di uninstall-package.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Solution<ept id="p1">**</ept>: In WMF 5.1, the -version alias is removed entirely in OneGet and PowerShellGet.</source>
          <target state="translated"><bpt id="p1">**</bpt>Soluzione<ept id="p1">**</ept>: in WMF 5.1 l'alias -version viene rimosso completamente in OneGet e PowerShellGet.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Multiple prompts for bootstrapping the NuGet provider</source>
          <target state="translated">Più richieste per l'avvio del provider NuGet</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Scenario<ept id="p1">**</ept>: When you run Find-Module or Install-module or other OneGet cmdlets on your computer for the first time, OneGet tries to bootstrap the NuGet provider.</source>
          <target state="translated"><bpt id="p1">**</bpt>Scenario<ept id="p1">**</ept>: quando si esegue Find-Module o Install-Module o altri cmdlet OneGet nel computer in uso per la prima volta, OneGet tenta di avviare il provider NuGet.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>It does this because the PowerShellGet provider also uses the NuGet provider to download PowerShell modules.</source>
          <target state="translated">Ciò avviene perché il provider PowerShellGet usa anche il provider NuGet per scaricare i moduli di PowerShell.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>OneGet then prompts the user for permission to install the NuGet provider.</source>
          <target state="translated">OneGet quindi chiede all'utente l'autorizzazione per installare il provider NuGet.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>After the user selects "yes" for the bootstrapping, the latest version of the NuGet provider will be installed.</source>
          <target state="translated">Dopo che l'utente seleziona "Sì" per l'avvio, verrà installata la versione più recente del provider NuGet.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>However, in some cases, when you have an old version of NuGet provider installed on your computer, the older version of NuGet sometimes gets loaded first into the PowerShell session (that's the race condition in OneGet).</source>
          <target state="translated">Tuttavia, in alcuni casi, quando si dispone di una versione precedente del provider NuGet installata nel computer in uso, in alcuni casi viene caricata per prima la versione precedente di NuGet nella sessione di PowerShell. Si tratta della race condition di OneGet.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>However PowerShellGet requires the later version of the NuGet provider to work, so PowerShellGet asks the OneGet for bootstrapping the NuGet provider again.</source>
          <target state="translated">Tuttavia PowerShellGet richiede la versione più recente del provider NuGet, pertanto PowerShellGet chiede a OneGet di avviare nuovamente il provider NuGet.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This results in multiple prompts for bootstrapping the NuGet provider.</source>
          <target state="translated">Ciò comporta l'esecuzione di più richieste di avvio del provider NuGet.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Solution<ept id="p1">**</ept>: In WMF 5.1, OneGet now loads the latest version of the NuGet provider to avoid multiple prompts for bootstrapping the NuGet provider.</source>
          <target state="translated"><bpt id="p1">**</bpt>Soluzione<ept id="p1">**</ept>: In WMF 5.1, OneGet carica la versione più recente del provider NuGet per evitare l'esecuzione di più richieste di avvio del provider NuGet.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>You could also work around this issue by manually deleting the old version of the NuGet provider (NuGet-Anycpu.exe) if exists from $env:ProgramFiles\PackageManagement\ProviderAssemblies $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies</source>
          <target state="translated">È possibile aggirare il problema anche eliminando manualmente la versione precedente del provider NuGet (NuGet-Anycpu.exe), se presente, da $env:Programmi\PackageManagement\ProviderAssemblies $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Support for OneGet on computers with intranet access only</source>
          <target state="translated">Supporto per OneGet nei computer solo con accesso Intranet</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Scenario<ept id="p1">**</ept>: In WMF 5.0, OneGet did not support computers that have only intranet (but not internet) access.</source>
          <target state="translated"><bpt id="p1">**</bpt>Scenario<ept id="p1">**</ept>: In WMF 5.0, OneGet non supportava i computer che disponevano solo dell'accesso Intranet, ma non Internet.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Solution<ept id="p1">**</ept>: In WMF 5.1, you can follow these steps to allow intranet computers to use OneGet:</source>
          <target state="translated"><bpt id="p1">**</bpt>Soluzione<ept id="p1">**</ept>: In WMF 5.1, è possibile seguire questa procedura per consentire ai computer Intranet di usare OneGet:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Download the NuGet provider using another computer that has an internet connection by using Install-PackageProvider NuGet.</source>
          <target state="translated">Scaricare il provider NuGet usando un altro computer che dispone di una connessione Internet tramite Install-PackageProvider NuGet.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Find the NuGet provider under either  $env:ProgramFiles\PackageManagement\ProviderAssemblies\nuget  or  $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies\nuget.</source>
          <target state="translated">Trovare il provider NuGet in $env:Programmi\PackageManagement\ProviderAssemblies\nuget o $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies\nuget.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Copy the binaries to a folder or network share location that the intranet computer can access, and then install the NuGet provider with "Install-PackageProvider NuGet -Source <ph id="ph1">&lt;Path to folder&gt;</ph>".</source>
          <target state="translated">Copiare i file binari in una cartella o in una condivisione di rete a cui il computer Intranet può accedere e quindi installare il provider NuGet con "Install-PackageProvider NuGet -Source <ph id="ph1">&lt;Path to folder&gt;</ph>".</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Event logging improvements</source>
          <target state="translated">Miglioramenti apportati alla registrazione di eventi</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When you install packages, you are changing the state of the computer.</source>
          <target state="translated">Quando si installano i pacchetti, si modifica lo stato del computer.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, OneGet now logs events to the Windows event log for install, uninstall, and save-package activities.</source>
          <target state="translated">In WMF 5.1, OneGet registra gli eventi nel registro eventi di Windows per installare, disinstallare e salvare le attività del pacchetto.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The Event channel is the same as for PowerShell, that is, Microsoft-Windows-PowerShell, Operational.</source>
          <target state="translated">Il canale dell'evento è identico a quello di PowerShell, ovvero Microsoft-Windows-PowerShell/Operational.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Support for basic authentication</source>
          <target state="translated">Supporto per l'autenticazione di base</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, OneGet supports finding and installing packages from a repository that requires basic authentication.</source>
          <target state="translated">In WMF 5.1, OneGet supporta la ricerca e l'installazione dei pacchetti da un repository che richiede l'autenticazione di base.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>You can supply your credentials to the Find-Package and Install-Package cmdlets.</source>
          <target state="translated">È possibile fornire le credenziali ai cmdlet Find-Package e Install-Package.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Support for using OneGet behind a proxy</source>
          <target state="translated">Supporto per l'uso di OneGet protetto da un proxy</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, OneGet now takes new proxy parameters: -ProxyCredential and -Proxy.</source>
          <target state="translated">In WMF 5.1, OneGet accetta ora nuovi parametri proxy: -ProxyCredential e -Proxy.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Using these parameters, you can specify the proxy URL and credentials to OneGet cmdlets.</source>
          <target state="translated">Grazie a questi parametri è possibile specificare le credenziali e l'URL del proxy nei cmdlet di OneGet.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>By default, system proxy settings are used.</source>
          <target state="translated">Per impostazione predefinita, vengono usate le impostazioni proxy del sistema.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Ad esempio:</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>