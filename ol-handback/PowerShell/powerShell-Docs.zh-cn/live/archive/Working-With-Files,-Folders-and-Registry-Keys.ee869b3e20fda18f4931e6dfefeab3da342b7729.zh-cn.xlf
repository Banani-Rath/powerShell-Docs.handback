<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="md" source-language="en-US" target-language="zh-cn">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fcdacb648a9fb5feb9f09f9f7219ed220ea24ccb</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-04046aa" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Working With Files, Folders and Registry Keys</source>
          <target state="translated">使用文件、文件夹和注册表项</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Working With Files, Folders and Registry Keys</source>
          <target state="translated">使用文件、文件夹和注册表项</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Windows PowerShell uses the noun <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> to refer to items found on a Windows PowerShell drive.</source>
          <target state="translated">Windows PowerShell 使用名词 <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> 来引用在 Windows PowerShell 驱动器上找到的项。</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>When dealing with the Windows PowerShell FileSystem provider, an <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> might be a file, a folder, or the Windows PowerShell drive.</source>
          <target state="translated">处理 Windows PowerShell FileSystem 提供程序时，<bpt id="p1">**</bpt>Item<ept id="p1">**</ept> 可能是文件、文件夹或 Windows PowerShell 驱动器。</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Listing and working with these items is a critical basic task in most administrative settings, so we want to discuss these tasks in detail.</source>
          <target state="translated">列出并使用这些项是大部分管理设置中的关键基本任务，因此我们想要详细讨论这些任务。</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Enumerating Files, Folders, and Registry Keys (Get\-ChildItem)</source>
          <target state="translated">枚举文件、文件夹和注册表项 (Get-ChildItem)</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Since getting a collection of items from a particular location is such a common task, the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet is designed specifically to return all items found within a container such as a folder.</source>
          <target state="translated">由于从特定位置获取项的集合是很常见的任务，因此 <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet 专门用于返回在容器（例如某个文件夹）中找到的所有项。</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you want to return all files and folders that are contained directly within the folder C:\\Windows, type:</source>
          <target state="translated">如果你希望返回直接包含在文件夹 C:\Windows 内的所有文件和文件夹，请键入：</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The listing looks similar to what you would see when you enter the <bpt id="p1">**</bpt>dir<ept id="p1">**</ept> command in <bpt id="p2">**</bpt>Cmd.exe<ept id="p2">**</ept>, or the <bpt id="p3">**</bpt>ls<ept id="p3">**</ept> command in a UNIX command shell.</source>
          <target state="translated">列出操作看起来和你在 <bpt id="p2">**</bpt>Cmd.exe<ept id="p2">**</ept> 中输入 <bpt id="p1">**</bpt>dir<ept id="p1">**</ept> 命令或在 UNIX 命令 shell 中输入 <bpt id="p3">**</bpt>ls<ept id="p3">**</ept> 命令时类似。</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can perform very complex listings by using parameters of the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">你可以通过使用 <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet 的参数来执行非常复杂的列出操作。</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>We will look at a few scenarios next.</source>
          <target state="translated">接下来，我们将介绍一些方案。</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can see the syntax the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet by typing:</source>
          <target state="translated">你可以通过键入以下内容来查看 <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet 的语法：</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>These parameters can be mixed and matched to get highly customized output.</source>
          <target state="translated">可以混合并匹配这些参数以获取高度自定义的输出。</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Listing all Contained Items (\-Recurse)</source>
          <target state="translated">列出所有包含的项 (-Recurse)</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>To see both the items inside a Windows folder and any items that are contained within the subfolders, use the <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get\-ChildItem<ept id="p2">**</ept>.</source>
          <target state="translated">若要查看 Windows 文件夹内的项和子文件夹内包含的任何项，请使用 <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept> 的 <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> 参数。</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The listing displays everything within the Windows folder and the items in its subfolders.</source>
          <target state="translated">此列出操作显示 Windows 文件夹内的所有内容及其子文件夹中的项。</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Filtering Items by Name (\-Name)</source>
          <target state="translated">按名称筛选项 (-Name)</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To display only the names of items, use the <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get\-Childitem<ept id="p2">**</ept>:</source>
          <target state="translated">若要仅显示项的名称，请使用 <bpt id="p2">**</bpt>Get-Childitem<ept id="p2">**</ept> 的 <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> 参数：</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Forcibly Listing Hidden Items (\-Force)</source>
          <target state="translated">强制列出隐藏的项 (-Force)</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Items that are normally invisible in File Explorer or Cmd.exe are not displayed in the output of a <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> command.</source>
          <target state="translated">正常情况下在文件资源管理器或 Cmd.exe 中不可见的项不会在 <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> 命令的输出中显示。</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>To display hidden items, use the <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get\-ChildItem<ept id="p2">**</ept>.</source>
          <target state="translated">若要显示隐藏的项，请使用 <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept> 的 <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> 参数。</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This parameter is named Force because you can forcibly override the normal behavior of the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> command.</source>
          <target state="translated">此参数的名称为 Force，因为你可以强制替代 <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> 命令的正常行为。</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Force is a widely used parameter that forces an action that a cmdlet would not normally perform, although it will not perform any action that compromises the security of the system.</source>
          <target state="translated">Force 是一个广泛使用的参数，此参数可强制执行 cmdlet 通常不会执行的操作，尽管它不会执行任何危害系统安全的操作。</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Matching Item Names with Wildcards</source>
          <target state="translated">使用通配符匹配项名称</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>The Get\-ChildItem<ept id="p1">**</ept> command accepts wildcards in the path of the items to list.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> 命令支持要列出的项路径中的通配符。</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Because wildcard matching is handled by the Windows PowerShell engine, all cmdlets that accepts wildcards use the same notation and have the same matching behavior.</source>
          <target state="translated">由于通配符匹配由 Windows PowerShell 引擎处理，因此接受通配符的所有 cmdlet 使用相同的表示法，并具有相同的匹配行为。</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell wildcard notation includes:</source>
          <target state="translated">Windows PowerShell 通配符表示法包括：</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Asterisk (\*)matches zero or more occurrences of any character.</source>
          <target state="translated">星号 (*) 匹配零个或多个出现的任何字符。</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Question mark (?) matches exactly one character.</source>
          <target state="translated">问号 (?) 完全匹配一个字符。</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Left bracket (\[) character and right bracket (]) character surround a set of characters to be matched.</source>
          <target state="translated">左括号 ([) 字符和右括号 (]) 字符括起一组要匹配的字符。</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Here are some examples of how wildcard specification works.</source>
          <target state="translated">下面是一些通配符规则工作原理的示例。</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>To find all files in the Windows directory with the suffix <bpt id="p1">**</bpt>.log<ept id="p1">**</ept> and exactly five characters in the base name, enter the following command:</source>
          <target state="translated">若要在 Windows 目录中查找带有后缀 <bpt id="p1">**</bpt>.log<ept id="p1">**</ept> 并且基名称中正好有五个字符的所有文件，请输入以下命令：</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To find all files that begin with the letter <bpt id="p1">**</bpt>x<ept id="p1">**</ept> in the Windows directory, type:</source>
          <target state="translated">若要在 Windows 目录中查找以字母 <bpt id="p1">**</bpt>x<ept id="p1">**</ept> 开头的所有文件，请键入：</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To find all files whose names begin with <bpt id="p1">**</bpt>x<ept id="p1">**</ept> or <bpt id="p2">**</bpt>z<ept id="p2">**</ept>, type:</source>
          <target state="translated">若要查找名称以 <bpt id="p1">**</bpt>x<ept id="p1">**</ept> 或 <bpt id="p2">**</bpt>z<ept id="p2">**</ept> 开头的所有文件，请键入：</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Excluding Items (\-Exclude)</source>
          <target state="translated">排除项 (-Exclude)</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>You can exclude specific items by using the <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> parameter of Get\-ChildItem.</source>
          <target state="translated">你可以通过使用 Get-ChildItem 的 <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> 参数来排除特定项。</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This lets you perform complex filtering in a single statement.</source>
          <target state="translated">这可让你在单个声明中执行复杂的筛选。</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example, suppose you are trying to find the Windows Time Service DLL in the System32 folder, and all you can remember about the DLL name is that it begins with "W" and has "32" in it.</source>
          <target state="translated">例如，假设你正尝试在 System32 文件夹中查找 Windows Time Service DLL，但是你只记得 DLL 名称以“W”开头并且其中有“32”。</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>An expression like <bpt id="p1">**</bpt>w\&amp;#42;32\&amp;#42;.dll<ept id="p1">**</ept> will find all DLLs that satisfy the conditions, but it may also return the Windows 95 and 16\-bit Windows compatibility DLLs that include "95" or "16" in their names.</source>
          <target state="translated">类似于 <bpt id="p1">**</bpt>w&amp;#42;32&amp;#42;.dll<ept id="p1">**</ept> 的表达式将找到满足条件的所有 DLL，但它也可能返回名称中包含“95”或“16”的 Windows 95 和 16 位 Windows 兼容性 DLL。</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can omit files that have any of these numbers in their names by using the <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> parameter with the pattern <bpt id="p2">**</bpt>\&amp;#42;\[9516]\&amp;#42;<ept id="p2">**</ept>:</source>
          <target state="translated">你可以通过将 <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> 参数与模式 <bpt id="p2">**</bpt>&amp;#42;[9516]&amp;#42;<ept id="p2">**</ept> 一起使用来忽略名称中含有任意这些数字的文件：</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>PS&gt; Get-ChildItem -Path C:\WINDOWS\System32\w<bpt id="p1">*</bpt>32<ept id="p1">*</ept>.dll -Exclude <bpt id="p2">*</bpt>[9516]<ept id="p2">*</ept></source>
          <target state="translated">PS&gt; Get-ChildItem -Path C:\Windows\System32\w<bpt id="p1">*</bpt>32<ept id="p1">*</ept>.dll -Exclude <bpt id="p2">*</bpt>[9516]<ept id="p2">*</ept></target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Directory: Microsoft.PowerShell.Core\FileSystem::C:\WINDOWS\System32</source>
          <target state="translated">目录：Microsoft.PowerShell.Core\FileSystem::C:\Windows\System32</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Mode                LastWriteTime     Length Name
----                -------------     ------ ----
-a---        2004-08-04   8:00 AM     174592 w32time.dll</source>
          <target state="translated">模式                上次写入时间     长度名称
----                -------------     ------ ----
-a---        2004-08-04   上午 8:00     174592 w32time.dll</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>-a---        2004-08-04   8:00 AM      22016 w32topl.dll</source>
          <target state="translated">-a---        2004-08-04   上午 8:00     22016 w32topl.dll</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>-a---        2004-08-04   8:00 AM     101888 win32spl.dll</source>
          <target state="translated">-a---        2004-08-04   上午 8:00     101888 win32spl.dll</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>-a---        2004-08-04   8:00 AM     172032 wldap32.dll</source>
          <target state="translated">-a---        2004-08-04   上午 8:00     172032 wldap32.dll</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>-a---        2004-08-04   8:00 AM     264192 wow32.dll</source>
          <target state="translated">-a---        2004-08-04   上午 8:00     264192 wow32.dll</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>-a---        2004-08-04   8:00 AM      82944 ws2_32.dll</source>
          <target state="translated">-a---        2004-08-04   上午 8:00     82944 ws2_32.dll</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>-a---        2004-08-04   8:00 AM      42496 wsnmp32.dll</source>
          <target state="translated">-a---        2004-08-04   上午 8:00     42496 wsnmp32.dll</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>-a---        2004-08-04   8:00 AM      22528 wsock32.dll</source>
          <target state="translated">-a---        2004-08-04   上午 8:00     22528 wsock32.dll</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>-a---        2004-08-04   8:00 AM      18432 wtsapi32.dll</source>
          <target state="translated">-a---        2004-08-04   上午 8:00     18432 wtsapi32.dll</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Mixing Get\-ChildItem Parameters</source>
          <target state="translated">混合使用 Get-ChildItem 参数</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>You can use several of the parameters of the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet in the same command.</source>
          <target state="translated">你可以在同一命令中使用 <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet 的多个参数。</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Before you mix parameters, be sure that you understand wildcard matching.</source>
          <target state="translated">在混合使用参数之前，请确保你了解通配符匹配。</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For example, the following command returns no results:</source>
          <target state="translated">例如，以下命令不会返回任何结果：</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>There are no results, even though there are two DLLs that begin with the letter "z" in the Windows folder.</source>
          <target state="translated">即使 Windows 文件夹中有两个以字母“z”开头的 DLL，也没有结果。</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>No results were returned because we specified the wildcard as part of the path.</source>
          <target state="translated">由于我们已将通配符指定为路径的一部分，因此未返回任何结果。</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Even though the command was recursive, the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet restricted the items to those that are in the Windows folder with names ending with ".dll".</source>
          <target state="translated">即使命令是递归的，<bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet 也会将项限制为 Windows 文件夹中名称以“.dll”结尾的项。</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>To specify a recursive search for files whose names match a special pattern, use the <bpt id="p1">**</bpt>\-Include<ept id="p1">**</ept> parameter.</source>
          <target state="translated">若要指定名称匹配特殊模式的文件的递归搜索，请使用 <bpt id="p1">**</bpt>-Include<ept id="p1">**</ept> 参数。</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>