<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Working-with-Software-Installations.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9f60be9bebe9dfaa98f495c8e9a9c0d8c2fa5cc2</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-39517ae" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Working with Software Installations</source>
          <target state="translated">處理軟體安裝</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Working with Software Installations</source>
          <target state="translated">處理軟體安裝</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Applications that are designed to use Windows Installer can be accessed through WMI's <bpt id="p1">**</bpt>Win32\_Product<ept id="p1">**</ept> class, but not all applications in use today use the Windows Installer.</source>
          <target state="translated">設計成使用 Windows Installer 的應用程式可以透過 WMI 的 <bpt id="p1">**</bpt>Win32\_Product<ept id="p1">**</ept> 類別存取，但並非所有現今使用的應用程式都使用 Windows Installer。</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Because the Windows Installer provides the widest range of standard techniques for working with installable applications, we will focus primarily on those applications.</source>
          <target state="translated">因為 Windows Installer 對處理可安裝的應用程式提供最廣泛的標準技術，我們主要將著重在那些應用程式。</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Applications that use alternate setup routines will generally not be managed by the Windows Installer.</source>
          <target state="translated">使用替代安裝常式的應用程式通常不受 Windows Installer 管理。</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Specific techniques for working with those applications will depend on the installer software and decisions made by the application developer.</source>
          <target state="translated">處理那些應用程式的特定技術將視安裝程式軟體與應用程式開發人員的決定而定。</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Applications that are installed by copying the application files to the computer usually cannot be managed by using techniques discussed here.</source>
          <target state="translated">透過將應用程式檔案複製到電腦來安裝的應用程式通常無法使用這裡討論的技術來管理。</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>You can manage these applications as files and folders by using the techniques discussed in the "Working With Files and Folders" section.</source>
          <target state="translated">您可以使用＜處理檔案與資料夾＞一節中所討論的技術，將這些應用程式當成檔案與資料夾來管理。</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Listing Windows Installer Applications</source>
          <target state="translated">列出 Windows Installer 應用程式</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To list the applications installed with the Windows Installer on a local or remote system, use the following simple WMI query:</source>
          <target state="translated">若要列出在本機或遠端系統上使用 Windows Installer 安裝的應用程式，請使用下列簡單的 WMI 查詢：</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>To display all of the properties of the Win32\_Product object to the display, use the Properties parameter of the formatting cmdlets, such as the Format\-List cmdlet, with a value of \* (all).</source>
          <target state="translated">若要在螢幕上顯示 Win32_Product 物件的所有屬性，請使用格式化 Cmdlet (例如 Format-List Cmdlet) 的 Properties 參數，加上 * (全部) 值。</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Or, you could use the <bpt id="p1">**</bpt>Get\-WmiObject Filter<ept id="p1">**</ept> parameter to select only Microsoft .NET Framework 2.0.</source>
          <target state="translated">或者，您可以使用 <bpt id="p1">**</bpt>Get-WmiObject Filter<ept id="p1">**</ept> 參數來只選取 Microsoft .NET Framework 2.0。</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Because the filter used in this command is a WMI filter, it uses WMI Query Language (WQL) syntax, not Windows PowerShell syntax.</source>
          <target state="translated">因為此命令中使用的篩選器是 WMI 篩選器，所以它使用 WMI 查詢語言 (WQL) 語法，而不是 Windows PowerShell 語法。</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Instead,:</source>
          <target state="translated">而是：</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Note that WQL queries frequently use characters, such as spaces or equal signs, that have a special meaning in Windows PowerShell.</source>
          <target state="translated">請注意，WQL 查詢經常使用在 Windows PowerShell 中有特殊意義的字元，例如空格或等號。</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>For this reason, it is prudent to always enclose the value of the Filter parameter in quotation marks.</source>
          <target state="translated">基於此原因，最好一律將 Filter 參數的值用引號括住。</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You can also use the Windows PowerShell escape character, a backtick (\`), although it may not improve readability.</source>
          <target state="translated">您也可以使用 Windows PowerShell 的逸出字元倒引號 (\`)，但這麼做可能無法改善可讀性。</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The following command is equivalent to the previous command and returns the same results, but uses the backtick to escape special characters, instead of quoting the entire filter string.</source>
          <target state="translated">下列命令相當於先前的命令且傳回相同的結果，但它使用倒引號來逸出特殊字元，而不是將整個篩選字串用引號括住。</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>To list only the properties that interest you, use the Property parameter of the formatting cmdlets to list the desired properties.</source>
          <target state="translated">若只要列出您感興趣的屬性，請使用格式化 Cmdlet 的 Property 參數來列出想要的屬性。</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Finally, to find only the names of installed applications, a simple <bpt id="p1">**</bpt>Format\-Wide<ept id="p1">**</ept> statement simplifies the output:</source>
          <target state="translated">最後，如果只要尋找已安裝應用程式的名稱，使用簡單的 <bpt id="p1">**</bpt>Format-Wide<ept id="p1">**</ept> 陳述式可簡化輸出：</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Although we now have several ways to look at applications that used the Windows Installer for installation, we have not considered other applications.</source>
          <target state="translated">雖然我們現在有數種方式可查看使用 Windows Installer 安裝的應用程式，但我們還沒有考慮其他應用程式。</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Because most standard applications register their uninstaller with Windows, we can work with those locally by finding them in the Windows registry.</source>
          <target state="translated">因為大部分的標準應用程式會向 Windows 登錄其解除安裝程式，所以我們可以透過在 Windows 登錄中尋找這些應用程式，以在本機處理它們。</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Listing All Uninstallable Applications</source>
          <target state="translated">列出所有可解除安裝應用程式</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Although there is no guaranteed way to find every application on a system, it is possible to find all programs with listings displayed in the Add or Remove Programs dialog box.</source>
          <target state="translated">雖然沒有方法可以保證找出系統上所有應用程式，但可以尋找 [新增或移除程式] 對話方塊顯示之清單中的所有程式。</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Add or Remove Programs finds these applications in the following registry key:</source>
          <target state="translated">[新增或移除程式] 會在下列登錄機碼中尋找這些應用程式：</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>HKEY\_LOCAL\_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall<ept id="p1">**</ept>.</source>
          <target state="translated"><bpt id="p1">**</bpt>HKEY\_LOCAL\_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall<ept id="p1">**</ept>.</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>We can also examine this key to find applications.</source>
          <target state="translated">我們也可以檢查此機碼來尋找應用程式。</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>To make it easier to view the Uninstall key, we can map a Windows PowerShell drive to this registry location:</source>
          <target state="translated">為了讓您更輕鬆地檢視 Uninstall 機碼，我們可以將 Windows PowerShell 磁碟機對應至此登錄位置：</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>HKLM:<ept id="p1">**</ept> drive is mapped to the root of <bpt id="p2">**</bpt>HKEY\_LOCAL\_MACHINE<ept id="p2">**</ept>, so we used that drive in the path to the Uninstall key.</source>
          <target state="translated"><bpt id="p1">**</bpt>HKLM:<ept id="p1">**</ept> 磁碟機已對應到 <bpt id="p2">**</bpt>HKEY\_LOCAL\_MACHINE<ept id="p2">**</ept> 的根目錄，因此我們在指向 Uninstall 機碼的路徑中使用該磁碟機。</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Instead of <bpt id="p1">**</bpt>HKLM:<ept id="p1">**</ept> we could have specified the registry path by using either <bpt id="p2">**</bpt>HKLM<ept id="p2">**</ept> or <bpt id="p3">**</bpt>HKEY\_LOCAL\_MACHINE<ept id="p3">**</ept>.</source>
          <target state="translated">除了 <bpt id="p1">**</bpt>HKLM:<ept id="p1">**</ept> 之外，我們可以使用 <bpt id="p2">**</bpt>HKLM<ept id="p2">**</ept> 或 <bpt id="p3">**</bpt>HKEY\_LOCAL\_MACHINE<ept id="p3">**</ept> 其中之一指定登錄路徑。</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The advantage of using an existing registry drive is that we can use tab\-completion to fill in the keys names, so we do not need to type them.</source>
          <target state="translated">使用現有登錄磁碟機的好處是可以使用 Tab 鍵自動完成來填入機碼名稱，因此我們不需要手動輸入。</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>We now have a drive named "Uninstall" that can be used to quickly and conveniently look for application installations.</source>
          <target state="translated">我們現在有了名為 "Uninstall" 的磁碟機，它可以用來快速又方便地尋找應用程式安裝。</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>We can find the number of installed applications by counting the number of registry keys in the Uninstall: Windows PowerShell drive:</source>
          <target state="translated">我們可以計算 Uninstall: Windows PowerShell 磁碟機中的登錄機碼數目，找出安裝的應用程式數目：</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>We can search this list of applications further by using a variety of techniques, beginning with <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept>.</source>
          <target state="translated">我們可以使用各種不同的技術來進一步搜尋此應用程式清單，首先是 <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept>。</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To get a list of applications and save them in the <bpt id="p1">**</bpt>$UninstallableApplications<ept id="p1">**</ept> variable, use the following command:</source>
          <target state="translated">若要取得應用程式清單並將它們儲存在 <bpt id="p1">**</bpt>$UninstallableApplications<ept id="p1">**</ept> 變數中，請使用下列命令：</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>We are using a lengthy variable name here for clarity.</source>
          <target state="translated">為了清楚說明，在這裡我們使用冗長的變數名稱。</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In actual use, there is no reason to use long names.</source>
          <target state="translated">在實際使用時，就沒有必要使用長名稱。</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Although you can use tab\-completion for variable names, you can also use 1–2 character names for speed.</source>
          <target state="translated">雖然您可以使用 Tab 鍵自動完成輸入變數名稱，但您也可以為了加快速度使用 1 至 2 個字元的名稱。</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Longer, descriptive names are most useful when you are developing code for reuse.</source>
          <target state="translated">較長的描述性名稱在您開發重複使用的程式碼時最有幫助。</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>To display the values of the registry entries in the registry keys under Uninstall, use the GetValue method of the registry keys.</source>
          <target state="translated">若要顯示 Uninstall 下登錄機碼中登錄項目的值，請使用登錄機碼的 GetValue 方法。</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The value of the method is the name of the registry entry.</source>
          <target state="translated">方法的值是登錄項目的名稱。</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>For example, to find the display names of applications in the Uninstall key, use the following command:</source>
          <target state="translated">例如，若要尋找 Uninstall 機碼中應用程式的顯示名稱，請使用下列命令：</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>There is no guarantee that these values are unique.</source>
          <target state="translated">這些值並不保證是唯一的。</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>In the following example, two installed items appear as "Windows Media Encoder 9 Series":</source>
          <target state="translated">在下列範例中，有兩個已安裝項目顯示為 "Windows Media Encoder 9 Series"：</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Installing Applications</source>
          <target state="translated">安裝應用程式</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">**</bpt>Win32\_Product<ept id="p1">**</ept> class to install Windows Installer packages, remotely or locally.</source>
          <target state="translated">您可以在遠端或本機使用 <bpt id="p1">**</bpt>Win32\_Product<ept id="p1">**</ept> 類別來安裝 Windows Installer 封裝。</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><ph id="ph1">[!NOTE]</ph> On Windows Vista, Windows Server 2008, and later versions of Windows, to install an application, you must start Windows PowerShell with the "Run as administrator" option.</source>
          <target state="translated"><ph id="ph1">[!NOTE]</ph> 在 Windows Vista、Windows Server 2008 與更新版本的 Windows 中，您必須使用 [以系統管理員身分執行] 選項啟動 Windows PowerShell 才能安裝應用程式。</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When installing remotely, use a Universal Naming Convention (UNC) network path to specify the path to the .msi package, because the WMI subsystem does not understand Windows PowerShell paths.</source>
          <target state="translated">進行遠端安裝時，請使用通用命名慣例 (UNC) 網路路徑來指定 .msi 套件的路徑，因為 WMI 子系統不了解 Windows PowerShell 路徑。</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For example, to install the NewPackage.msi package located in the network share \\\\AppServ\\dsp on the remote computer PC01, type the following command at the Windows PowerShell prompt:</source>
          <target state="translated">例如，若要安裝位於遠端電腦 PC01 上網路共用 \\\\AppServ\\dsp 中的 NewPackage.msi 封裝，請在 Windows PowerShell 提示字元輸入下列命令：</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Applications that do not use Windows Installer technology may have application\-specific methods available for automated deployment.</source>
          <target state="translated">不使用 Windows Installer 技術的應用程式可能會有應用程式專屬，且適用於自動化部署的方法。</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To determine whether there is a method for deployment automation, check the documentation for the application or consult the application vendor's support system.</source>
          <target state="translated">若要判斷是否有自動化部署的方法，請檢查應用程式的文件或洽詢應用程式廠商的支援系統。</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>In some cases, even if the application vendor did not specifically design the application for installation automation, the installer software manufacturer may have some techniques for automation.</source>
          <target state="translated">在某些情況下，即使應用程式廠商沒有特別將應用程式設計成自動化安裝，但安裝程式軟體製造商可能會有一些自動化技術。</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Removing Applications</source>
          <target state="translated">移除應用程式</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Removing a Windows Installer package by using Windows PowerShell works in approximately the same way as installing a package.</source>
          <target state="translated">使用 Windows PowerShell 移除 Windows Installer 套件的方法，與安裝套件的方法大致相同。</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Here is an example that selects the package to uninstall based on its name; in some cases it may be easier to filter with the <bpt id="p1">**</bpt>IdentifyingNumber<ept id="p1">**</ept>:</source>
          <target state="translated">以下是範例，其中根據封裝的名稱選取要解除安裝的封裝；在某些情況下，使用 <bpt id="p1">**</bpt>IdentifyingNumber<ept id="p1">**</ept> 來篩選可能會比較容易：</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Removing other applications is not quite so simple, even when done locally.</source>
          <target state="translated">即使是在本機上要移除其他應用程式，有時候也不太容易。</target>         
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>We can find the command line uninstallation strings for these applications by extracting the <bpt id="p1">**</bpt>UninstallString<ept id="p1">**</ept> property.</source>
          <target state="translated">我們可以透過擷取 <bpt id="p1">**</bpt>UninstallString<ept id="p1">**</ept> 屬性，來尋找這些應用程式的命令列解除安裝字串。</target>         
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>This method works for Windows Installer applications and for older programs appearing under the Uninstall key:</source>
          <target state="translated">此方法可用於 Windows Installer 應用程式，以及出現在 Uninstall 機碼下的舊版程式：</target>         
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You can filter the output by the display name, if you like:</source>
          <target state="translated">您也可以使用顯示名稱來篩選輸出：</target>         
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>However, these strings may not be directly usable from the Windows PowerShell prompt without some modification.</source>
          <target state="translated">不過，這些字串在未經修改之前，可能無法直接用於 Windows PowerShell 提示字元。</target>         
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Upgrading Windows Installer Applications</source>
          <target state="translated">升級 Windows Installer 應用程式</target>         
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>To upgrade an application, you need to know the name of the application and the path to the application upgrade package.</source>
          <target state="translated">若要升級應用程式，您需要知道應用程式的名稱，以及應用程式升級套件的路徑。</target>         
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>With that information, you can upgrade an application with a single Windows PowerShell command:</source>
          <target state="translated">有了該資訊之後，您就可以使用單一的 Windows PowerShell 命令升級應用程式：</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>