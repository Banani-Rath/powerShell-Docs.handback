<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Manipulating-Items-Directly.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b7e752a1615da4540106ec32754f873c5d7aa5d9</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-39517ae" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Manipulating Items Directly</source>
          <target state="translated">直接操作項目</target>         
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Manipulating Items Directly</source>
          <target state="translated">直接操作項目</target>         
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>The elements that you see in Windows PowerShell drives, such as the files and folders in the file system drives, and the registry keys in the Windows PowerShell registry drives, are called <bpt id="p1">*</bpt>items<ept id="p1">*</ept> in Windows PowerShell.</source>
          <target state="translated">您在 Windows PowerShell 磁碟機中看到的項目 (例如檔案系統磁碟機中的檔案與資料夾，以及 Windows PowerShell 登錄磁碟機中的登錄機碼) 在 Windows PowerShell 中稱為<bpt id="p1">*</bpt>項目<ept id="p1">*</ept>。</target>         
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The cmdlets for working with them item have the noun <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> in their names.</source>
          <target state="translated">用於處理項目之 Cmdlet 的名稱中具有名詞 <bpt id="p1">**</bpt>Item<ept id="p1">**</ept>。</target>         
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>The output of the <bpt id="p1">**</bpt>Get\-Command \-Noun Item<ept id="p1">**</ept> command shows that there are nine Windows PowerShell item cmdlets.</source>
          <target state="translated"><bpt id="p1">**</bpt>Get-Command -Noun Item<ept id="p1">**</ept> 命令的輸出顯示有九個 Windows PowerShell 項目 Cmdlet。</target>         
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Creating New Items (New\-Item)</source>
          <target state="translated">建立新項目 (New-Item)</target>         
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>To create a new item in the file system, use the <bpt id="p1">**</bpt>New\-Item<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">若要在檔案系統中建立新項目，請使用 <bpt id="p1">**</bpt>New-Item<ept id="p1">**</ept> Cmdlet。</target>         
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Include the <bpt id="p1">**</bpt>Path<ept id="p1">**</ept> parameter with path to the item, and the <bpt id="p2">**</bpt>ItemType<ept id="p2">**</ept> parameter with a value of "file" or "directory".</source>
          <target state="translated">包含 <bpt id="p1">**</bpt>Path<ept id="p1">**</ept> 參數並指定項目路徑作為參數值，以及包含 <bpt id="p2">**</bpt>ItemType<ept id="p2">**</ept> 參數並指定 "file" 或 "directory" 的值。</target>         
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For example, to create a new directory named "New.Directory"in the C:\\Temp directory,  type:</source>
          <target state="translated">例如，若要在 C:\Temp 目錄中建立名為 "New.Directory" 的新目錄，請輸入：</target>         
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To create a file, change the value of the <bpt id="p1">**</bpt>ItemType<ept id="p1">**</ept> parameter to "file".</source>
          <target state="translated">若要建立檔案，請將 <bpt id="p1">**</bpt>ItemType<ept id="p1">**</ept> 參數的值變更為 "file"。</target>         
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For example, to create a file named "file1.txt" in the New.Directory directory, type:</source>
          <target state="translated">例如，若要在 New.Directory 目錄中建立名為 "file1.txt" 的檔案，請輸入：</target>         
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can use the same technique to create a new registry key.</source>
          <target state="translated">您可以使用相同的方式來建立新的登錄機碼。</target>         
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>In fact, a registry key is easier to create because the only item type in the Windows registry is a key.</source>
          <target state="translated">事實上，建立登錄機碼的方式較簡單，因為 Windows 登錄中唯一的項目類型是機碼。</target>         
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>(Registry entries are item <bpt id="p1">*</bpt>properties<ept id="p1">*</ept>.) For example, to create a key named "\_Test" in the CurrentVersion subkey, type:</source>
          <target state="translated">(登錄項目是項目<bpt id="p1">*</bpt>屬性<ept id="p1">*</ept>。)例如，若要在 CurrentVersion 子機碼中建立名為 "_Test" 的機碼，請輸入：</target>         
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>When typing a registry path, be sure to include the colon (<bpt id="p1">**</bpt>:<ept id="p1">**</ept>) in the Windows PowerShell drive names, HKLM: and HKCU:.</source>
          <target state="translated">輸入登錄路徑時，請務必在 Windows PowerShell 磁碟機名稱中包含冒號 (<bpt id="p1">**</bpt>:<ept id="p1">**</ept>)，亦即 HKLM: 與 HKCU:。</target>         
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Without the colon, Windows PowerShell does not recognize the drive name in the path.</source>
          <target state="translated">若未使用冒號，Windows PowerShell 將無法識別該路徑中的磁碟機名稱。</target>         
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Why Registry Values are not Items</source>
          <target state="translated">為什麼登錄值不是項目</target>         
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>When you use the <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> cmdlet to find the items in a registry key, you will never see actual registry entries or their values.</source>
          <target state="translated">當您使用 <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> Cmdlet 來尋找登錄機碼中的項目時，您將永遠不會看到實際的登錄項目或其值。</target>         
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For example, the registry key <bpt id="p1">**</bpt>HKEY\_LOCAL\_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run<ept id="p1">**</ept> usually contains several registry entries that represent applications that run when the system starts.</source>
          <target state="translated">例如，登錄機碼 <bpt id="p1">**</bpt>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run<ept id="p1">**</ept> 通常包含數個登錄項目，這些登錄項目代表系統啟動時執行的應用程式。</target>         
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>However, when you use <bpt id="p1">**</bpt>Get\-ChildItem<ept id="p1">**</ept> to look for child items in the key, all you will see is the <bpt id="p2">**</bpt>OptionalComponents<ept id="p2">**</ept> subkey of the key:</source>
          <target state="translated">不過，當您使用 <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> 來尋找機碼中的子項目時，您只會看到該機碼的 <bpt id="p2">**</bpt>OptionalComponents<ept id="p2">**</ept> 子機碼：</target>         
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Although it would be convenient to treat registry entries as items, you cannot specify a path to a registry entry in a way that ensures that it is unique.</source>
          <target state="translated">雖然將登錄項目視為項目很方便，但您無法在指定登錄項目路徑時確保其唯一性。</target>         
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The path notation does not distinguish between the registry subkey named <bpt id="p1">**</bpt>Run<ept id="p1">**</ept> and the <bpt id="p2">**</bpt>(Default)<ept id="p2">**</ept> registry entry in the <bpt id="p3">**</bpt>Run<ept id="p3">**</ept> subkey.</source>
          <target state="translated">路徑標記法無法區分名為 <bpt id="p1">**</bpt>Run<ept id="p1">**</ept> 的登錄子機碼與 <bpt id="p3">**</bpt>Run<ept id="p3">**</ept> 子機碼中的 <bpt id="p2">**</bpt>(Default)<ept id="p2">**</ept> 登錄項目。</target>         
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Furthermore, because registry entry names can contain the backslash character (<bpt id="p1">**</bpt><ph id="ph1">\\</ph><ept id="p1">**</ept>), if regsitry entries were items, then you could not use the path notation to distinguish a registry entry named <bpt id="p2">**</bpt>Windows\\CurrentVersion\\Run<ept id="p2">**</ept> from the subkey that is located in that path.</source>
          <target state="translated">此外，因為登錄項目名稱可以包含反斜線字元 (<bpt id="p1">**</bpt><ph id="ph1">\\</ph><ept id="p1">**</ept>)，若登錄項目是項目，您無法使用路徑標記法來區分名為 <bpt id="p2">**</bpt>Windows\CurrentVersion\Run<ept id="p2">**</ept> 的登錄項目與該路徑中的子機碼。</target>         
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Renaming Existing Items (Rename\-Item)</source>
          <target state="translated">重新命名現有的項目 (Rename-Item)</target>         
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>To change the name of a file or folder, use the <bpt id="p1">**</bpt>Rename\-Item<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">若要變更檔案或資料夾的名稱，請使用 <bpt id="p1">**</bpt>Rename-Item<ept id="p1">**</ept> Cmdlet。</target>         
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The following command changes the name of the <bpt id="p1">**</bpt>file1.txt<ept id="p1">**</ept> file to <bpt id="p2">**</bpt>fileOne.txt<ept id="p2">**</ept>.</source>
          <target state="translated">下列命令會將 <bpt id="p1">**</bpt>file1.txt<ept id="p1">**</ept> 檔案的名稱變更為 <bpt id="p2">**</bpt>fileOne.txt<ept id="p2">**</ept>。</target>         
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Rename\-Item<ept id="p1">**</ept> cmdlet can change the name of a file or a folder, but it cannot move an item.</source>
          <target state="translated"><bpt id="p1">**</bpt>Rename-Item<ept id="p1">**</ept> Cmdlet 可以變更檔案或資料夾的名稱，但無法移動項目。</target>         
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following command fails because it attempts to move the file from the New.Directory directory to the Temp directory.</source>
          <target state="translated">下列命令會失敗。因為它會嘗試將檔案從 New.Directory 目錄移動到 Temp 目錄。</target>         
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Moving Items (Move\-Item)</source>
          <target state="translated">移動項目 (Move-Item)</target>         
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To move a file or folder, use the <bpt id="p1">**</bpt>Move\-Item<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">若要移動檔案或資料夾，請使用 <bpt id="p1">**</bpt>Move-Item<ept id="p1">**</ept> Cmdlet。</target>         
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For example, the following command moves the New.Directory directory from the C:\\temp directory to the root of the C: drive.</source>
          <target state="translated">例如，下列命令會將 New.Directory 目錄從 C:\temp 目錄移動到 C: 磁碟機的根目錄。</target>         
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To verify that the item was moved, include the <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> parameter of the <bpt id="p2">**</bpt>Move\-Item<ept id="p2">**</ept> cmdlet.</source>
          <target state="translated">若要確定項目已移動，請包含 <bpt id="p2">**</bpt>Move-Item<ept id="p2">**</ept> Cmdlet 的 <bpt id="p1">**</bpt>PassThru<ept id="p1">**</ept> 參數。</target>         
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Without <bpt id="p1">**</bpt>Passthru<ept id="p1">**</ept>, the <bpt id="p2">**</bpt>Move\-Item<ept id="p2">**</ept> cmdlet does not display any results.</source>
          <target state="translated">若未指定 <bpt id="p1">**</bpt>Passthru<ept id="p1">**</ept>，<bpt id="p2">**</bpt>Move-Item<ept id="p2">**</ept> Cmdlet 不會顯示任何結果。</target>         
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Copying Items (Copy\-Item)</source>
          <target state="translated">複製項目 (Copy-Item)</target>         
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>If you are familiar with the copy operations in other shells, you might find the behavior of the <bpt id="p1">**</bpt>Copy\-Item<ept id="p1">**</ept> cmdlet in Windows PowerShell to be unusual.</source>
          <target state="translated">若您熟悉其他殼層中的複製操作，您可能會發現 Windows PowerShell 中 <bpt id="p1">**</bpt>Copy-Item<ept id="p1">**</ept> Cmdlet 的行為不尋常。</target>         
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>When you copy an item from one location to another, Copy\-Item does not copy its contents by default.</source>
          <target state="translated">當您將某個項目從一個位置複製到另一個位置時，Copy-Item 預設不會複製其內容。</target>         
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For example, if you copy the <bpt id="p1">**</bpt>New.Directory<ept id="p1">**</ept> directory from the C: drive to the C:\\temp directory, the command succeeds, but the files in the New.Directory directory are not copied.</source>
          <target state="translated">例如，若您將 <bpt id="p1">**</bpt>New.Directory<ept id="p1">**</ept> 目錄從 C: 磁碟機複製到 C:\temp 目錄，該命令會成功，但不會複製 New.Directory 目錄中的檔案。</target>         
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If you display the contents of <bpt id="p1">**</bpt>C:\\temp\\New.Directory<ept id="p1">**</ept>, you will find that it contains no files:</source>
          <target state="translated">若顯示 <bpt id="p1">**</bpt>C:\temp\New.Directory<ept id="p1">**</ept> 的內容，您會發現其中未包含任何檔案：</target>         
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Why doesn't the <bpt id="p1">**</bpt>Copy\-Item<ept id="p1">**</ept> cmdlet copy the contents to the new location?</source>
          <target state="translated">為什麼 <bpt id="p1">**</bpt>Copy-Item<ept id="p1">**</ept> Cmdlet 不會將內容複製到新位置？</target>         
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Copy\-Item<ept id="p1">**</ept> cmdlet was designed to be generic; it is not just for copying files and folders.</source>
          <target state="translated"><bpt id="p1">**</bpt>Copy-Item<ept id="p1">**</ept> Cmdlet 被設計為泛型；它不是只能用來複製檔案與資料夾。</target>         
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Also, even when copying files and folders, you might want to copy only the container and not the items within it.</source>
          <target state="translated">此外，即使複製檔案與資料夾時，您可能只想複製容器，而非其中的項目。</target>         
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To copy all of the contents of a folder, include the <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> parameter of the <bpt id="p2">**</bpt>Copy\-Item<ept id="p2">**</ept> cmdlet in the command.</source>
          <target state="translated">若要複製資料夾中的所有內容，請在命令中包含 <bpt id="p2">**</bpt>Copy-Item<ept id="p2">**</ept> Cmdlet 的 <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> 參數。</target>         
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>If you have already copied the directory without its contents, add the <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> parameter, which allows you to overwrite the empty folder.</source>
          <target state="translated">若已複製目錄但未複製其內容，請新增 <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> 參數，這樣可以讓您覆寫空資料夾。</target>         
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Deleting Items (Remove\-Item)</source>
          <target state="translated">刪除項目 (Remove-Item)</target>         
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>To delete files and folders, use the <bpt id="p1">**</bpt>Remove\-Item<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">若要刪除檔案與資料夾，請使用 <bpt id="p1">**</bpt>Remove-Item<ept id="p1">**</ept> Cmdlet。</target>         
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Windows PowerShell cmdlets, such as <bpt id="p1">**</bpt>Remove\-Item<ept id="p1">**</ept>, that can make significant, irreversible changes will often prompt for confirmation when you enter its commands.</source>
          <target state="translated">會造成大幅且無法復原之變更的 Windows PowerShell Cmdlet (例如 <bpt id="p1">**</bpt>Remove-Item<ept id="p1">**</ept>) 通常會在您輸入其命令時提示您確認。</target>         
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, if you try to remove the <bpt id="p1">**</bpt>New.Directory<ept id="p1">**</ept> folder, you will be prompted to confirm the command, because the folder contains files:</source>
          <target state="translated">例如，若嘗試移除 <bpt id="p1">**</bpt>New.Directory<ept id="p1">**</ept> 資料夾，系統會提示您確認要執行該命令，因為資料夾包含檔案：</target>         
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Because <bpt id="p1">**</bpt>Yes<ept id="p1">**</ept> is the default response, to delete the folder and its files, press the <bpt id="p2">**</bpt>Enter<ept id="p2">**</ept> key.</source>
          <target state="translated">因為 <bpt id="p1">**</bpt>[是]<ept id="p1">**</ept> 是預設回應，若要刪除資料夾與其中的檔案，請按 <bpt id="p2">**</bpt>Enter<ept id="p2">**</ept> 鍵。</target>         
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>To remove the folder without confirming, use the <bpt id="p1">**</bpt>\-Recurse<ept id="p1">**</ept> parameter.</source>
          <target state="translated">若要在不確認的情況下移除資料夾，請使用 <bpt id="p1">**</bpt>-Recurse<ept id="p1">**</ept> 參數。</target>         
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Executing Items (Invoke\-Item)</source>
          <target state="translated">執行項目 (Invoke-Item)</target>         
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Windows PowerShell uses the <bpt id="p1">**</bpt>Invoke\-Item<ept id="p1">**</ept> cmdlet to perform a default action for a file or folder.</source>
          <target state="translated">Windows PowerShell 使用 <bpt id="p1">**</bpt>Invoke-Item<ept id="p1">**</ept> Cmdlet 來針對檔案或資料夾執行預設動作。</target>         
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This default action is determined by the default application handler in the registry; the effect is the same as if you double\-click the item in File Explorer.</source>
          <target state="translated">此預設動作是由登錄中的預設應用程式處理常式決定；效果等同於在檔案總管中按兩下該項目。</target>         
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For example, suppose you run the following command:</source>
          <target state="translated">例如，假設您執行下列命令：</target>         
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>An Explorer window that is located in C:\\Windows appears, just as if you had double\-clicked the C:\\Windows folder.</source>
          <target state="translated">隨即出現檔案總管視窗 (顯示 C:\Windows)，就像您按兩下 C:\Windows 資料夾一樣。</target>         
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If you invoke the <bpt id="p1">**</bpt>Boot.ini<ept id="p1">**</ept> file on a system prior to Windows Vista:</source>
          <target state="translated">若在 Windows Vista 之前的系統上叫用 <bpt id="p1">**</bpt>Boot.ini<ept id="p1">**</ept> 檔案：</target>         
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If the .ini file type is associated with Notepad, the boot.ini file opens in Notepad.</source>
          <target state="translated">若 .ini 檔案類型與 [記事本] 關聯，boot.ini 檔案會在 [記事本] 中開啟。</target>         
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>