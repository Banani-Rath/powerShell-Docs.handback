<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5860fff87e8bd9511ffd02ee8c3c180095874062</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_Debuggers.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">70c3e204a65fa25d004d8dd86fda2d2e8143b1b5</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d08eb5c290e8115c8fcfa118dc56a6beea7adf1</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell 指令程式</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About Debuggers</source>
          <target state="translated">關於偵錯工具</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_Debuggers</source>
          <target state="translated">about_Debuggers</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">簡短描述</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes the Windows PowerShell debugger.</source>
          <target state="translated">說明 Windows PowerShell 偵錯工具。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細描述</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Debugging is the process of examining a script while it is running to identify and correct errors in the script instructions.</source>
          <target state="translated">偵錯是找出並修正錯誤的指令碼指示在執行時，請檢查指令碼的程序。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can help you examine and identify errors and inefficiencies in your scripts, functions, commands, Windows PowerShell workflows, Windows PowerShell Desired State Configuration (DSC) configurations, or expressions.</source>
          <target state="translated">Windows PowerShell 偵錯工具可協助您檢查並識別錯誤和效率在指令碼、 函式、 命令、 Windows PowerShell 工作流程、 Windows PowerShell 期望狀態組態 (DSC) 組態或運算式。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, the Windows PowerShell debugger has been updated to debug scripts, functions, workflows, commands, configurations, or expressions that are running in either the console or Windows PowerShell ISE on remote computers.</source>
          <target state="translated">從 Windows PowerShell 5.0 開始，Windows PowerShell 偵錯工具已更新為偵錯指令碼、 函式、 工作流程、 命令、 組態或遠端電腦執行主控台或 Windows PowerShell ISE 中的運算式。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can run Enter-PSSession to start an interactive remote PowerShell session in which you can set breakpoints and debug script files and commands on the remote computer.</source>
          <target state="translated">您可以執行 Enter-pssession 啟動的互動式遠端 PowerShell 工作階段來設定中斷點及偵錯指令碼檔案和遠端電腦上的命令。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running a script or command on a remote computer.</source>
          <target state="translated">Enter-pssession 功能已更新為可讓您重新連線至並輸入遠端電腦執行指令碼或命令中斷連線工作階段。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">如果執行的指令碼會叫用中斷點，您的用戶端工作階段會自動啟動偵錯工具。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If the disconnected session that is running a script has already hit a breakpoint, and is stopped at the breakpoint, Enter-PSSession automatically starts the command-line debugger, after you reconnect to the session.</source>
          <target state="translated">如果執行指令碼中斷連線工作階段已叫用中斷點時，並在中斷點停止，Enter-pssession 後，自動啟動偵錯工具命令列，重新連線工作階段。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger can also be used to debug Windows PowerShell workflows, in either the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">Windows PowerShell 偵錯工具也可用來偵錯 Windows PowerShell 工作流程，在其中一個 Windows PowerShell 主控台中，或在 Windows PowerShell ISE。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can debug within running jobs or processes, either locally or remotely.</source>
          <target state="translated">從 Windows PowerShell 5.0 開始，您可以偵錯中執行的工作或程序，在本機或遠端。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You can use the features of the Windows PowerShell debugger to examine a Windows PowerShell script, function, command, workflow, or expression while it is running.</source>
          <target state="translated">若要檢查的 Windows PowerShell 指令碼、 函式、 命令、 工作流程或運算式，在執行時，您可以使用 Windows PowerShell 偵錯工具的功能。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell debugger includes a set of cmdlets that let you set breakpoints, manage breakpoints, and view the call stack.</source>
          <target state="translated">Windows PowerShell 偵錯工具會包含一組指令程式可讓您設定中斷點、 管理中斷點，以及檢視呼叫堆疊。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Debugger Cmdlets The Windows PowerShell debugger includes the following set of cmdlets:</source>
          <target state="translated">偵錯工具在 Windows PowerShell 指令程式的偵錯工具包含下列一組 cmdlet:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Set-PsBreakpoint:     Sets breakpoints on lines, variables, and commands.</source>
          <target state="translated">Set-psbreakpoint︰ 將程式碼行、 變數和命令上設定中斷點。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Get-PsBreakpoint:     Gets breakpoints in the current session.</source>
          <target state="translated">Get-psbreakpoint︰ 取得目前工作階段中的中斷點。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint: Turns off breakpoints in the current session.</source>
          <target state="translated">Disable-psbreakpoint︰ 關閉目前工作階段中的中斷點。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Enable-PsBreakpoint:  Re-enables breakpoints in the current session.</source>
          <target state="translated">Enable-psbreakpoint︰ 會在目前工作階段中重新啟用中斷點。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Remove-PsBreakpoint:  Deletes breakpoints from the current session.</source>
          <target state="translated">Remove-psbreakpoint︰ 會從目前的工作階段刪除中斷點。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Get-PsCallStack:      Displays the current call stack.</source>
          <target state="translated">Get-pscallstack︰ 顯示目前的呼叫堆疊。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Starting and Stopping the Debugger To start the debugger, set one or more breakpoints.</source>
          <target state="translated">啟動和停止偵錯工具來開始偵錯工具中，設定一或多個中斷點。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Then, run the script, command, or function that you want to debug.</source>
          <target state="translated">然後，執行指令碼、 命令或函式，您要偵錯。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>When you reach a breakpoint, execution stops, and control is turned over to the debugger.</source>
          <target state="translated">當您到達中斷點、 執行會停止，而且控制項已偵錯工具。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To stop the debugger, run the script, command, or function until it is complete.</source>
          <target state="translated">若要停止偵錯工具，執行指令碼、 命令或函式，直到完成為止。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Or, type "stop" or "t".</source>
          <target state="translated">或者，輸入 「 停止 」 或"t"。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Debugger Commands When you use the debugger in the Windows PowerShell console, use the following commands to control the execution.</source>
          <target state="translated">偵錯工具命令當您使用 Windows PowerShell 主控台中的偵錯工具，使用下列命令來控制執行。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell ISE, use commands on the Debug menu.</source>
          <target state="translated">在 Windows PowerShell ISE 中，使用偵錯] 功能表上的命令。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Note: For information about how to use the debugger in other host applications, see the host application documentation.</source>
          <target state="translated">注意︰ 如需如何在其他主機應用程式中使用偵錯工具的資訊，請參閱主機應用程式文件。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>s, Step-into        Executes the next statement and then stops.</source>
          <target state="translated">s，逐步執行會執行下一個陳述式，然後停止。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>v, Step-over        Executes the next statement, but skips functions and invocations.</source>
          <target state="translated">函式和引動過程，但會略過 v、 不進入函式執行的下一個陳述式。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">這會執行已跳過的陳述式，但不會逐步執行。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Ctrl+Break (Break All in ISE)  Breaks into a running script within either the Windows PowerShell console, or Windows PowerShell ISE.</source>
          <target state="translated">Ctrl + Break （全部中斷 ise） 到 Windows PowerShell 主控台或 Windows PowerShell ISE 中執行指令碼的符號。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Note that Ctrl+Break in Windows PowerShell 2.0, 3.0, and 4.0 closes the program.</source>
          <target state="translated">請注意在 Windows PowerShell 2.0、 3.0 和 4.0 中的 Ctrl + Break 會關閉該程式。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Break All works on both local and remote interactively-running scripts.</source>
          <target state="translated">在本機和遠端以互動方式執行指令碼時中斷運作。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>o, Step-out         Steps out of the current function; up one level if nested.</source>
          <target state="translated">o，跳離步驟移到目前的函式。上移一層如果巢狀。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If in the main body, it continues to the end or the next breakpoint.</source>
          <target state="translated">如果在主要本文中，持續的結尾或下一個中斷點。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">這會執行已跳過的陳述式，但不會逐步執行。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>c, Continue         Continues to run until the script is complete or until the next breakpoint is reached.</source>
          <target state="translated">c，繼續會繼續執行，直到指令碼已完成或直到下一個中斷點為止。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The skipped statements are executed, but not stepped through.</source>
          <target state="translated">這會執行已跳過的陳述式，但不會逐步執行。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>l, List             Displays the part of the script that is executing.</source>
          <target state="translated">l，清單會顯示正在執行的指令碼的一部分。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>By default, it displays the current line, five previous lines, and 10 subsequent lines.</source>
          <target state="translated">根據預設，它會顯示目前這一行、 五個以上幾行和 10 的下一行。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To continue listing the script, press ENTER.</source>
          <target state="translated">若要繼續列出指令碼，請按 ENTER 鍵。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph>, List         Displays 16 lines of the script beginning with the line number specified by <ph id="ph2">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph>, ，所指定的行號開頭的指令碼的清單會顯示 16 行 <ph id="ph2">&lt;m&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, List     Displays <ph id="ph3">&lt;n&gt;</ph> lines of the script, beginning with the line number specified by <ph id="ph4">&lt;m&gt;</ph>.</source>
          <target state="translated">l <ph id="ph1">&lt;m&gt;</ph> <ph id="ph2">&lt;n&gt;</ph>, ，清單會顯示 <ph id="ph3">&lt;n&gt;</ph> 指令碼，以指定的行數字開頭行 <ph id="ph4">&lt;m&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>q, Stop, Exit       Stops executing the script, and exits the debugger.</source>
          <target state="translated">q，停止執行指令碼，結束停駐點和結束偵錯工具。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If you are debugging a job by running the Debug-Job cmdlet, the Exit command detaches the debugger, and allows the job to continue running.</source>
          <target state="translated">如果您正在偵錯作業，執行偵錯工作 cmdlet，結束命令中斷偵錯工具，並允許繼續執行工作。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>k, Get-PsCallStack  Displays the current call stack.</source>
          <target state="translated">k、 Get-pscallstack 會顯示目前的呼叫堆疊。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Repeats the last command if it was Step (s), Step-over (v), or List (l).</source>
          <target state="translated">重複最後一個命令，如果它是步驟 (s)、 不進入函式 (v) 或清單 (l)。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Otherwise, represents a submit action.</source>
          <target state="translated">否則，表示送出動作。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>?, h                Displays the debugger command Help.</source>
          <target state="translated">？，h 顯示偵錯工具命令說明。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To exit the debugger, you can use Stop (q).</source>
          <target state="translated">若要結束偵錯工具，您可以使用停駐點 (q)。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Starting in Windows PowerShell 5.0, you can run the Exit command to exit a nested debugging session that you started by running either Debug-Job or Debug-Runspace.</source>
          <target state="translated">從 Windows PowerShell 5.0 開始，您可以執行 [結束] 命令，以結束您啟動偵錯工作或偵錯 Runspace 執行巢狀偵錯工作階段。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>By using these debugger commands, you can run a script, stop on a point of concern, examine the values of variables and the state of the system, and continue running the script until you have identified a problem.</source>
          <target state="translated">藉由使用這些偵錯工具命令，您可以執行指令碼、 關切的點上停止、 檢查變數和系統狀態的值和繼續執行指令碼，直到您找出問題。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>NOTE:  If you step into a statement with a redirection operator, such as "&gt;", the Windows PowerShell debugger steps over all remaining statements in the script.</source>
          <target state="translated">注意︰ 如果您逐步執行陳述式以重新導向運算子，例如 「 &gt; 」，Windows PowerShell 偵錯工具進入所有剩餘的陳述式的指令碼中。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Displaying the Values of script Variables</source>
          <target state="translated">顯示指令碼變數的值</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>While you are in the debugger, you can also enter commands, display the value of variables, use cmdlets, and run scripts at the command line.</source>
          <target state="translated">在偵錯工具時，也可以輸入命令，顯示變數的值、 使用 cmdlet，以及在命令列執行指令碼。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>You can display the current value of all variables in the script that is being debugged, except for the following automatic variables:</source>
          <target state="translated">您可以顯示所有變數的目前值，在指令碼進行偵錯，但下列自動變數除外︰</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>$_</source>
          <target state="translated">$_</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>$Args $Input $MyInvocation $PSBoundParameters</source>
          <target state="translated">$Args $Input $MyInvocation $PSBoundParameters</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>If you try to display the value of any of these variables, you get the value of that variable for in an internal pipeline the debugger uses, not the value of the variable in the script.</source>
          <target state="translated">如果您嘗試顯示上述任何變數的值，您會取得偵錯工具所使用之內部管線中的變數值，而不是指令碼中的變數值。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To display the value these variables for the script that is being debugged, in the script, assign the value of the automatic variable to a new variable.</source>
          <target state="translated">若要顯示指令碼進行偵錯，這些變數值的指令碼中，將自動變數的值指派給新的變數。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Then you can display the value of the new variable.</source>
          <target state="translated">然後您可以顯示新變數的值。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如，</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>$scriptArgs = $Args $scriptArgs</source>
          <target state="translated">$scriptArgs = $Args $scriptArgs</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In the example in this topic, the value of the $MyInvocation variable is reassigned as follows:</source>
          <target state="translated">本主題的範例，請在 $MyInvocation 變數的值會指派，如下所示︰</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">$scriptname = $MyInvocation.MyCommand.Path</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The Debugger Environment When you reach a breakpoint, you enter the debugger environment.</source>
          <target state="translated">偵錯工具環境時您到達中斷點，您輸入偵錯工具環境。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The command prompt changes so that it begins with "<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:".</source>
          <target state="translated">命令提示字元中變更，使它的開頭 「<bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>:"。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>If you are debugging a workflow, the prompt is "[WFDBG]".</source>
          <target state="translated">如果您正在偵錯工作流程，「 提示 」 是 「 [WFDBG] 」。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can customize the prompt.</source>
          <target state="translated">您可以自訂提示。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Also, in some host applications, such as the Windows PowerShell console, (but not in Windows PowerShell Integrated Scripting Environment [ISE]), a nested prompt opens for debugging.</source>
          <target state="translated">此外，在主應用程式，例如 Windows PowerShell 主控台 （而不是在 Windows PowerShell 整合式指令碼環境 [ISE]），巢狀的提示開啟以進行偵錯。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You can detect the nested prompt by the repeating greater-than characters (ASCII 62) that appear at the command prompt.</source>
          <target state="translated">您可以藉由重複大於偵測巢狀的提示-比字元 (ASCII 62) 出現在命令提示字元。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For example, the following is the default debugging prompt in the Windows PowerShell console:</source>
          <target state="translated">例如，以下是預設偵錯在 Windows PowerShell 主控台提示字元︰</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>You can find the nesting level by using the $NestedPromptLevel automatic variable.</source>
          <target state="translated">您可以使用 $NestedPromptLevel 自動變數，以尋找巢狀層級。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Additionally, an automatic variable, $PSDebugContext, is defined in the local scope.</source>
          <target state="translated">此外，自動變數，$PSDebugContext，被定義本機範圍內。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can use the presence of the $PsDebugContext variable to determine whether you are in the debugger.</source>
          <target state="translated">您可以使用 $PsDebugContext 變數的目前狀態來判斷是否處於偵錯工具。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>if ($psdebugcontext) {"Debugging"} else {"Not Debugging"}</source>
          <target state="translated">如果 ($psdebugcontext) {「 偵錯 」} else {「 不偵錯 」。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can use the value of the $PSDebugContext variable in your debugging.</source>
          <target state="translated">在您偵錯，您可以使用 $PSDebugContext 變數的值。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Name   CommandLineParameters  UnboundArguments  Location</source>
          <target state="translated">名稱 CommandLineParameters UnboundArguments 位置</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>=      {}                     {}                C:\ps-test\vote.ps1 (1)</source>
          <target state="translated">= {} {} C:\ps-test\vote.ps1 (1)</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Debugging and Scope Breaking into the debugger does not change the scope in which you are operating, but when you reach a breakpoint in a script, you move into the script scope.</source>
          <target state="translated">偵錯和中斷偵錯工具的範圍不會變更的範圍中您要操作的但當您到達中斷點的指令碼中，移到指令碼範圍。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The script scope is a child of the scope in which you ran the debugger.</source>
          <target state="translated">指令碼範圍是您已執行偵錯工具在範圍的子系。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To find the variables and aliases that are defined in the script scope, use the Scope parameter of the Get-Alias or Get-Variable cmdlets.</source>
          <target state="translated">若要尋找的變數和指令碼範圍中定義的別名，使用 Scope 參數取得別名或取得變數的指令程式。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the variables in the local (script) scope:</source>
          <target state="translated">比方說，下列命令會取得本機 （指令碼） 範圍中的變數︰</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>get-variable -scope 0</source>
          <target state="translated">取得變數的範圍 0</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">您可以將做為命令的縮寫︰</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>gv -s 0</source>
          <target state="translated">gv-s 0</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This is a useful way to see only the variables that you defined in the script and that you defined while debugging.</source>
          <target state="translated">這是只有變數在指令碼中所定義，您定義在偵錯時，請參閱 &lt; 有用的方法。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Debugging at the Command Line When you set a variable breakpoint or a command breakpoint, you can set the breakpoint only in a script file.</source>
          <target state="translated">在偵錯命令列當您設定變數中斷點命令，您可以只在指令碼檔案中設定中斷點。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>However, by default, the breakpoint is set on anything that runs in the current session.</source>
          <target state="translated">不過，根據預設，中斷點設定在目前工作階段中執行的項目。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For example, if you set a breakpoint on the $name variable, the debugger breaks on any $name variable in any script, command, function, script cmdlet or expression that you run until you disable or remove the breakpoint.</source>
          <target state="translated">例如，如果您在設定中斷點 $name 變數，偵錯工具中斷任何指令碼、 命令、 函數、 指令碼 cmdlet 或運算式中任何 $name 變數上，執行直到您停用或移除中斷點。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>This allows you to debug your scripts in a more realistic context in which they might be affected by functions, variables, and other scripts in the session and in the user's profile.</source>
          <target state="translated">這可讓您偵錯您的指令碼更實際的內容中他們可能會受到函式、 變數和其他指令碼和使用者的設定檔中的工作階段中。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Line breakpoints are specific to script files, so they are set only in script files.</source>
          <target state="translated">行中斷點專用於指令碼檔案，因此只在指令碼檔案中所設定。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Debugging Workflows The Windows PowerShell 4.0 debugger can be used to debug Windows PowerShell workflows, either in the Windows PowerShell console, or in Windows PowerShell ISE.</source>
          <target state="translated">偵錯工作流程 Windows PowerShell 4.0 偵錯工具可以用來偵錯 Windows PowerShell 工作流程，在 Windows PowerShell 主控台中，或在 Windows PowerShell ISE。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>There are some limitations with using the Windows PowerShell debugger to debug workflows.</source>
          <target state="translated">有一些限制使用 Windows PowerShell 偵錯工具偵錯工作流程。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>-- You can view workflow variables while you are in the debugger, but setting workflow variables from within the debugger is not supported.</source>
          <target state="translated">--您可以檢視工作流程變數，而您正在偵錯工具，但是不支援設定偵錯工具內的工作流程變數。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>-- Tab completion when stopped in the workflow debugger is not available.</source>
          <target state="translated">-無法使用 tab 鍵自動完成的工作流程偵錯工具停止時。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>-- Workflow debugging works only with synchronous running of workflows from a Windows PowerShell script.</source>
          <target state="translated">-工作流程偵錯僅適用於同步執行的工作流程，從 Windows PowerShell 指令碼。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>You cannot debug workflows if they are running as a job (with the –AsJob parameter).</source>
          <target state="translated">如果它們正在執行工作 （使用 – AsJob 參數中），您無法偵錯工作流程。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>-- Other nested debugging scenarios--such as a workflow calling another workflow, or a workflow calling a script--are not implemented.</source>
          <target state="translated">-其他巢狀的偵錯案例-例如，工作流程呼叫另一個工作流程或呼叫指令碼工作流程-未實作。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The following example demonstrates debugging a workflow.</source>
          <target state="translated">下列範例示範如何偵錯工作流程。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Note that when the debugger steps into the workflow function, the debugger prompt changes to [WFDBG].</source>
          <target state="translated">請注意，當工作流程函式偵錯工具逐步執行、 偵錯工具提示字元會變成 [WFDBG]。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Set-PSBreakpoint -Script C:\TestWFDemo1.ps1 -Line 8</source>
          <target state="translated">PS C: &gt; Set-psbreakpoint-C:\TestWFDemo1.ps1 編寫指令碼的行 8</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>ID Script           Line Command    Variable     Action</source>
          <target state="translated">識別碼的指令碼行命令變數 」 動作</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>0 TestWFDemo1.ps1   8</source>
          <target state="translated">0 TestWFDemo1.ps1 8</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>PS C:&gt; C:\TestWFDemo1.ps1 Entering debug mode.</source>
          <target state="translated">PS C: &gt; C:\TestWFDemo1.ps1 進入偵錯模式。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或嗎？</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">以取得協助。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\TestWFDemo1.ps1:8'</source>
          <target state="translated">'C:\TestWFDemo1.ps1:8' 上叫用的行中斷點</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>At C:\TestWFDemo1.ps1:8 char:5</source>
          <target state="translated">在 C:\TestWFDemo1.ps1:8 char: 5</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Now writing output:"</source>
          <target state="translated">寫入輸出 InputObject 」 現在正在寫入輸出: 」</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~</source>
          <target state="translated">+!包含 [] ~ ~ ~</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>3:</source>
          <target state="translated">3：</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4︰ 工作流程 SampleWorkflowTest 5: {6: param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>8:*     Write-Output -InputObject "Now writing output:" 9:      Write-Output -Input $MyOutput</source>
          <target state="translated">8: * Write-output InputObject 」 現在正在寫入輸出: 「 9︰ 寫入輸出-輸入 $MyOutput</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: Write-output InputObject 」 取得 PowerShell 處理程序:"12: Get-process-名稱 powershell</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: Write-output-InputObject 」 工作流程函式完成 」。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # 呼叫工作流程函式 18: SampleWorkflowTest MyOutput"Hello"</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Hello</source>
          <target state="translated">Hello</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Now writing output: At C:\TestWFDemo1.ps1:9 char:5</source>
          <target state="translated">現在正在寫入輸出︰ 在 C:\TestWFDemo1.ps1:9 char: 5</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Write-Output -Input $MyOutput</source>
          <target state="translated">寫入輸出-輸入 $MyOutput</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~</source>
          <target state="translated">+!包含 [] ~</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>4:  workflow SampleWorkflowTest 5:  { 6:      param ($MyOutput)</source>
          <target state="translated">4︰ 工作流程 SampleWorkflowTest 5: {6: param ($MyOutput)</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>7:</source>
          <target state="translated">7:</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>8:      Write-Output -InputObject "Now writing output:" 9:*     Write-Output -Input $MyOutput</source>
          <target state="translated">8: Write-output InputObject 」 現在正在寫入輸出: 「 9: * 寫入輸出-輸入 $MyOutput</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>10:</source>
          <target state="translated">10:</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>11:      Write-Output -InputObject "Get PowerShell process:" 12:      Get-Process -Name powershell</source>
          <target state="translated">11: Write-output InputObject 」 取得 PowerShell 處理程序:"12: Get-process-名稱 powershell</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>14:      Write-Output -InputObject "Workflow function complete."</source>
          <target state="translated">14: Write-output-InputObject 」 工作流程函式完成 」。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>15:  }</source>
          <target state="translated">15:  }</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>16:</source>
          <target state="translated">16:</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>17:  # Call workflow function 18:  SampleWorkflowTest -MyOutput "Hello"</source>
          <target state="translated">17: # 呼叫工作流程函式 18: SampleWorkflowTest MyOutput"Hello"</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Hello At C:\TestWFDemo1.ps1:11 char:5</source>
          <target state="translated">Hello 在 C:\TestWFDemo1.ps1:11 char: 5</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Write-Output -InputObject "Get PowerShell process:"</source>
          <target state="translated">寫入輸出 InputObject 」 取得 PowerShell 處理程序: 」</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~~~~~</source>
          <target state="translated">+!包含 [] ~ ~ ~</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>WFDBG:localhost</source>
          <target state="translated">WFDBG:localhost</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Get PowerShell process:</source>
          <target state="translated">取得 PowerShell 處理程序︰</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Handles  NPM(K)    PM(K)   WS(K) VM(M)   CPU(s)     Id ProcessName    PSComputerName</source>
          <target state="translated">處理 NPM(K) PM(K) WS(K) VM(M) CPU 識別碼 ProcessName PSComputerName</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>433      35   106688   128392   726     2.67   7124 powershell    localhost 499      44   134244   172096   787     2.79   7452 powershell    localhost Workflow function complete.</source>
          <target state="translated">433 35 106688 128392 726 2.67 7124 powershell localhost 499 44 134244 172096 787 2.79 7452 powershell localhost 完成的工作流程函式。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Debugging Functions When you set a breakpoint on a function that has Begin, Process, and End sections, the debugger breaks at the first line of each section.</source>
          <target state="translated">偵錯工具偵錯函式，當您在具有 Begin、 Process 及 End 區段函式上設定中斷點，在每個區段的第一行中斷。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>function test-cmdlet { begin { write-output "Begin" } process { write-output "Process" } end { write-output "End" } }</source>
          <target state="translated">函式測試 cmdlet {開始 {寫入輸出"Begin"} {寫入輸出 」 處理程序 」} 處理序結束 {寫入輸出"End"}}</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; set-psbreakpoint -command test-cmdlet</source>
          <target state="translated">C:\PS&amp;GT; &gt; set psbreakpoint-命令測試 cmdlet</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>C:\PS&gt; test-cmdlet</source>
          <target state="translated">C:\PS&amp;GT; &gt; 測試 cmdlet</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Begin Entering debug mode.</source>
          <target state="translated">開始進入偵錯模式。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或嗎？</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">以取得協助。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">叫用命令中斷點 ' 提示︰ test-cmdlet'</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">測試 cmdlet</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Process Entering debug mode.</source>
          <target state="translated">處理輸入偵錯模式。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或嗎？</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">以取得協助。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">叫用命令中斷點 ' 提示︰ test-cmdlet'</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">測試 cmdlet</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>DBG</source>
          <target state="translated">DBG</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>End Entering debug mode.</source>
          <target state="translated">結束輸入偵錯模式。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或嗎？</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">以取得協助。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Hit Command breakpoint on 'prompt:test-cmdlet'</source>
          <target state="translated">叫用命令中斷點 ' 提示︰ test-cmdlet'</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>test-cmdlet</source>
          <target state="translated">測試 cmdlet</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS&gt;</source>
          <target state="translated"><bpt id="p1">[</bpt>DBG<ept id="p1">]</ept>: C:\PS&amp;GT; &gt;</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Debugging Remote Scripts Starting in Windows PowerShell 5.0, you can run the Windows PowerShell debugger in a remote session, in either the console, or Windows PowerShell ISE.</source>
          <target state="translated">偵錯遠端指令碼啟動 Windows PowerShell 5.0 中，您可以在主控台或 Windows PowerShell ISE 中的遠端工作階段中執行 Windows PowerShell 偵錯工具。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Enter-PSSession functionality has been updated to let you reconnect to and enter a disconnected session that is running on a remote computer, and currently running a script.</source>
          <target state="translated">Enter-pssession 功能已更新為可讓您重新連線至並進入中斷連線的工作階段執行的遠端電腦上，以及目前正在執行指令碼。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>If the running script hits a breakpoint, your client session automatically starts the debugger.</source>
          <target state="translated">如果執行的指令碼會叫用中斷點，您的用戶端工作階段會自動啟動偵錯工具。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The following is an example that shows how this works, with breakpoints set in a script at lines 6, 11, 22, and 25.</source>
          <target state="translated">以下是範例，顯示其運作方式，與在第 6、 11、 22 和 25 行指令碼中設定中斷點。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Note that in the example, when the debugger starts, there are two identifying prompts: the name of the computer on which the session is running, and the DBG prompt that lets you know you are in debugging mode.</source>
          <target state="translated">請注意，在範例中，偵錯工具啟動時，有兩個識別的提示︰ 電腦所在工作階段正在執行，與 DBG 提示，可讓您知道您在偵錯模式中的名稱。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Enter-Pssession -Cn localhost</source>
          <target state="translated">Enter-pssession-Cn localhost</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>ID Script          Line     Command          Variable          Action</source>
          <target state="translated">識別碼的指令碼行命令變數 」 動作</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>0 ttest19.ps1          6 1 ttest19.ps1          11 2 ttest19.ps1          22 3 ttest19.ps1          25</source>
          <target state="translated">0 ttest19.ps1 6 1 ttest19.ps1 11 2 ttest19.ps1 22 3 ttest19.ps1 25</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\psscripts\ttest19.ps1:11'</source>
          <target state="translated">'C:\psscripts\ttest19.ps1:11' 上叫用的行中斷點</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:11 char:1</source>
          <target state="translated">C:\psscripts\ttest19.ps1:11 char: 1</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>$winRMName = "WinRM"</source>
          <target state="translated">$winRMName ="WinRM"</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>6:      1..5 | foreach { sleep 1; Write-Output "hello2day $_" } 7:  }</source>
          <target state="translated">6: 1..5 |foreach {睡眠 1;Write-output"hello2day $_"} 7:}</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>8:</source>
          <target state="translated">8:</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>9:  $count = 10 10:  $psName = "PowerShell" 11:* $winRMName = "WinRM" 12:  $myVar = 102</source>
          <target state="translated">9: $count = 10 10: $psName ="PowerShell"11: * $winRMName ="WinRM"12: $myVar = 102</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>13:</source>
          <target state="translated">13:</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>14:  for ($i=0; $i -lt $count; $i++) 15:  { 16:      sleep 1 17:      Write-Output "Loop iteration is: $i" 18:      Write-Output "MyVar is $myVar"</source>
          <target state="translated">14︰ 針對 ($i = 0; $i lt $count; $i + +) 15: {16︰ 睡眠 1 17︰ 寫入輸出 」 迴圈反覆項目︰ $i"18︰ 寫入輸出 「 MyVar 是 $myVar 」</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>19:</source>
          <target state="translated">19:</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>20:      hello2day</source>
          <target state="translated">20: hello2day</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>21:</source>
          <target state="translated">21:</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>At C:\psscripts\ttest19.ps1:12 char:1</source>
          <target state="translated">C:\psscripts\ttest19.ps1:12 char: 1</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>$myVar = 102</source>
          <target state="translated">$myVar = 102</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>+ ~</source>
          <target state="translated">+ ~</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>localhost</source>
          <target state="translated">localhost</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>PS C:\psscripts&gt;</source>
          <target state="translated">PS C:\psscripts &gt;</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Examples This test script detects the version of the operating system and displays a system-appropriate message.</source>
          <target state="translated">此測試指令碼偵測到的作業系統版本，並顯示適當的系統訊息的範例。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>It includes a function, a function call, and a variable.</source>
          <target state="translated">它包含一個函式、 函式呼叫和變數。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The following command displays the contents of the test script file:</source>
          <target state="translated">下列命令會顯示測試指令碼檔案的內容︰</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>c:&gt;\PS-test&gt;  get-content test.ps1</source>
          <target state="translated">c: &gt; \PS-test &gt; 取得內容 test.ps1</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>function psversion { "Windows PowerShell " + $psversiontable.psversion if ($psversiontable.psversion.major -lt 2) { "Upgrade to Windows PowerShell 2.0!"</source>
          <target state="translated">函式 psversion {"Windows PowerShell"+ $psversiontable.psversion 如果 ($psversiontable.psversion.major-lt 2) {」 升級到 Windows PowerShell 2.0 ！ 」</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>} else { "Have you run a background job today (start-job)?"</source>
          <target state="translated">} else {」 有您執行背景工作今天 （工作）？ 」</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>} }</source>
          <target state="translated">} }</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>$scriptname = $MyInvocation.MyCommand.Path psversion "Done $scriptname."</source>
          <target state="translated">$scriptname = $MyInvocation.MyCommand.Path psversion 「 完成 $scriptname 」。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>To start, set a breakpoint at a point of interest in the script, such as a line, command, variable, or function.</source>
          <target state="translated">若要開始，請在感興趣的指令碼，例如線條、 命令、 變數或函式的點上設定中斷點。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Start by creating a line breakpoint on the first line of the Test.ps1 script in the current directory.</source>
          <target state="translated">開始建立 Test.ps1 指令碼目前的目錄中的第一行的行中斷點。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -line 1 -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; set psbreakpoint-行 1-指令碼 test.ps1</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">您可以將此命令縮寫為：</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; spb 1 -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; spb 1-s test.ps1</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>The command returns a line-breakpoint object (System.Management.Automation.LineBreakpoint).</source>
          <target state="translated">此命令會傳回行中斷點物件 （System.Management.Automation.LineBreakpoint）。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Column     : 0 Line       : 1 Action     : Enabled    : True HitCount   : 0 Id         : 0 Script     : C:\ps-test\test.ps1 ScriptName : C:\ps-test\test.ps1</source>
          <target state="translated">資料行︰ 0 線條︰ 1 個動作︰ 啟用︰ True 叫用次數︰ 識別碼 0: 0 的指令碼︰ C:\ps-test\test.ps1 ScriptName: C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">現在，啟動指令碼。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>When the script reaches the first breakpoint, the breakpoint message indicates that the debugger is active.</source>
          <target state="translated">當指令碼到達第一個中斷點時，中斷點訊息表示偵錯工具使用中。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>It describes the breakpoint and previews the first line of the script, which is a function declaration.</source>
          <target state="translated">它說明中斷點，並預覽的指令碼，也就是函式宣告的第一行。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The command prompt also changes to indicate that the debugger has control.</source>
          <target state="translated">命令提示字元中也會變更，表示偵錯工具控制。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>The preview line includes the script name and the line number of the previewed command.</source>
          <target state="translated">預覽列包含指令碼名稱和 [預覽] 命令的行號。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Entering debug mode.</source>
          <target state="translated">進入偵錯模式。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Use h or ?</source>
          <target state="translated">使用 h 或嗎？</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>for help.</source>
          <target state="translated">以取得協助。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>Hit Line breakpoint on 'C:\ps-test\test.ps1:1'</source>
          <target state="translated">'C:\ps-test\test.ps1:1' 上叫用的行中斷點</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>test.ps1:1   function psversion {</source>
          <target state="translated">test.ps1:1 function psversion {</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Use the Step command (s) to execute the first statement in the script and to preview the next statement.</source>
          <target state="translated">若要執行指令碼中的第一個陳述式，以及預覽下一個陳述式，請使用步驟命令 (s)。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The next statement uses the $MyInvocation automatic variable to set the value of the $ScriptName variable to the path and file name of the script file.</source>
          <target state="translated">下一個陳述式會使用 $MyInvocation 自動變數來設定指令碼檔案的路徑和檔案名稱 $ScriptName 變數的值。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:11  $scriptname = $MyInvocation.MyCommand.Path</source>
          <target state="translated">DBG &gt; s test.ps1:11 $scriptname = $MyInvocation.MyCommand.Path</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is not populated, but you can verify the value of the variable by displaying its value.</source>
          <target state="translated">此時，不會填入 $ScriptName 變數，但您可以檢查變數的值顯示其值。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>In this case, the value is $null.</source>
          <target state="translated">在此情況下，值為 $null。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Use another Step command (s) to execute the current statement and to preview the next statement in the script.</source>
          <target state="translated">若要執行目前的陳述式，以及預覽指令碼中的下一個陳述式，請使用另一個步驟命令 (s)。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The next statement calls the PsVersion function.</source>
          <target state="translated">下一個陳述式會呼叫 PsVersion 函式。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>At this point, the $ScriptName variable is populated, but you verify the value of the variable by displaying its value.</source>
          <target state="translated">此時，$ScriptName 變數已填入，，但您確認顯示其值的變數的值。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>In this case, the value is set to the script path.</source>
          <target state="translated">在此情況下，值會設定指令碼路徑。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Use another Step command to execute the function call.</source>
          <target state="translated">您可以使用另一個步驟命令來執行函式呼叫。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Press ENTER, or type "s" for Step.</source>
          <target state="translated">按 ENTER 鍵，或輸入"s"的步驟。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:2       "Windows PowerShell " + $psversiontable.psversion</source>
          <target state="translated">DBG &gt; s test.ps1:2"Windows PowerShell"+ $psversiontable.psversion</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The debug message includes a preview of the statement in the function.</source>
          <target state="translated">偵錯訊息包含函式中的陳述式的預覽。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>To execute this statement and to preview the next statement in the function, you can use a Step command.</source>
          <target state="translated">若要執行此陳述式，以及預覽下一個陳述式，函式中的，您可以使用逐步執行] 命令。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>But, in this case, use a Step-Out command (o).</source>
          <target state="translated">但是，在此情況下，使用跳離 」 命令 (o)。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>It completes the execution of the function (unless it reaches a breakpoint) and steps to the next statement in the script.</source>
          <target state="translated">完成執行函式 （除非到達中斷點） 和指令碼中的下一個陳述式的步驟。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>DBG&gt; o Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; o Windows PowerShell 2.0 已執行的背景工作今天 （工作）？</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">test.ps1:13 「 完成 $scriptname 」</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>Because we are on the last statement in the script, the Step, Step-Out, and Continue commands have the same effect.</source>
          <target state="translated">因為我們是在步驟中，指令碼中的最後一個陳述式跳離和繼續命令的效果相同。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>In this case, use Step-Out (o).</source>
          <target state="translated">在此情況下，使用 [跳離 (o)。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1 PS C:\ps-test&gt;</source>
          <target state="translated">完成 C:\ps-test\test.ps1 PS C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The Step-Out command executes the last command.</source>
          <target state="translated">跳離命令執行的最後一個命令。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>The standard command prompt indicates that the debugger has exited and returned control to the command processor.</source>
          <target state="translated">標準命令提示字元表示偵錯工具已結束並返回命令處理器上的控制項。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Now, run the debugger again.</source>
          <target state="translated">現在，再次執行偵錯工具。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>First, to delete the current breakpoint, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">首先，若要刪除目前的中斷點，請使用 Get-psbreakpoint 和 Remove-psbreakpoint cmdlet。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>(If you think you might reuse the breakpoint, use the Disable-PsBreakpoint cmdlet instead of Remove-PsBreakpoint.)</source>
          <target state="translated">（如果您認為您可能會重複使用中斷點，使用 Disable-psbreakpoint cmdlet 而不是 Remove-psbreakpoint）。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test &gt; Get-psbreakpoint |Remove-psbreakpoint</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command as:</source>
          <target state="translated">您可以將此命令縮寫為：</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; gbp | rbp</source>
          <target state="translated">PS C:\ps-test &gt; gbp |rbp</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Or, run the command by writing a function, such as the following function:</source>
          <target state="translated">或者，您也可以撰寫一項功能，例如下列函式來執行命令︰</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>function delbr { gbp | rbp }</source>
          <target state="translated">函式 delbr {gbp | rbp}</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Now, create a breakpoint on the $scriptname variable.</source>
          <target state="translated">現在，$scriptname 變數上建立中斷點。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -variable scriptname -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; set psbreakpoint-變數 scriptname-test.ps1 指令碼</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>You can abbreviate the command as:</source>
          <target state="translated">您可以將做為命令的縮寫︰</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -v scriptname -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; sbp-v scriptname-s test.ps1</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Now, start the script.</source>
          <target state="translated">現在，啟動指令碼。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>The script reaches the variable breakpoint.</source>
          <target state="translated">指令碼的中斷點變數。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>The default mode is Write, so execution stops just before the statement that changes the value of the variable.</source>
          <target state="translated">預設模式是寫入的因此變更變數的值的陳述式之前停止執行。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Variable breakpoint on 'C:\ps-test\test.ps1:$scriptname' (Write access)</source>
          <target state="translated">PS C:\ps-test &gt;.\test.ps1 變數叫用中斷點 'C:\ps-test\test.ps1:$scriptname' （寫入存取權）</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>test.ps1:11  $scriptname = $MyInvocation.mycommand.path</source>
          <target state="translated">test.ps1:11 $scriptname = $MyInvocation.mycommand.path</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Display the current value of the $scriptname variable, which is $null.</source>
          <target state="translated">顯示 $scriptname 變數，也就是 $null 的目前值。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname</source>
          <target state="translated">DBG &gt; $scriptname</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to execute the statement that populates the variable.</source>
          <target state="translated">您可以使用逐步執行] 命令 (s) 來執行填入變數的陳述式。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Then, display the new value of the $scriptname variable.</source>
          <target state="translated">然後，顯示 $scriptname 變數的新值。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>DBG&gt; $scriptname C:\ps-test\test.ps1</source>
          <target state="translated">DBG &gt; $scriptname C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Use a Step command (s) to preview the next statement in the script.</source>
          <target state="translated">若要預覽的指令碼中的下一個陳述式使用逐步執行] 命令 (s)。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>DBG&gt; s test.ps1:12  psversion</source>
          <target state="translated">DBG &gt; s test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>The next statement is a call to the PsVersion function.</source>
          <target state="translated">下一個陳述式是 PsVersion 函式的呼叫。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>To skip the function but still execute it, use a Step-Over command (v).</source>
          <target state="translated">Skip 函式，但仍加以執行，請使用不進入函式命令 (v)。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>If you are already in the function when you use Step-Over, it is not effective.</source>
          <target state="translated">如果您已在函數中使用不進入函式時，它便無法生效。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The function call is displayed, but it is not executed.</source>
          <target state="translated">函式呼叫會顯示，但它不會執行。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>DBG&gt; v Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; v Windows PowerShell 2.0 已執行的背景工作今天 （工作）？</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>test.ps1:13  "Done $scriptname"</source>
          <target state="translated">test.ps1:13 「 完成 $scriptname 」</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>The Step-Over command executes the function, and it previews the next statement in the script, which prints the final line.</source>
          <target state="translated">不進入函式命令執行函式，並將它預覽列印的最後一行的指令碼中的下一個陳述式。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Use a Stop command (t) to exit the debugger.</source>
          <target state="translated">若要結束偵錯工具使用 Stop] 命令 (t)。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The command prompt reverts to the standard command prompt.</source>
          <target state="translated">命令提示字元會還原成標準命令提示字元。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>C:\ps-test&gt;</source>
          <target state="translated">C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>To delete the breakpoints, use the Get-PsBreakpoint and Remove-PsBreakpoint cmdlets.</source>
          <target state="translated">若要刪除的中斷點，請使用 Get-psbreakpoint 和 Remove-psbreakpoint cmdlet。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Get-PsBreakpoint | Remove-PSBreakpoint</source>
          <target state="translated">PS C:\ps-test &gt; Get-psbreakpoint |Remove-psbreakpoint</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Create a new command breakpoint on the PsVersion function.</source>
          <target state="translated">PsVersion 函式上建立新的命令中斷點。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; Set-PsBreakpoint -command psversion -script test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; Set-psbreakpoint-命令 psversion-test.ps1 指令碼</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>You can abbreviate this command to:</source>
          <target state="translated">您可以將這個命令的縮寫︰</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; sbp -c psversion -s test.ps1</source>
          <target state="translated">PS C:\ps-test &gt; sbp-c psversion-s test.ps1</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">現在，執行指令碼。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test &gt; 'C:\ps-test\test.ps1:psversion'.\test.ps1 叫用命令中斷點</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>DBG&gt;</source>
          <target state="translated">DBG &gt;</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>The script reaches the breakpoint at the function call.</source>
          <target state="translated">指令碼中斷點的函式呼叫。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>At this point, the function has not yet been called.</source>
          <target state="translated">此時，函式具有尚未呼叫。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>This gives you the opportunity to use the Action parameter of Set-PsBreakpoint to set conditions for the execution of the breakpoint or to perform preparatory or diagnostic tasks, such as starting a log or invoking a diagnostic or security script.</source>
          <target state="translated">這樣您就可以使用 Set-psbreakpoint 的動作參數，設定的中斷點執行的條件，或執行準備或診斷工作，例如啟動記錄檔，或叫用診斷或安全性的指令碼。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>To set an action, use a Continue command (c) to exit the script, and a Remove-PsBreakpoint command to delete the current breakpoint.</source>
          <target state="translated">若要設定的動作，使用繼續指令 (c) 以結束指令碼，並刪除目前中斷點的 Remove-psbreakpoint 命令。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>(Breakpoints are read-only, so you cannot add an action to the current breakpoint.)</source>
          <target state="translated">（中斷點是唯讀的因此您無法將動作加入至目前的中斷點）。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>DBG&gt; c Windows PowerShell 2.0 Have you run a background job today (start-job)?</source>
          <target state="translated">DBG &gt; c Windows PowerShell 2.0 已執行的背景工作今天 （工作）？</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Done C:\ps-test\test.ps1</source>
          <target state="translated">完成的 C:\ps-test\test.ps1</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; get-psbreakpoint | remove-psbreakpoint PS C:\ps-test&gt;</source>
          <target state="translated">PS C:\ps-test &gt; get psbreakpoint |移除 psbreakpoint PS C:\ps-test &gt;</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>Now, create a new command breakpoint with an action.</source>
          <target state="translated">現在，建立新的命令中斷點與動作。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>The following command sets a command breakpoint with an action that logs the value of the $scriptname variable when the function is called.</source>
          <target state="translated">下列命令會將動作記錄 $scriptname 變數的值，在呼叫函式與命令中斷點。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Because the Break keyword is not used in the action, execution does not stop.</source>
          <target state="translated">因為動作並未使用 Break 關鍵字，就不會停止執行。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the line-continuation character.)</source>
          <target state="translated">（倒單引號 （'） 是行接續字元）。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -command psversion -script test.ps1  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname is $scriptname."</source>
          <target state="translated">PS C:\ps-test &gt; set psbreakpoint-命令 psversion-test.ps1 指令碼  <ph id="ph1">`
-action { add-content "The value of `</ph>$scriptname 是 $scriptname。 」</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>` -path action.log}</source>
          <target state="translated">-路徑 action.log}</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>You can also add actions that set conditions for the breakpoint.</source>
          <target state="translated">您也可以新增設定條件中斷點的動作。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>In the following command, the command breakpoint is executed only if the execution policy is set to RemoteSigned, the most restrictive policy that still permits you to run scripts.</source>
          <target state="translated">在下列命令中，執行原則設為 RemoteSigned，仍可讓您執行指令碼的最高限制原則時，才會執行命令中斷點。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>(The backtick (`) is the continuation character.)</source>
          <target state="translated">（倒單引號 （'） 是接續字元）。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; set-psbreakpoint -script test.ps1 -command psversion ` -action { if ((get-executionpolicy) -eq "RemoteSigned") { break }}</source>
          <target state="translated">PS C:\ps-test &gt; set psbreakpoint-test.ps1 指令碼-命令 psversion '-動作 {如果 ((get-executionpolicy)-eq"RemoteSigned") {中斷}}</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>The Break keyword in the action directs the debugger to execute the breakpoint.</source>
          <target state="translated">在動作 Break 關鍵字會指示偵錯工具執行中斷點。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>You can also use the Continue keyword to direct the debugger to execute without breaking.</source>
          <target state="translated">您也可以直接執行而不會中斷偵錯工具使用 Continue 關鍵字。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Because the default keyword is Continue, you must specify Break to stop execution.</source>
          <target state="translated">預設關鍵字為 Continue，因為您必須指定中斷] 來停止執行。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>Now, run the script.</source>
          <target state="translated">現在，執行指令碼。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>PS C:\ps-test&gt; .\test.ps1 Hit Command breakpoint on 'C:\ps-test\test.ps1:psversion'</source>
          <target state="translated">PS C:\ps-test &gt; 'C:\ps-test\test.ps1:psversion'.\test.ps1 叫用命令中斷點</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>test.ps1:12  psversion</source>
          <target state="translated">test.ps1:12 psversion</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>Because the execution policy is set to RemoteSigned, execution stops at the function call.</source>
          <target state="translated">因為執行原則設為 RemoteSigned，執行會停止在函式呼叫。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>At this point, you might want to check the call stack.</source>
          <target state="translated">此時，您可能想要檢查呼叫堆疊。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Use the Get-PsCallStack cmdlet or the Get-PsCallStack debugger command (k).</source>
          <target state="translated">使用 Get-pscallstack cmdlet 或 Get-pscallstack 偵錯工具命令 (k)。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The following command gets the current call stack.</source>
          <target state="translated">下列命令會取得目前的呼叫堆疊。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>DBG&gt; k 2: prompt 1: .\test.ps1: $args=[] 0: prompt: $args=[]</source>
          <target state="translated">DBG &gt; k 2: 1 的提示︰.\test.ps1: $args = [0]: 提示︰ $args =]</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>This example demonstrates just a few of the many ways to use the Windows PowerShell debugger.</source>
          <target state="translated">這個範例會示範幾個許多方法可以使用 Windows PowerShell 偵錯工具。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>For more information about the debugger cmdlets, type the following command:</source>
          <target state="translated">如需有關偵錯工具 cmdlet 的詳細資訊，請輸入下列命令︰</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>help &lt;cmdlet-name&gt; -full</source>
          <target state="translated">說明 &lt; 指令程式名稱 &gt;-完整</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>For example, type:</source>
          <target state="translated">例如，輸入︰</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>help set-psbreakpoint -full</source>
          <target state="translated">說明 set psbreakpoint-完整</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Other Debugging Features in Windows PowerShell</source>
          <target state="translated">在 Windows PowerShell 中的其他偵錯功能</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>In addition to the Windows PowerShell debugger, Windows PowerShell includes several other features that you can use to debug scripts and functions.</source>
          <target state="translated">除了 Windows PowerShell 偵錯工具，Windows PowerShell 還包含數個其他功能，您可以使用偵錯指令碼和函式。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>-- Windows PowerShell Integrated Scripting Environment (ISE) includes an interactive graphical debugger.</source>
          <target state="translated">-Windows PowerShell 整合式指令碼環境 (ISE) 包含互動式的圖形化偵錯工具。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>For more information, start Windows PowerShell ISE and press F1.</source>
          <target state="translated">如需詳細資訊，請啟動 Windows PowerShell ISE，然後按 F1。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>-- The Set-PSDebug cmdlet offers very basic script debugging features, including stepping and tracing.</source>
          <target state="translated">--Set-psdebug cmdlet 提供非常基本的指令碼偵錯功能，包括逐步執行和追蹤。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>-- Use the Set-StrictMode cmdlet to detect references to uninitialized variables, to references to non-existent properties of an object, and to function syntax that is not valid.</source>
          <target state="translated">-使用 Set-strictmode cmdlet 來偵測參考未初始化的變數，參考不存在物件的屬性，並不是有效的函式語法。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>-- Add diagnostic statements to a script, such as statements that display the value of variables, statements that read input from the command line, or statements that report the current instruction.</source>
          <target state="translated">--指令碼，例如顯示的變數值的陳述式、 陳述式，讀取從命令列中，輸入或報告在目前指令的陳述式中加入診斷陳述式。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>Use the cmdlets that contain the Write verb for this task, such as Write-Host, Write-Debug, Write-Warning, and Write-Verbose.</source>
          <target state="translated">使用包含這項工作，例如寫入-寫入偵錯主機 Write-warning，寫入動作和 Write-verbose 指令程式。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>Disable-PsBreakpoint Enable-PsBreakpoint Get-PsBreakpoint Get-PsCallStack Remove-PsBreakpoint Set-PsBreakpoint Set-PsDebug Set-Strictmode Write-Debug Write-Verbose</source>
          <target state="translated">Disable-psbreakpoint 啟用-PsBreakpoint Get-psbreakpoint Get-設定 PsCallStack Remove-psbreakpoint Set-psbreakpoint Set-psdebug-Set-strictmode Write-debug Write-verbose</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>