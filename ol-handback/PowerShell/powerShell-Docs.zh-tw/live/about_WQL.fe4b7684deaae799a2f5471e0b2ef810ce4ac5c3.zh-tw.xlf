<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="zh-tw">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-1c394fd" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">6ecdbd81dcae8a8dfd13085671043cf9586d37e8</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">reference\5.0\Microsoft.PowerShell.Core\About\about_WQL.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b41396f637be60f315f501319161148c8f275724</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3db30d43b3e70cf5b7eb3abff7fdb721e43fa9b9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>about_WQL</source>
          <target state="translated">about_WQL</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell, cmdlet</source>
          <target state="translated">powershell 指令程式</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>About WQL</source>
          <target state="translated">有關 WQL</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>about_WQL</source>
          <target state="translated">about_WQL</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>about_WQL</source>
          <target state="translated">about_WQL</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>SHORT DESCRIPTION</source>
          <target state="translated">簡短描述</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Describes WMI Query Language (WQL), which can be used to get WMI objects in Windows PowerShell.</source>
          <target state="translated">描述 WMI 查詢語言 (WQL)，這可用於取得 Windows PowerShell 中的 WMI 物件。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>LONG DESCRIPTION</source>
          <target state="translated">詳細描述</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>WQL is the Windows Management Instrumentation (WMI) query language, which is the language used to get information from WMI.</source>
          <target state="translated">WQL 是 Windows Management Instrumentation (WMI) 查詢語言，也就是用來從 WMI 取得資訊的語言。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You are not required to use WQL to perform a WMI query in Windows PowerShell.</source>
          <target state="translated">您不需要使用在 Windows PowerShell 中執行 WMI 查詢的 WQL。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Instead, you can use the parameters of the Get-WmiObject or Get-CimInstance cmdlets.</source>
          <target state="translated">相反地，您可以使用 Get-wmiobject 或 Get-ciminstance cmdlet 的參數。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>WQL queries are somewhat faster than standard Get-WmiObject commands and the improved performance is evident when the commands run on hundreds of systems.</source>
          <target state="translated">WQL 查詢的速度會較快比標準 Get-wmiobject 命令，並改善的效能是很明顯數百部系統上執行的命令。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>However, be sure that the time you spend to write a successful WQL query doesn't outweigh the performance improvement.</source>
          <target state="translated">不過，一定要撰寫成功的 WQL 查詢所花費的時間不超過效能改進。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The basic WQL statements you need to use WQL are Select, Where, and From.</source>
          <target state="translated">您必須使用 WQL 的基本 WQL 陳述式是 Select、 何處、 及從。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>WHEN TO USE WQL</source>
          <target state="translated">使用 WQL 的時機</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>When working with WMI, and especially with WQL, do not forget that you are also using Windows PowerShell.</source>
          <target state="translated">當使用使用 WMI，而且特別是使用 WQL 時，請不要忘記也使用 Windows PowerShell。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Often, if a WQL query does not work as expected, it's easier to use a standard Windows PowerShell command than to debug the WQL query.</source>
          <target state="translated">通常，如果 WQL 查詢不會無法如預期運作，則您更輕鬆地使用標準的 Windows PowerShell 命令，比要進行偵錯的 WQL 查詢。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Unless you are returning massive amounts of data from across bandwidth-constrained remote systems, it is rarely productive to spend hours trying to perfect a complicated and convoluted WQL query when there is a perfectly acceptable Windows cmdlet that does the same thing, if a bit more slowly.</source>
          <target state="translated">除非您在頻寬受限的遠端系統上傳回的資料量很大，它很少效率很花時間嘗試完美很複雜，迂迴的 WQL 查詢時所執行的動作，完全可以接受 Windows cmdlet 如果位元速度更慢。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>USING THE SELECT STATEMENT</source>
          <target state="translated">使用 SELECT 陳述式</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A typical WMI query begins with a Select statement that gets all properties or particular properties of a WMI class.</source>
          <target state="translated">一般的 WMI 查詢取得所有的屬性或 WMI 類別的特定屬性的 Select 陳述式的開頭。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>To select all properties of a WMI class, use an asterisk (*).</source>
          <target state="translated">若要選取 WMI 類別的所有內容，使用星號 （*）。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The From keyword specifies the WMI class.</source>
          <target state="translated">From 關鍵字指定的 WMI 類別。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>A Select statement has the following format:</source>
          <target state="translated">Select 陳述式具有下列格式︰</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Select <ph id="ph1">&lt;property&gt;</ph> from &lt;WMI-class&gt;</source>
          <target state="translated">選取 <ph id="ph1">&lt;property&gt;</ph> 從 &lt; WMI 類別 &gt;</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For example, the following Select statement selects all properties (*) from the instances of the Win32_Bios WMI class.</source>
          <target state="translated">例如，下列 Select 陳述式會從 Win32_Bios WMI 類別的執行個體中，選取所有屬性 （*）。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Select * from Win32_Bios</source>
          <target state="translated">選取 * 從 Win32_Bios</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>To select a particular property of a WMI class, place the property name between the Select and From keywords.</source>
          <target state="translated">若要選取 WMI 類別的特定屬性，將屬性名稱以及與關鍵字之間選取。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following query selects only the name of the BIOS from the Win32_Bios WMI class.</source>
          <target state="translated">下列查詢會從 Win32_Bios WMI 類別選取 BIOS 的名稱。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The command saves the query in the $queryName variable.</source>
          <target state="translated">命令會將查詢儲存在 $queryName 變數中。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Select Name from Win32_Bios</source>
          <target state="translated">從 Win32_Bios 中選取名稱</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To select more than one property, use commas to separate the property names.</source>
          <target state="translated">若要選取多個屬性，請使用逗號來分隔屬性名稱。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The following WMI query selects the name and the version of the Win32_Bios WMI class.</source>
          <target state="translated">下列的 WMI 查詢會選取名稱和版本的 Win32_Bios WMI 類別。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The command saves the query in the $queryNameVersion variable.</source>
          <target state="translated">命令會將查詢儲存在 $queryNameVersion 變數中。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Select name, version from Win32_Bios</source>
          <target state="translated">選取名稱，從 Win32_Bios 版本</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>USING THE WQL QUERY</source>
          <target state="translated">使用 WQL 查詢</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>There are two ways to use WQL query in Windows PowerShell command.</source>
          <target state="translated">有兩種方式可在 Windows PowerShell 命令中使用 WQL 查詢。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>-- Use the Get-WmiObject cmdlet -- Use the Get-CimInstance cmdlet -- Use the [wmisearcher] type accelerator.</source>
          <target state="translated">-使用 Get-wmiobject cmdlet-使用 Get-ciminstance 指令程式-使用 [wmisearcher] 類型加速器。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>USING THE GET-WMIOBJECT CMDLET</source>
          <target state="translated">使用 GET-WMIOBJECT CMDLET</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The most basic way to use the WQL query is to enclose it in quotation marks (as a string) and then use the query string as the value of the Query parameter of the Get-WmiObject cmdlet, as shown in the following example.</source>
          <target state="translated">若要使用的 WQL 查詢的最基本的方式是將它括在引號 （做為字串），然後使用 Get-wmiobject 指令程式，將查詢參數的值的查詢字串，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Query "Select * from Win32_Bios"</source>
          <target state="translated">PS C: &gt; Get-wmiobject-查詢 」 選取 * 從 Win32_Bios 」</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW (1.36) 製造商︰ LENOVO 名稱︰ 預設系統 BIOS 序號︰ R9FPY3P 版本︰ LENOVO – 1360年</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You can also save the WQL statement in a variable and then use the variable as the value of the Query parameter, as shown in the following command.</source>
          <target state="translated">您可以也儲存在變數中的 WQL 陳述式，然後使用該變數做為查詢參數的值，如下列命令中所示。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $query = "Select * from Win32_Bios" PS C:&gt; Get-WmiObject –Query $query</source>
          <target state="translated">PS $query c: &gt; ="選取 * 從 Win32_Bios"PS c: &gt; Get-wmiobject – 查詢 $query</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can use either format with any WQL statement.</source>
          <target state="translated">您可以使用任一格式與任何 WQL 陳述式。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The following command uses the query in the $queryName variable to get only the name and version properties of the system BIOS.</source>
          <target state="translated">下列命令會使用 $queryName 變數中的查詢，來取得只有名稱和版本屬性的系統 BIOS。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $queryNameVersion = "Select Name, Version from Win32_Bios" PS C:&gt; Get-WmiObject -Query $queryNameVersion</source>
          <target state="translated">PS $queryNameVersion c: &gt; = [選取名稱和版本從 Win32_Bios] PS c: &gt; Get-wmiobject-查詢 $queryNameVersion</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS Version          : LENOVO - 1360</source>
          <target state="translated">名稱︰ 預設系統 BIOS 版本︰ LENOVO-1360年</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Remember that you can use the parameters of the Get-WmiObject cmdlet to get the same result.</source>
          <target state="translated">請記住，您可以使用 Get-wmiobject cmdlet 的參數來取得相同的結果。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>For example, the following command also gets the values of the Name and Version properties of instances of the Win32_Bios WMI class.</source>
          <target state="translated">例如，下列命令也會取得 Win32_Bios WMI 類別的執行個體的名稱和版本屬性的值。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject –Class Win32_Bios -Property Name, Version</source>
          <target state="translated">PS C: &gt; Get-wmiobject – 類別 Win32_Bios-屬性名稱、 版本</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS Version          : LENOVO - 1360</source>
          <target state="translated">名稱︰ 預設系統 BIOS 版本︰ LENOVO-1360年</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>USING THE GET-CIMINSTANCE CMDLET</source>
          <target state="translated">使用 GET-CIMINSTANCE 指令程式</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Beginning in Windows PowerShell 3.0, you can use the Get-CimInstance cmdlet to run WQL queries.</source>
          <target state="translated">從 Windows PowerShell 3.0 開始，您可以使用 Get-ciminstance 指令程式來執行 WQL 查詢。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Get-CimInstance gets instances of CIM-compliant classes, including WMI classes.</source>
          <target state="translated">Get-ciminstance 取得 CIM 相容的類別，包含 WMI 類別的執行個體。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The CIM cmdlets, introduced Windows PowerShell 3.0, perform the same tasks as the WMI cmdlets.</source>
          <target state="translated">CIM cmdlet 導入 Windows PowerShell 3.0 中，執行與 WMI cmdlet 相同的工作。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The CIM cmdlets comply with WS-Management (WSMan) standards and with the Common Information Model (CIM) standard, which enables the cmdlets to use the same techniques to manage Windows computers and computers that are running other operating systems.</source>
          <target state="translated">CIM cmdlet 符合 Ws-management (WSMan) 標準，以通用訊息模型 (CIM) 標準，可讓指令程式來使用相同的技術來管理 Windows 電腦和執行其他作業系統的電腦。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The following command uses the Get-CimInstance cmdlet to run a WQL query.</source>
          <target state="translated">下列命令會使用 Get-ciminstance 指令程式來執行的 WQL 查詢。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Any WQL query that can be used with Get-WmiObject can also be used with Get-CimInstance.</source>
          <target state="translated">任何可以搭配 Get-wmiobject 的 WQL 查詢也可以搭配 Get-ciminstance。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-CimInstance -Query "Select * from Win32_Bios"</source>
          <target state="translated">PS C: &gt; Get-ciminstance-查詢 」 選取 * 從 Win32_Bios 」</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW (1.36) 製造商︰ LENOVO 名稱︰ 預設系統 BIOS 序號︰ R9FPY3P 版本︰ LENOVO – 1360年</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Get-CimInstance returns a CimInstance object, instead of the ManagementObject that Get-WmiObject returns, but the objects are quite similar.</source>
          <target state="translated">Get-ciminstance 傳回 CimInstance 物件，而不是 ManagementObject 該 Get-wmiobject 傳回，但物件是非常類似。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>PS C:&gt;(Get-CimInstance -Query "Select <bpt id="p1">*</bpt> from Win32_Bios").GetType().FullName Microsoft.Management.Infrastructure.CimInstance PS C:&gt;(Get-WmiObject -Query "Select <ept id="p1">*</ept> from Win32_Bios").GetType().FullName System.Management.ManagementObject</source>
          <target state="translated">PS C: &gt; (Get-ciminstance-查詢"Select <bpt id="p1">*</bpt> 從 Win32_Bios 」)。GetType()。FullName Microsoft.Management.Infrastructure.CimInstance PS c: &gt; (Get-wmiobject-查詢"Select <ept id="p1">*</ept> 從 Win32_Bios 」)。GetType()。FullName System.Management.ManagementObject</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>USING THE [wmisearcher] TYPE ACCELERATOR</source>
          <target state="translated">使用 [wmisearcher] 類型加速器</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The [wmisearcher] type accelerator creates a ManagementObjectSearcher object from a WQL statement string.</source>
          <target state="translated">[Wmisearcher] 類型加速器 ManagementObjectSearcher 從建立物件的 WQL 陳述式字串。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The ManagementObjectSearcher object has many properties and methods, but the most basic method is the Get method, which invokes the specified WMI query and returns the resulting objects.</source>
          <target state="translated">ManagementObjectSearcher 物件有許多屬性和方法，但最基本的方法是 Get 方法，它會叫用指定的 WMI 查詢，並傳回結果的物件。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>By using the [wmisearcher], you gain easy access to the ManagementObjectSearcher .NET Framework class.</source>
          <target state="translated">藉由使用 [wmisearcher]，即可輕鬆存取 ManagementObjectSearcher.NET Framework 類別。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>This lets you query WMI and to configure the way the query is conducted.</source>
          <target state="translated">這可讓您查詢 WMI，並進行查詢的方式進行設定。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>To use the [wmisearcher] type accelerator:</source>
          <target state="translated">若要使用 [wmisearcher] 類型加速器︰</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Cast the  WQL string into a ManagementObjectSearcher object.</source>
          <target state="translated">將 WQL 字串轉換成 ManagementObjectSearcher 物件。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Call the Get method of the ManagementObjectSearcher object.</source>
          <target state="translated">呼叫 ManagementObjectSearcher 物件的 Get 方法。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, the following command casts the "select all" query, saves the result in the $bios variable, and then calls the Get method of the ManagementObjectSearcher object in the $bios variable.</source>
          <target state="translated">例如，下列命令會轉換為 [請選取所有的項目] 查詢、 將結果儲存在 $bios 變數中，然後呼叫 ManagementObjectSearcher 物件的 Get 方法 $bios 變數中。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $bios = [wmisearcher]"Select * from Win32_Bios" PS C:&gt; $bios.Get()</source>
          <target state="translated">PS $bios c: &gt; = [wmisearcher] 」 選取 * 從 Win32_Bios"c: &gt; $bios PS。Get()</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW (1.36) 製造商︰ LENOVO 名稱︰ 預設系統 BIOS 序號︰ R9FPY3P 版本︰ LENOVO – 1360年</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>NOTE: Only selected object properties are displayed by default.</source>
          <target state="translated">附註︰ 預設會顯示只有所選的物件的屬性。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>These properties are defined in the Types.ps1xml file.</source>
          <target state="translated">這些屬性會定義在 Types.ps1xml 檔案。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>You can use the [wmisearcher] type accelerator to cast the query or the variable.</source>
          <target state="translated">您可以使用 [wmisearcher] 類型加速器轉型查詢或變數。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>In the following example, the [wmisearcher] type accelerator is used to cast the variable.</source>
          <target state="translated">在下列範例中，[wmisearcher] 類型加速器用來轉換變數。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The result is the same.</source>
          <target state="translated">結果是一樣的。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>PS C:&gt; [wmisearcher]$bios = "Select * from Win32_Bios" PS C:&gt; $bios.Get()</source>
          <target state="translated">PS C: &gt; [wmisearcher] $bios ="選取 * 從 Win32_Bios"PS c: &gt; $bios。Get()</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>SMBIOSBIOSVersion : 8BET56WW (1.36 ) Manufacturer      : LENOVO Name              : Default System BIOS SerialNumber      : R9FPY3P Version           : LENOVO – 1360</source>
          <target state="translated">SMBIOSBIOSVersion: 8BET56WW (1.36) 製造商︰ LENOVO 名稱︰ 預設系統 BIOS 序號︰ R9FPY3P 版本︰ LENOVO – 1360年</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>When you use the [wmisearcher] type accelerator, it changes the query string into a ManagementObjectSearcher object, as shown in the following commands.</source>
          <target state="translated">當您使用 [wmisearcher] 類型加速器時，它會變更查詢字串 ManagementObjectSearcher 物件中，下列命令所示。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$a = "Select * from Win32_Bios" PS C:&gt;$a.GetType().FullName System.String</source>
          <target state="translated">PS C: &gt;$ a ="選取 * 從 Win32_Bios"PS &gt; $a.GetType()。FullName System.String</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$a = [wmisearcher]"Select * from Win32_Bios" PS C:&gt;$a.GetType().FullName System.Management.ManagementObjectSearcher</source>
          <target state="translated">PS C: &gt;$ a [wmisearcher] ="選取 * 從 Win32_Bios"PS &gt; $a.GetType()。FullName System.Management.ManagementObjectSearcher</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This command format works on any query.</source>
          <target state="translated">此命令格式適用於任何查詢。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The following command gets the value of the Name property of the Win32_Bios WMI class.</source>
          <target state="translated">下列命令會取得 Win32_Bios WMI 類別的名稱屬性的值。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $biosname = [wmisearcher]"Select Name from Win32_Bios" PS C:&gt; $biosname.Get()</source>
          <target state="translated">PS $biosname c: &gt; = [wmisearcher]"選取從 Win32_Bios Name"PS c: &gt; $biosname。Get()</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS</source>
          <target state="translated">名稱︰ 預設系統 BIOS</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>You can perform this operation in a single command, although the command is a bit more difficult to interpret.</source>
          <target state="translated">雖然命令是更難解譯，您可以在單一命令中，執行這項作業。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In this format, you use the [wmisearcher] type accelerator to cast the WQL query string to a ManagementObjectSearcher, and then call the Get method on the object -- all in a single command.</source>
          <target state="translated">在這種格式，您使用 [wmisearcher] 類型加速器轉換 ManagementObjectSearcher 的 WQL 查詢字串，然後 Get 方法上呼叫物件--全部都在單一命令。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The parentheses () that enclose the casted string direct Windows PowerShell to cast the string before calling the method.</source>
          <target state="translated">括號 （） 括住轉換的字串，指示 Windows PowerShell 將字串轉換呼叫方法之前。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>PS C:&gt; ([wmisearcher]"Select name from Win32_Bios").Get()</source>
          <target state="translated">PS C: &gt; ([wmisearcher]"Select name from Win32_Bios 」)。Get()</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>__GENUS          : 2</source>
          <target state="translated">__GENUS: 2</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>__CLASS          : Win32_BIOS</source>
          <target state="translated">__CLASS: Win32_BIOS</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>__SUPERCLASS     :</source>
          <target state="translated">__SUPERCLASS:</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>__DYNASTY        :</source>
          <target state="translated">__DYNASTY:</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>__RELPATH        :</source>
          <target state="translated">__RELPATH:</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>__PROPERTY_COUNT : 1</source>
          <target state="translated">__PROPERTY_COUNT: 1</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>__DERIVATION     : {}</source>
          <target state="translated">__DERIVATION: {}</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>__SERVER         :</source>
          <target state="translated">__SERVER:</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>__NAMESPACE      :</source>
          <target state="translated">__NAMESPACE:</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>__PATH           :</source>
          <target state="translated">__PATH:</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Name             : Default System BIOS</source>
          <target state="translated">名稱︰ 預設系統 BIOS</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>USING THE BASIC WQL WHERE STATEMENT</source>
          <target state="translated">使用基本的 WQL 其中陳述式</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>A Where statement establishes conditions for the data that a Select statement returns.</source>
          <target state="translated">答︰ 在陳述式建立 Select 陳述式傳回的資料條件。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The Where statement has the following format:</source>
          <target state="translated">Where 陳述式具有下列格式︰</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>where</source>
          <target state="translated">其中</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如：</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>where Name = 'Notepad.exe'</source>
          <target state="translated">where Name = 'Notepad.exe'</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The Where statement is used with the Select statement, as shown in the following example.</source>
          <target state="translated">Where 陳述式搭配 Select 陳述式，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Select * from Win32_Process where Name = 'Notepad.exe'</source>
          <target state="translated">選取 * from Win32_Process where Name = 'Notepad.exe'</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When using the Where statement, the property name and value must be accurate.</source>
          <target state="translated">當使用 Where 陳述式、 屬性名稱和值必須是正確的。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the Notepad processes on the local computer.</source>
          <target state="translated">例如，下列命令會取得本機電腦上 「 記事本 」 處理程序。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Query "Select * from Win32_Process where name = 'Notepad.exe'"</source>
          <target state="translated">PS C: &gt; Get-wmiobject-查詢 」 選取 * from Win32_Process where name = 'Notepad.exe' 」</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>However, the following command fails, because the process name includes the ".exe" file name extension.</source>
          <target state="translated">不過，下列命令會失敗，因為處理序名稱包含".exe"副檔名。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Query "Select * from Win32_Process where name = 'Notepad'"</source>
          <target state="translated">PS C: &gt; Get-wmiobject-查詢 」 選取 * from Win32_Process where name = '記事本' 」</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>WHERE STATEMENT COMPARISON OPERATORS</source>
          <target state="translated">在陳述式比較運算子</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The following operators are valid in a WQL Where statement.</source>
          <target state="translated">下列的運算子是有效的 WQL Where 陳述式中。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Operator    Description</source>
          <target state="translated">運算子描述</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>=           Equal !=          Not equal &lt;&gt;          Not equal &lt;           Less than</source>
          <target state="translated">= 相等 ！ = 不等於 &lt;&gt; 不等於 &lt; 小於</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>&lt;=          Less than or equal =          Greater than or equal LIKE        Wildcard match IS          Evaluates null ISNOT       Evaluates not null ISA         Evaluates a member of a WMI class</source>
          <target state="translated">&lt; = 小於或等於 = 大於或等於像萬用字元比對是評估為 null ISNOT 評估非 null ISA 評估 WMI 類別的成員</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>There are other operators, but these are the ones used for making comparisons.</source>
          <target state="translated">其他運算子，但這些是用來進行比較。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>For example, the following query selects the Name and Priority properties from processes in the Win32_Process class where the process priority is greater than or equal to 11.</source>
          <target state="translated">例如，下列查詢會選取名稱和優先權屬性從處理序優先權大於或等於 11 所在 Win32_Process 類別中的程序。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>The Get-WmiObject cmdlet runs the query.</source>
          <target state="translated">Get-wmiobject cmdlet 執行查詢。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>$highPriority = "Select Name, Priority from Win32_Process where Priority &gt;= 11" Get-WmiObject -Query $highPriority</source>
          <target state="translated">$highPriority ="選取名稱，從 Win32_Process 的優先權，優先權 &gt; = 11"Get-wmiobject-查詢 $highPriority</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>USING THE WQL OPERATORS IN THE FILTER PARAMETER</source>
          <target state="translated">在篩選參數中使用 WQL 運算子</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The WQL operators can also be used in the value of the Filter parameter of the Get-WmiObject or Get-CimInstance cmdlets, as well as in the value of the Query parameters of these cmdlets.</source>
          <target state="translated">WQL 操作員也可用在參數的值篩選 Get-wmiobject 或 Get-ciminstance 指令程式，以及這些 cmdlet 的查詢參數的值。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>For example, the following command gets the Name and ProcessID properties of the last five processes that have ProcessID values greater than 1004.</source>
          <target state="translated">例如，下列命令會取得具有大於 1004 ProcessID 值的最後五個處理程序的名稱和 ProcessID 屬性。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The command uses the Filter parameter to specify the ProcessID condition.</source>
          <target state="translated">命令會使用篩選參數來指定 ProcessID 條件。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-WmiObject -Class Win32_Process ` -Property Name, ProcessID -Filter "ProcessID &gt;= 1004" | Sort ProcessID | Select Name, ProcessID -Last 5</source>
          <target state="translated">PS C: &gt; Get-wmiobject-類別 Win32_Process' 的屬性名稱、 ProcessID-篩選"ProcessID &gt; = 1004年"|排序 ProcessID |選取名稱，ProcessID-最後 5</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Name                                 ProcessID</source>
          <target state="translated">名稱 ProcessID</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>SROSVC.exe                                4220</source>
          <target state="translated">SROSVC.exe 4220</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>WINWORD.EXE                               4664</source>
          <target state="translated">產生。EXE                               4664</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>TscHelp.exe                               4744 SnagIt32.exe                              4748 WmiPrvSE.exe                              5056</source>
          <target state="translated">TscHelp.exe 4744 SnagIt32.exe 4748 WmiPrvSE.exe 5056</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>USING THE LIKE OPERATOR</source>
          <target state="translated">使用 LIKE 運算子</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The Like operator lets you use wildcard characters to filter the results of a WQL query.</source>
          <target state="translated">Like 運算子可讓您使用萬用字元來篩選的 WQL 查詢的結果。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Like Operator  Description</source>
          <target state="translated">像運算子描述</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>[]             Character in a range [a-f] or a set of characters [abcdef].</source>
          <target state="translated">[在範圍 [a-f] 或一組字元 [abcdef] 中的字元]。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The items in a set do not need to be consecutive or listed in alphabetical order.</source>
          <target state="translated">集合中的項目不需要是連續或依照字母順序列出。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>^              Character not in a range [^a-f] or not in a set [^abcdef].</source>
          <target state="translated">^ 字元範圍中找不到 [^ a-f] 或 [不在集合中 [^ abcdef]。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The items in a set do not need to be consecutive or listed in alphabetical order.</source>
          <target state="translated">集合中的項目不需要是連續或依照字母順序列出。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>%              A string of zero or more characters</source>
          <target state="translated">%零或多個字元的字串</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>              One character. (underscore)    NOTE: To use a literal underscore in a query string, enclose it in square brackets [<ept id="p1">_</ept>].</source>
          <target state="translated"><bpt id="p1">_</bpt>              一個字元。（底線）   注意︰ 若要在查詢字串中使用常值的底線，將它括在方括號 [<ept id="p1">_</ept>]。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>When the Like operator is used without any wildcard characters or range operators, it behaves like the equality operator (=) and returns objects only when they are an exact match for the pattern.</source>
          <target state="translated">使用 Like 運算子時，沒有任何萬用字元或範圍運算子，其行為都像是等號比較運算子 （=），而且它們是完全符合的模式比對時，只會傳回物件。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>You can combine the range operation with the percent wildcard character to create simple, yet powerful filters.</source>
          <target state="translated">您可以結合的百分比萬用字元，來建立簡單，但功能強大的篩選器的範圍作業。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>LIKE OPERATOR EXAMPLES</source>
          <target state="translated">像運算子範例</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>EXAMPLE 1: [<ph id="ph1">&lt;range&gt;</ph>] The following commands start Notepad and then search for an instance of the Win32_Process class that has a name that starts with a letter between "H" and "N" (case-insensitive).</source>
          <target state="translated">範例 1: [<ph id="ph1">&lt;range&gt;</ph>] 的下列命令啟動 [記事本]，然後搜尋具有開頭為字母 a"H"和"N"（區分大小寫） 之間的名稱 Win32_Process 類別的執行個體。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The query should return any process from Hotpad.exe through Notepad.exe.</source>
          <target state="translated">此查詢應該傳回 Hotpad.exe Notepad.exe 透過任何處理程序。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Notepad   # Starts Notepad PS C:&gt; $query = "Select * from win32_Process where Name LIKE '[H-N]otepad.exe'" PS C:&gt; Get-WmiObject -Query $query | Select Name, ProcessID</source>
          <target state="translated">PS C: &gt; 記事本 # 啟動 [記事本] PS $query c: &gt; ="選取 * from win32_Process 名稱，例如 '[H N] otepad.exe' 「 PS &gt; Get-wmiobject-查詢 $query |選取名稱，ProcessID</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>Name                                ProcessID</source>
          <target state="translated">名稱 ProcessID</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>notepad.exe                              1740</source>
          <target state="translated">notepad.exe 1740</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>EXAMPLE 2: [<ph id="ph1">&lt;range&gt;</ph>] and % The following commands select all process that have a name that begins with a letter between A and P (case-insensitive) followed by zero or more letters in any combination.</source>
          <target state="translated">範例 2: [<ph id="ph1">&lt;range&gt;</ph>] %下列命令會選取所有處理程序之間以字母開頭的名稱 A 和 P （不區分大小寫） 後面接著零個或多個字母的任意組合。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The Get-WmiObject cmdlet runs the query, the Select-Object cmdlet gets the Name and ProcessID properties, and the Sort-Object cmdlet sorts the results in alphabetical order by name.</source>
          <target state="translated">Get-wmiobject cmdlet 執行查詢、 Select-object 指令程式取得的名稱和 ProcessID 屬性，以及 Sort-object cmdlet 會依名稱排序的結果依字母順序。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$query = "Select * from win32_Process where name LIKE '[A-P]%'" PS C:&gt;Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID | Sort-Object -Property Name</source>
          <target state="translated">PS C: &gt; $query ="選取 * from win32_Process LIKE '[A P] %'，名稱"PS &gt; Get-wmiobject-查詢 $query |選取物件的屬性名稱、 ProcessID |排序物件的屬性名稱</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>EXAMPLE 3: Not in Range (^) The following command gets processes whose names do not begin with any of the following letters:</source>
          <target state="translated">範例 3︰ 不在範圍 (^) 下列命令會取得其名稱開頭不是任何下列字母的處理程序︰</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>A, S, W, P, R, C, U, N</source>
          <target state="translated">A、 S、 W、 P、 R、 C、 U、 N</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>and followed zero or more letters.</source>
          <target state="translated">且後面接著零個或多個字母。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$query = "Select * from win32_Process where name LIKE '[^ASWPRCUN]%'" PS C:&gt;Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID | Sort-Object -Property Name</source>
          <target state="translated">PS C: &gt; $query ="選取 * from win32_Process 名稱，例如 ' [^ ASWPRCUN] %' 「 PS &gt; Get-wmiobject-查詢 $query |選取物件的屬性名稱、 ProcessID |排序物件的屬性名稱</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>EXAMPLE 4: Any characters -- or none (%) The following commands get processes that have names that begin with "calc".</source>
          <target state="translated">範例 4:-的任何字元或無 （%）下列命令會取得名稱以"calc"開頭的處理程序。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The % symbol in WQL is equivalent to the asterisk (*) symbol in regular expressions.</source>
          <target state="translated">WQL %符號就等於規則運算式中的星號 （*） 符號。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $query = "Select * from win32_Process where Name LIKE 'calc%'" PS C:&gt; Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID</source>
          <target state="translated">PS $query c: &gt; ="選取 * from win32_Process where Name LIKE 'calc %' 「 PS &gt; Get-wmiobject-查詢 $query |選取物件的屬性名稱、 ProcessID</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Name                               ProcessID</source>
          <target state="translated">名稱 ProcessID</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>calc.exe                                4424</source>
          <target state="translated">calc.exe 4424</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>EXAMPLE 5: One character (_) The following commands get processes that have names that have the following pattern, "c_lc.exe" where the underscore character represents any one character.</source>
          <target state="translated">範例 5︰ 一個字元 (_) 的下列命令取得處理程序有下列模式中，「 c_lc.exe 」 底線字元，表示任何單一字元的名稱。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>This pattern matches any name from calc.exe through czlc.exe, or c9lc.exe, but does not match names in which the "c" and "l" are separated by more than one character.</source>
          <target state="translated">這種模式比對 calc.exe 透過 czlc.exe 或 c9lc.exe，從任何名稱，但不是符合"c"和"l"以多個字元所分隔的名稱。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $query = "Select * from Win32_Process where Name LIKE 'c_lc.exe'" PS C:&gt; Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID</source>
          <target state="translated">PS $query c: &gt; = 」 選取 * from Win32_Process where Name 'c_lc.exe' 像 「 PS &gt; Get-wmiobject-查詢 $query |選取物件的屬性名稱、 ProcessID</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Name                                 ProcessID</source>
          <target state="translated">名稱 ProcessID</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>calc.exe                                  4424</source>
          <target state="translated">calc.exe 4424</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>EXAMPLE 6: Exact match The following commands get processes named WLIDSVC.exe.</source>
          <target state="translated">範例 6︰ 完全相符，下列命令取得處理程序命名為 WLIDSVC.exe。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Even though the query uses the Like keyword, it requires an exact match, because the value does not include any wildcard characters.</source>
          <target state="translated">即使此查詢使用 Like 關鍵字，它需要完全相符，因為值不包含任何萬用字元。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>$query = "Select * from win32_Process where name LIKE 'WLIDSVC.exe'" Get-WmiObject -Query $query | Select-Object -Property Name, ProcessID</source>
          <target state="translated">$query ="選取 * from win32_Process 位置命名為 'WLIDSVC.exe' 像 「 Get-wmiobject-查詢 $query |選取物件的屬性名稱、 ProcessID</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Name                                 ProcessID</source>
          <target state="translated">名稱 ProcessID</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>WLIDSVC.exe                                84</source>
          <target state="translated">WLIDSVC.exe 84</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>USING THE OR OPERATOR</source>
          <target state="translated">使用 OR 運算子</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>To specify multiple independent conditions, use the Or keyword.</source>
          <target state="translated">若要指定多個獨立的條件，請使用 Or 關鍵字。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The Or keyword appears in the Where clause.</source>
          <target state="translated">Or 關鍵字會出現在 Where 子句。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>It performs an inclusive OR operation on two (or more) conditions and returns items that meet any of the conditions.</source>
          <target state="translated">它會執行兩個 （含） 以上的條件包含 OR 運算，並傳回符合條件的項目。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The Or operator has the following format:</source>
          <target state="translated">Or 運算子具有下列格式︰</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> or <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</source>
          <target state="translated">Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> or <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>For example, the following commands get all instances of the Win32_Process WMI class but returns them only if the process name is winword.exe or excel.exe.</source>
          <target state="translated">例如，下列命令取得 Win32_Process WMI 類別的所有執行個體，但只會傳回它們的處理序名稱是 winword.exe 或 excel.exe。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_Process where Name = 'winword.exe' or Name = 'excel.exe'" PS C:&gt;Get-WmiObject -Query $q</source>
          <target state="translated">PS C: &gt; $q ="選取 * from Win32_Process where Name = 'winword.exe' 或名稱 = 'excel.exe' 「 PS &gt; Get-wmiobject-查詢 $q</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>The Or statement can be used with more than two conditions.</source>
          <target state="translated">Or 陳述式可以搭配兩個以上的條件。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>In the following query, the Or statement gets Winword.exe, Excel.exe, or Powershell.exe.</source>
          <target state="translated">在下列查詢中，Or 陳述式會取得 Winword.exe、 Excel.exe 或 Powershell.exe。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>$q = "Select * from Win32_Process where Name = 'winword.exe' or Name = 'excel.exe' or Name = 'powershell.exe'"</source>
          <target state="translated">$q ="選取 * from Win32_Process where Name = 'winword.exe' 或名稱 = 'excel.exe' 或名稱 = 'powershell.exe' 」</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>USING THE AND OPERATOR</source>
          <target state="translated">使用 AND 運算子</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>To specify multiple related conditions, use the And keyword.</source>
          <target state="translated">若要指定多個相關的條件，請使用 And 關鍵字。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>The And keyword appears in the Where clause.</source>
          <target state="translated">與關鍵字出現在 Where 子句。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>It returns items that meet all of the conditions.</source>
          <target state="translated">它會傳回符合所有條件的項目。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>The And operator has the following format:</source>
          <target state="translated">And 運算子具有下列格式︰</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> and <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</source>
          <target state="translated">Where <ph id="ph1">&lt;property&gt;</ph> <ph id="ph2">&lt;operator&gt;</ph> <ph id="ph3">&lt;value&gt;</ph> and <ph id="ph4">&lt;property&gt;</ph> <ph id="ph5">&lt;operator&gt;</ph> <ph id="ph6">&lt;value&gt;</ph> ...</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>For example, the following commands get processes that have a name of "Winword.exe" and the process ID of 6512.</source>
          <target state="translated">例如，下列命令取得處理程序的名稱 「 Winword.exe 」 和 6512 的處理序識別碼。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Note that the commands use the Get-CimInstance cmdlet.</source>
          <target state="translated">請注意，命令會使用 Get-ciminstance 指令程式。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_Process where Name = 'winword.exe' and ProcessID =6512" PS C:&gt; Get-CimInstance -Query $q</source>
          <target state="translated">PS C: &gt; $q ="選取 * from Win32_Process where Name = 'winword.exe' 和 ProcessID = 6512"PS &gt; Get-ciminstance-查詢 $q</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>ProcessId        Name             HandleCount      WorkingSetSize   VirtualSize</source>
          <target state="translated">ProcessId 名稱 HandleCount WorkingSetSize VirtualSize</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>6512             WINWORD.EXE      768              117170176        633028608</source>
          <target state="translated">6512 WINWORD。EXE 768 117170176 633028608</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>All operators, including the Like operators are valid with the Or and And operators.</source>
          <target state="translated">所有的運算子，包括 Like 運算子是有效的 Or 和運算子。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>And, you can combine the Or and And operators in a single query with parentheses that tell Windows PowerShell which clauses to process first.</source>
          <target state="translated">而且，您可以結合 Or 和括號括住的單一查詢中的運算子會告知 Windows PowerShell 先處理的子句。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>This command uses the Windows PowerShell continuation character (`) divide the command into two lines.</source>
          <target state="translated">此命令會使用 Windows PowerShell 接續字元 （'） 除以命令分成兩行。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_Process ` where (Name = 'winword.exe' or Name = 'excel.exe') and HandleCount &gt; 700"</source>
          <target state="translated">PS $q c: &gt; ="選取 * 從 Win32_Process' where (名稱 = 'winword.exe' 或名稱 = 'excel.exe') 和 HandleCount &gt; 700 」</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>PS C:&gt; Get-CimInstance -Query $q ProcessId        Name             HandleCount      WorkingSetSize   VirtualSize</source>
          <target state="translated">PS C: &gt; Get-ciminstance-查詢 $q ProcessId 名稱 HandleCount WorkingSetSize VirtualSize</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>6512             WINWORD.EXE      797              117268480        634425344</source>
          <target state="translated">6512 WINWORD。EXE 797 117268480 634425344</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>9610             EXCEL.EXE        727               38858752        323227648</source>
          <target state="translated">9610 EXCEL。EXE 727 38858752 323227648</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>SEARCHING FOR NULL VALUES</source>
          <target state="translated">搜尋的 NULL 值</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>Searching for null values in WMI is challenging, because it can lead to unpredictable results.</source>
          <target state="translated">在 WMI 中的 null 值搜尋具挑戰性，因為它可能造成無法預期的結果。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>Null is not zero and it is not equivalent or to an empty string.</source>
          <target state="translated">Null 不是零，而且不相等，或為空字串。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Some WMI class properties are initialized and others are not, so a search for null might not work for all properties.</source>
          <target state="translated">有些 WMI 類別屬性會初始化與其他人則不會，因此搜尋 null 可能不適用於所有的屬性。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>To search for null values, use the Is operator with a value of "null".</source>
          <target state="translated">若要搜尋 null 值，請使用"null"值的運算子。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For example, the following commands get processes that have a null value for the IntallDate property.</source>
          <target state="translated">例如，下列命令會取得具有 IntallDate 屬性的 null 值的處理序。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The commands return many processes.</source>
          <target state="translated">命令會傳回許多處理序。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_Process where InstallDate is null" PS C:&gt;Get-WmiObject -Query $q</source>
          <target state="translated">PS C: &gt; $q ="選取 * 從安裝日期所在 null Win32_Process"PS &gt; Get-wmiobject-查詢 $q</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>In contrast, the following command, gets user accounts that have a null value for the Description property.</source>
          <target state="translated">相反地，下列命令，取得具有 null 值描述屬性的使用者帳戶。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>This command does not return any user accounts, even though most user accounts do not have any value for the Description property.</source>
          <target state="translated">此命令不會傳回任何使用者帳戶，雖然大部分的使用者帳戶並沒有任何描述屬性的值。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_UserAccount where Description is null" PS C:&gt;Get-WmiObject -Query $q</source>
          <target state="translated">PS C: &gt; $q ="選取 * 從其中描述為 null 的 Win32_UserAccount"PS &gt; Get-wmiobject-查詢 $q</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>To find the user accounts that have no value for the Description property, use the equality operator to get an empty string.</source>
          <target state="translated">沒有值的描述屬性的使用者帳戶，請使用等號比較運算子來取得空的字串。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>To represent the empty string, use two consecutive single quotation marks.</source>
          <target state="translated">若要表示空字串，使用兩個連續單引號。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>$q = "Select * from Win32_UserAccount where Description = '' "</source>
          <target state="translated">$q ="選取 * 從 Win32_UserAccount 其中描述 = ' 」</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>USING TRUE OR FALSE</source>
          <target state="translated">使用 TRUE 或 FALSE</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>To get Boolean values in the properties of WMI objects, use True and False.</source>
          <target state="translated">若要取得 WMI 物件的內容中的布林值，請使用 True 和 False。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>They are not case sensitive.</source>
          <target state="translated">它們不是區分大小寫。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>The following WQL query returns only local user accounts from a domain joined computer.</source>
          <target state="translated">下列的 WQL 查詢會傳回從已加入網域的電腦只有本機使用者帳戶。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_UserAccount where LocalAccount = True" PS C:&gt;Get-CimInstance -Query $q</source>
          <target state="translated">PS C: &gt; $q ="選取 * 從 Win32_UserAccount 其中 LocalAccount = True"PS &gt; Get-ciminstance-查詢 $q</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>To find domain accounts, use a value of False, as shown in the following example.</source>
          <target state="translated">網域帳戶，請使用值為 False，如下列範例所示。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>PS C:&gt;$q = "Select * from Win32_UserAccount where LocalAccount = False" PS C:&gt;Get-CimInstance -Query $q</source>
          <target state="translated">PS C: &gt; $q ="選取 * 從 Win32_UserAccount 其中 LocalAccount = False"PS &gt; Get-ciminstance-查詢 $q</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>USING THE ESCAPE CHARACTER</source>
          <target state="translated">使用逸出字元</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>WQL uses the backslash () as its escape character.</source>
          <target state="translated">WQL 使用反斜線 （） 做為其逸出字元。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>This is different from Windows PowerShell, which uses the backtick character (`).</source>
          <target state="translated">這是從 Windows PowerShell，使用倒單引號字元 （'） 不同。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Quotation marks, and the characters used for quotation marks, often need to be escaped so that they are not misinterpreted.</source>
          <target state="translated">引號，並使用引號括起來的字元通常需要逸出，讓它們不會被誤解。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>To find a user whose name includes a single quotation mark, use a backslash to escape the single quotation mark, as shown in the following command.</source>
          <target state="translated">使用者名稱中包括一個單引號，請使用反斜線逸出單引號，下列命令中所示。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_UserAccount where Name = 'Tim O<ph id="ph1">\'</ph>Brian'" PS C:&gt; Get-CimInstance -Query $q Name             Caption          AccountType      SID              Domain</source>
          <target state="translated">PS $q c: &gt; ="選取 * 從 Win32_UserAccount where Name = ' Tim O<ph id="ph1">\'</ph>Brian' 「 PS &gt; Get-ciminstance-查詢 $q 名稱標題 AccountType SID 網域</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Tim O'Brian      FABRIKAM\TimO    512              S-1-5-21-1457... FABRIKAM</source>
          <target state="translated">Tim O'Brian FABRIKAM\TimO 512 S-1-5-21-1457...FABRIKAM</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>In some case, the backslash also needs to be escaped.</source>
          <target state="translated">在某些情況下，反斜線也需要逸出。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>For example, the following commands generate an Invalid Query error due to the backslash in the Caption value.</source>
          <target state="translated">例如，下列命令會產生無效的查詢錯誤，因為有反斜線標題值中。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_UserAccount where Caption = 'Fabrikam\TimO'" PS C:&gt; Get-CimInstance -Query $q Get-CimInstance : Invalid query At line:1 char:1</source>
          <target state="translated">PS $q c: &gt; ="選取 * 從 Win32_UserAccount 其中標題 = 'Fabrikam\TimO' 」 PS &gt; Get-ciminstance-查詢 $q Get-ciminstance︰ 無效的查詢，行︰ 1 char: 1</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>Get-CimInstance -Query $q</source>
          <target state="translated">Get-ciminstance-查詢 $q</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>+!INCLUDE[]~~~~~~~~~~~</source>
          <target state="translated">+!包含 [] ~ ~ ~</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>CategoryInfo          : InvalidArgument: (:) [Get-CimInstance], CimException</source>
          <target state="translated">CategoryInfo: InvalidArgument: （:）[Get-ciminstance]，CimException</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>FullyQualifiedErrorId : HRESULT 0x80041017,Microsoft.Management.Infrastructure.CimCmdlets</source>
          <target state="translated">FullyQualifiedErrorId: HRESULT 0x80041017,Microsoft.Management.Infrastructure.CimCmdlets</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>To escape the backslash, use a second backslash character, as shown in the following command.</source>
          <target state="translated">要逸出反斜線，使用第二個反斜線字元，如下列命令中所示。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>PS C:&gt; $q = "Select * from Win32_UserAccount where Caption = 'Fabrikam\TimO'" PS C:&gt; Get-CimInstance -Query $q</source>
          <target state="translated">PS $q c: &gt; ="選取 * 從 Win32_UserAccount 其中標題 = 'Fabrikam\TimO' 「 PS &gt; Get-ciminstance-查詢 $q</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>SEE ALSO</source>
          <target state="translated">另請參閱</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>about_Escape_Characters about_Quoting_Rules about_WMI about_WMI_Cmdlets</source>
          <target state="translated">about_Escape_Characters about_Quoting_Rules about_WMI about_WMI_Cmdlets</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>