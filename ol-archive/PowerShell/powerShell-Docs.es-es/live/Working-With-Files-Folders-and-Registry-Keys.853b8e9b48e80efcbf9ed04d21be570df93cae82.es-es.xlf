<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-4fb33c9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3e1bf444d7657b66422dab3eb8dbeef5e4d581b4</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Working-With-Files-Folders-and-Registry-Keys.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d1cdc25f9dcf6b772d4d68a88bd6e09bddd766bb</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Working With Files Folders and Registry Keys</source>
          <target state="translated">Trabajar con archivos, carpetas y claves del Registro</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Working With Files, Folders and Registry Keys</source>
          <target state="translated">Trabajar con archivos, carpetas y claves del Registro</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Windows PowerShell uses the noun <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> to refer to items found on a Windows PowerShell drive.</source>
          <target state="translated">En Windows PowerShell se usa el término <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> para hacer referencia a los elementos contenidos en una unidad de Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>When dealing with the Windows PowerShell FileSystem provider, an <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> might be a file, a folder, or the Windows PowerShell drive.</source>
          <target state="translated">Cuando se trabaja con el proveedor FileSystem de Windows PowerShell, un <bpt id="p1">**</bpt>Item<ept id="p1">**</ept> puede ser un archivo, una carpeta o la unidad de Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Listing and working with these items is a critical basic task in most administrative settings, so we want to discuss these tasks in detail.</source>
          <target state="translated">Enumerar estos elementos y trabajar con ellos son tareas críticas básicas en la mayoría de las configuraciones administrativas, de modo que conviene abordar estas tareas en profundidad.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Enumerating Files, Folders, and Registry Keys (Get-ChildItem)</source>
          <target state="translated">Enumerar archivos, carpetas y claves del Registro (Get-ChildItem)</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Since getting a collection of items from a particular location is such a common task, the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet is designed specifically to return all items found within a container such as a folder.</source>
          <target state="translated">Hacerse con una colección de elementos de una ubicación determinada es una tarea extremadamente común, por lo que el cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> está diseñado específicamente para devolver todos los elementos dentro de un contenedor, como, por ejemplo, una carpeta.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If you want to return all files and folders that are contained directly within the folder C:<ph id="ph1">\\</ph>Windows, type:</source>
          <target state="translated">Si desea que se devuelvan todos los archivos y carpetas contenidos directamente dentro de la carpeta C:<ph id="ph1">\\</ph>Windows, escriba:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The listing looks similar to what you would see when you enter the <bpt id="p1">**</bpt>dir<ept id="p1">**</ept> command in <bpt id="p2">**</bpt>Cmd.exe<ept id="p2">**</ept>, or the <bpt id="p3">**</bpt>ls<ept id="p3">**</ept> command in a UNIX command shell.</source>
          <target state="translated">La lista es similar a lo que se obtendría si se especificara el comando <bpt id="p1">**</bpt>dir<ept id="p1">**</ept> en <bpt id="p2">**</bpt>Cmd.exe<ept id="p2">**</ept> o el comando <bpt id="p3">**</bpt>ls<ept id="p3">**</ept> en un shell de comandos de UNIX.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You can perform very complex listings by using parameters of the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet.</source>
          <target state="translated">Si se usan los parámetros del cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept>, se pueden confeccionar listas de enorme complejidad.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>We will look at a few scenarios next.</source>
          <target state="translated">Pasemos a ver algunos escenarios sobre esto.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can see the syntax the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet by typing:</source>
          <target state="translated">La sintaxis del cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> se puede ver escribiendo lo siguiente:</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>These parameters can be mixed and matched to get highly customized output.</source>
          <target state="translated">Estos parámetros se pueden mezclar y relacionar para obtener resultados muy personalizados.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Listing all Contained Items (-Recurse)</source>
          <target state="translated">Enumerar todos los elementos contenidos (-Recurse)</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>To see both the items inside a Windows folder and any items that are contained within the subfolders, use the <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</source>
          <target state="translated">Para ver tanto los elementos que hay dentro de una carpeta de Windows como cualquier elemento dentro de sus subcarpetas, use el parámetro <bpt id="p1">**</bpt>Recurse<ept id="p1">**</ept> de <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The listing displays everything within the Windows folder and the items in its subfolders.</source>
          <target state="translated">La lista muestra todos los elementos dentro de la carpeta de Windows y los elementos de sus subcarpetas.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Filtering Items by Name (-Name)</source>
          <target state="translated">Filtrar elementos por su nombre (-Name)</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To display only the names of items, use the <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get-Childitem<ept id="p2">**</ept>:</source>
          <target state="translated">Para mostrar solo los nombres de los elementos, use el parámetro <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> de <bpt id="p2">**</bpt>Get-Childitem<ept id="p2">**</ept>:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Forcibly Listing Hidden Items (-Force)</source>
          <target state="translated">Enumerar forzosamente los elementos ocultos (-Force)</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Items that are normally invisible in File Explorer or Cmd.exe are not displayed in the output of a <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> command.</source>
          <target state="translated">Los elementos que normalmente son invisibles en el Explorador de archivos o en Cmd.exe no aparecen en la salida de un comando <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>To display hidden items, use the <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> parameter of <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</source>
          <target state="translated">Para ver los elementos ocultos, use el parámetro <bpt id="p1">**</bpt>Force<ept id="p1">**</ept> de <bpt id="p2">**</bpt>Get-ChildItem<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This parameter is named Force because you can forcibly override the normal behavior of the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> command.</source>
          <target state="translated">Este parámetro se llama Force porque permite anular a la fuerza el comportamiento normal del comando <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Force is a widely used parameter that forces an action that a cmdlet would not normally perform, although it will not perform any action that compromises the security of the system.</source>
          <target state="translated">Force es un parámetro muy usado que fuerza una acción que un cmdlet normalmente no realizaría, si bien no llevará a cabo ninguna acción que ponga en peligro la seguridad del sistema.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Matching Item Names with Wildcards</source>
          <target state="translated">Buscar nombres de elemento coincidentes con caracteres comodín</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>The Get-ChildItem<ept id="p1">**</ept> command accepts wildcards in the path of the items to list.</source>
          <target state="translated"><bpt id="p1">**</bpt>El comando Get-ChildItem<ept id="p1">**</ept> acepta caracteres comodín en la ruta de acceso de los elementos que se van a enumerar.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Because wildcard matching is handled by the Windows PowerShell engine, all cmdlets that accepts wildcards use the same notation and have the same matching behavior.</source>
          <target state="translated">Dado que las coincidencias con caracteres comodín se controla mediante el motor de Windows PowerShell, todos los cmdlets que acepten caracteres comodín usan la misma notación y tienen el mismo comportamiento de búsqueda de coincidencias.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The Windows PowerShell wildcard notation includes:</source>
          <target state="translated">La notación de caracteres comodín de Windows PowerShell conlleva las siguientes reglas:</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Asterisk (<ph id="ph1">\*</ph>)matches zero or more occurrences of any character.</source>
          <target state="translated">El asterisco (<ph id="ph1">\*</ph>) coincide con cero o más repeticiones de cualquier carácter.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Question mark (?) matches exactly one character.</source>
          <target state="translated">El signo de interrogación de cierre (?) coincide exactamente con un carácter.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Left bracket (<ph id="ph1">\[</ph>) character and right bracket (]) character surround a set of characters to be matched.</source>
          <target state="translated">Los caracteres de corchete de apertura (<ph id="ph1">\[</ph>) y corchete de cierre (]) rodean un juego de caracteres que debe coincidir.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Here are some examples of how wildcard specification works.</source>
          <target state="translated">A continuación presentamos algunos ejemplos de cómo funciona la especificación de caracteres comodín.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>To find all files in the Windows directory with the suffix <bpt id="p1">**</bpt>.log<ept id="p1">**</ept> and exactly five characters in the base name, enter the following command:</source>
          <target state="translated">Escriba el siguiente comando para encontrar todos los archivos en el directorio de Windows con el sufijo <bpt id="p1">**</bpt>.log<ept id="p1">**</ept> y exactamente cinco caracteres en el nombre base:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To find all files that begin with the letter <bpt id="p1">**</bpt>x<ept id="p1">**</ept> in the Windows directory, type:</source>
          <target state="translated">Escriba lo siguiente para encontrar todos los archivos que comienzan por la letra <bpt id="p1">**</bpt>x<ept id="p1">**</ept> en el directorio de Windows:</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>To find all files whose names begin with <bpt id="p1">**</bpt>x<ept id="p1">**</ept> or <bpt id="p2">**</bpt>z<ept id="p2">**</ept>, type:</source>
          <target state="translated">Escriba lo siguiente para encontrar todos los archivos cuyos nombres comiencen por <bpt id="p1">**</bpt>x<ept id="p1">**</ept> o <bpt id="p2">**</bpt>z<ept id="p2">**</ept>:</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Excluding Items (-Exclude)</source>
          <target state="translated">Excluir elementos (-Exclude)</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You can exclude specific items by using the <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> parameter of Get-ChildItem.</source>
          <target state="translated">Puede excluir elementos concretos con el parámetro <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> de Get-ChildItem.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>This lets you perform complex filtering in a single statement.</source>
          <target state="translated">Esto le permite realizar filtrados complejos en una sola instrucción.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, suppose you are trying to find the Windows Time Service DLL in the System32 folder, and all you can remember about the DLL name is that it begins with "W" and has "32" in it.</source>
          <target state="translated">Por ejemplo, imaginemos que estamos buscando el archivo DLL del Servicio de hora de Windows en la carpeta System32, y todo lo que recuerda del nombre del archivo DLL es que comienza por "W" y contiene "32".</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>An expression like <bpt id="p1">**</bpt>w<ph id="ph1">\&amp;</ph>#42;32<ph id="ph2">\&amp;</ph>#42;.dll<ept id="p1">**</ept> will find all DLLs that satisfy the conditions, but it may also return the Windows 95 and 16-bit Windows compatibility DLLs that include "95" or "16" in their names.</source>
          <target state="translated">Con una expresión como <bpt id="p1">**</bpt>w<ph id="ph1">\&amp;</ph>#42;32<ph id="ph2">\&amp;</ph>#42;.dll<ept id="p1">**</ept>, se detectarán todos los archivos DLL que cumplan las condiciones, pero también se pueden devolver los archivos DLL de compatibilidad de Windows 95 y Windows de 16 bits que incluyan "95" o "16" en sus nombres.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can omit files that have any of these numbers in their names by using the <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> parameter with the pattern <bpt id="p2">**</bpt><ph id="ph1">\&amp;</ph>#42;<ph id="ph2">\[</ph>9516]<ph id="ph3">\&amp;</ph>#42;<ept id="p2">**</ept>:</source>
          <target state="translated">Puede omitir todos los archivos que contengan cualquiera de estos números en sus nombres, para lo que debe usar el parámetro <bpt id="p1">**</bpt>Exclude<ept id="p1">**</ept> con el patrón <bpt id="p2">**</bpt><ph id="ph1">\&amp;</ph>#42;<ph id="ph2">\[</ph>9516]<ph id="ph3">\&amp;</ph>&amp;#42;<ept id="p2">**</ept>:</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>PS&gt; Get-ChildItem -Path C:\WINDOWS\System32\w<bpt id="p1">*</bpt>32<ept id="p1">*</ept>.dll -Exclude <bpt id="p2">*</bpt>[9516]<ept id="p2">*</ept> Directory: Microsoft.PowerShell.Core\FileSystem::C:\WINDOWS\System32 Mode                LastWriteTime     Length Name ----                -------------     ------ ---- -a---        2004-08-04   8:00 AM     174592 w32time.dll -a---        2004-08-04   8:00 AM      22016 w32topl.dll -a---        2004-08-04   8:00 AM     101888 win32spl.dll -a---        2004-08-04   8:00 AM     172032 wldap32.dll -a---        2004-08-04   8:00 AM     264192 wow32.dll -a---        2004-08-04   8:00 AM      82944 ws2_32.dll -a---        2004-08-04   8:00 AM      42496 wsnmp32.dll -a---        2004-08-04   8:00 AM      22528 wsock32.dll -a---        2004-08-04   8:00 AM      18432 wtsapi32.dll</source>
          <target state="translated">PS&gt; Get-ChildItem -Path C:\WINDOWS\System32\w<bpt id="p1">*</bpt>32<ept id="p1">*</ept>.dll -Exclude <bpt id="p2">*</bpt>[9516]<ept id="p2">*</ept> Directory: Microsoft.PowerShell.Core\FileSystem::C:\WINDOWS\System32 Mode                LastWriteTime     Length Name ----                -------------     ------ ---- -a---        2004-08-04   8:00 AM     174592 w32time.dll -a---        2004-08-04   8:00 AM      22016 w32topl.dll -a---        2004-08-04   8:00 AM     101888 win32spl.dll -a---        2004-08-04   8:00 AM     172032 wldap32.dll -a---        2004-08-04   8:00 AM     264192 wow32.dll -a---        2004-08-04   8:00 AM      82944 ws2_32.dll -a---        2004-08-04   8:00 AM      42496 wsnmp32.dll -a---        2004-08-04   8:00 AM      22528 wsock32.dll -a---        2004-08-04   8:00 AM      18432 wtsapi32.dll</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Mixing Get-ChildItem Parameters</source>
          <target state="translated">Mezclar parámetros de Get-ChildItem</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>You can use several of the parameters of the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet in the same command.</source>
          <target state="translated">Se pueden usar varios de los parámetros del cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> en el mismo comando.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Before you mix parameters, be sure that you understand wildcard matching.</source>
          <target state="translated">Antes de mezclar parámetros, asegúrese de que comprende el concepto de búsqueda de coincidencias con caracteres comodín.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For example, the following command returns no results:</source>
          <target state="translated">Por ejemplo, el siguiente comando no devuelve ningún resultado:</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>There are no results, even though there are two DLLs that begin with the letter "z" in the Windows folder.</source>
          <target state="translated">No hay ningún resultado, a pesar de que hay dos archivos DLL que comienzan por la letra "z" en la carpeta de Windows.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>No results were returned because we specified the wildcard as part of the path.</source>
          <target state="translated">No se devolvieron resultados porque hemos especificado el carácter comodín como parte de la ruta de acceso.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Even though the command was recursive, the <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> cmdlet restricted the items to those that are in the Windows folder with names ending with ".dll".</source>
          <target state="translated">Aunque el comando era recursivo, el cmdlet <bpt id="p1">**</bpt>Get-ChildItem<ept id="p1">**</ept> limitó los elementos a aquellos que están en la carpeta de Windows y cuyos nombres terminan en ".dll".</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>To specify a recursive search for files whose names match a special pattern, use the <bpt id="p1">**</bpt>-Include<ept id="p1">**</ept> parameter.</source>
          <target state="translated">Para especificar una búsqueda recursiva de archivos cuyos nombres coincidan con un patrón especial, use el parámetro <bpt id="p1">**</bpt>-Include<ept id="p1">**</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>