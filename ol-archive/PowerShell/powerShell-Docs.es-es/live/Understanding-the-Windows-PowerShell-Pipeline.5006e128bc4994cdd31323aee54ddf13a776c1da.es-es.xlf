<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="es-es">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-4fb33c9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d90bf940a1047b629f7b59d239aab50a78748251</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\fundamental\Understanding-the-Windows-PowerShell-Pipeline.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d3807ae2a9e602afdc13185cc04769af2ed122e7</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Understanding the Windows PowerShell Pipeline</source>
          <target state="translated">Descripción de la canalización de Windows PowerShell</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">powershell,cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Understanding the Windows PowerShell Pipeline</source>
          <target state="translated">Descripción de la canalización de Windows PowerShell</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Piping works virtually everywhere in Windows PowerShell.</source>
          <target state="translated">La canalización funciona prácticamente en cualquier lugar en Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Although you see text on the screen, Windows PowerShell does not pipe text between commands.</source>
          <target state="translated">Aunque se ve texto en la pantalla, Windows PowerShell no canaliza texto entre los comandos.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Instead, it pipes objects.</source>
          <target state="translated">En su lugar, canaliza objetos.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The notation used for pipelines is similar to that used in other shells, so at first glance, it may not be apparent that Windows PowerShell introduces something new.</source>
          <target state="translated">La notación usada para las canalizaciones es similar a la que se usa en otros shells, por lo que, a primera vista, puede que no sea evidente que Windows PowerShell presenta algo nuevo.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For example, if you use the <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> cmdlet to force a page-by-page display of output from another command, the output looks just like the normal text displayed on the screen, broken up into pages:</source>
          <target state="translated">Por ejemplo, si usa el cmdlet <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> para forzar una presentación página por página de la salida de otro comando, la salida tiene el aspecto del texto normal que se muestra en la pantalla, dividida en páginas:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The Out-Host -Paging command is a useful pipeline element whenever you have lengthy output that you would like to display slowly.</source>
          <target state="translated">El comando Out-Host -Paging es un elemento de la canalización útil siempre que tiene una salida larga que le gustaría mostrar lentamente.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>It is especially useful if the operation is very CPU-intensive.</source>
          <target state="translated">Es especialmente útil si la operación consume una gran cantidad de CPU.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Because processing is transferred to the Out-Host cmdlet when it has a complete page ready to display, cmdlets that precede it in the pipeline halt operation until the next page of output is available.</source>
          <target state="translated">Dado que el procesamiento se transfiere al cmdlet Out-Host cuando tiene una página completa lista para mostrar, los cmdlets que lo preceden en la canalización detienen la operación hasta que la siguiente página de salida esté disponible.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can see this if you use the Windows Task Manager to monitor CPU and memory use by Windows PowerShell.</source>
          <target state="translated">Puede verlo si usa el Administrador de tareas de Windows para supervisar el uso de la CPU y la memoria de Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Run the following command: <bpt id="p1">**</bpt>Get-ChildItem C:<ph id="ph1">\\</ph>Windows -Recurse<ept id="p1">**</ept>.</source>
          <target state="translated">Ejecute el siguiente comando: <bpt id="p1">**</bpt>Get-ChildItem C:<ph id="ph1">\\</ph>Windows -Recurse<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Compare the CPU and memory usage to this command: <bpt id="p1">**</bpt>Get-ChildItem C:<ph id="ph1">\\</ph>Windows -Recurse | Out-Host -Paging<ept id="p1">**</ept>.</source>
          <target state="translated">Compare el uso de la CPU y la memoria con este comando: <bpt id="p1">**</bpt>Get-ChildItem C:<ph id="ph1">\\</ph>Windows -Recurse | Out-Host -Paging<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>What you see on the screen is text, but that is because it is necessary to represent objects as text in a console window.</source>
          <target state="translated">Lo que ve en la pantalla es texto, lo que se debe a la necesidad de representar objetos como texto en una ventana de la consola.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This is just a representation of what is really going on inside Windows PowerShell.</source>
          <target state="translated">Se trata simplemente de una representación de lo que sucede realmente en Windows PowerShell.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For example, consider the Get-Location cmdlet.</source>
          <target state="translated">Por ejemplo, considere el cmdlet Get-Location.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you type <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> while your current location is the root of the C drive, you would see the following output:</source>
          <target state="translated">Si escribe <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> mientras la ubicación actual es la raíz de la unidad C, verá la siguiente salida:</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If Windows PowerShell pipelined text, issuing a command such as <bpt id="p1">**</bpt>Get-Location | Out-Host<ept id="p1">**</ept>, would pass from <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> to <bpt id="p3">**</bpt>Out-Host<ept id="p3">**</ept> a set of characters in the order they are displayed onscreen.</source>
          <target state="translated">Si Windows PowerShell canaliza texto, al emitir un comando como <bpt id="p1">**</bpt>Get-Location | Out-Host<ept id="p1">**</ept>, pasará de <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> a <bpt id="p3">**</bpt>Out-Host<ept id="p3">**</ept> un conjunto de caracteres en el orden en que se muestran en la pantalla.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In other words, if you were to ignore the heading information, <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> would first receive the character '<bpt id="p2">**</bpt>C'<ept id="p2">**</ept>, then the character '<bpt id="p3">**</bpt>:'<ept id="p3">**</ept>, then the character '<bpt id="p4">**</bpt><ph id="ph1">\\</ph>'<ept id="p4">**</ept>.</source>
          <target state="translated">En otras palabras, si fuera a ignorar la información de encabezado, <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> recibiría primero el carácter '<bpt id="p2">**</bpt>C'<ept id="p2">**</ept>, luego el carácter '<bpt id="p3">**</bpt>:'<ept id="p3">**</ept> y, finalmente, el carácter '<bpt id="p4">**</bpt><ph id="ph1">\\</ph>'<ept id="p4">**</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> cmdlet could not determine what meaning to associate with the characters output by the <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept> cmdlet.</source>
          <target state="translated">El cmdlet <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> no pudo determinar el significado que debía asociarse a los caracteres emitidos por el cmdlet <bpt id="p2">**</bpt>Get-Location<ept id="p2">**</ept>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Instead of using text to let commands in a pipeline communicate, Windows PowerShell uses objects.</source>
          <target state="translated">En lugar de utilizar texto para permitir que los comandos de una canalización se comuniquen, Windows PowerShell usa objetos.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>From the standpoint of a user, objects package related information into a form that makes it easier to manipulate the information as a unit, and extract specific items that you need.</source>
          <target state="translated">Desde el punto de vista de un usuario, los objetos empaquetan información relacionada en un formulario que facilita la manipulación de la información como una unidad y la extracción de los elementos específicos que necesita.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> command does not return text that contains the current path.</source>
          <target state="translated">El comando <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> no devuelve el texto que contenga la ruta de acceso actual.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It returns a package of information called a <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> object that contains the current path along with some other information.</source>
          <target state="translated">Devuelve un conjunto de información denominado objeto <bpt id="p1">**</bpt>PathInfo<ept id="p1">**</ept> que contiene la ruta de acceso actual junto con otra información.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> cmdlet then sends this <bpt id="p2">**</bpt>PathInfo<ept id="p2">**</ept> object to the screen, and Windows PowerShell decides what information to display and how to display it based on its formatting rules.</source>
          <target state="translated">El cmdlet <bpt id="p1">**</bpt>Out-Host<ept id="p1">**</ept> envía luego este objeto <bpt id="p2">**</bpt>PathInfo<ept id="p2">**</ept> a la pantalla y Windows PowerShell decide qué información se mostrará y cómo se mostrará en función de sus reglas de formato.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In fact, the heading information output by the <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> cmdlet is added only at the end of the process, as part of the process of formatting the data for onscreen display.</source>
          <target state="translated">De hecho, la información de encabezado generada por el cmdlet <bpt id="p1">**</bpt>Get-Location<ept id="p1">**</ept> se agrega solo al final del proceso, como parte del proceso de formato de los datos para su presentación en pantalla.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>What you see onscreen is a summary of information, and not a complete representation of the output object.</source>
          <target state="translated">Lo que ve en la pantalla es un resumen de la información y no una representación completa del objeto de salida.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Given that there may be more information output from a Windows PowerShell command than what we see displayed in the console window, how can you retrieve the non-visible elements?</source>
          <target state="translated">Dado que puede haber más información devuelta por un comando de Windows PowerShell de la que vemos en la ventana de la consola, ¿cómo podemos recuperar los elementos no visibles?</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>How do you view the extra data?</source>
          <target state="translated">¿Cómo se pueden ver los datos adicionales?</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>And what if you want to view the data in a format different than the one Windows PowerShell normally uses?</source>
          <target state="translated">¿Qué ocurre si quiere ver los datos en un formato diferente al que suele usar Windows PowerShell?</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The rest of this chapter discusses how you can discover the structure of specific Windows PowerShell objects, selecting specific items and formatting them for easier display, and how to send this information to alternative output locations such as files and printers.</source>
          <target state="translated">En lo que queda de este capítulo explicaremos cómo puede detectar la estructura de objetos específicos de Windows PowerShell, seleccionar elementos específicos y darles formato para mostrarlos más fácilmente, y cómo enviar esta información a ubicaciones de salida alternativas, como archivos e impresoras.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>