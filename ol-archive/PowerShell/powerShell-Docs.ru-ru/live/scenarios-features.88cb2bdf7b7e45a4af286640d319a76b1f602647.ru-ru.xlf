<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ru-ru">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-22243b3" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9341b7fc3feea20cc2434065c3e512d1a8dd2b54</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wmf\5.1\scenarios-features.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>New Scenarios and Features in WMF 5.1 (Preview)</source>
          <target state="translated">Новые сценарии и возможности в WMF 5.1 (предварительная версия)</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>New Scenarios and Features in WMF 5.1 (Preview)</source>
          <target state="translated">Новые сценарии и возможности в WMF 5.1 (предварительная версия)</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Note: This information is preliminary and subject to change.</source>
          <target state="translated">Примечание. Эта информация является предварительной и может быть изменена.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>PowerShell Editions</source>
          <target state="translated">Выпуски PowerShell</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Starting with version 5.1, PowerShell is available in different editions which denote varying feature sets and platform compatibility.</source>
          <target state="translated">Начиная с версии 5.1 доступны различные выпуски среды PowerShell, что означает различные наборы возможностей и совместимость с разными платформами.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Desktop Edition:<ept id="p1">**</ept> Built on .NET Framework and provides compatibility with scripts and modules targeting versions of PowerShell running on full footprint editions of Windows such as Server Core and Windows Desktop.</source>
          <target state="translated"><bpt id="p1">**</bpt>Выпуск Desktop Edition:<ept id="p1">**</ept> построен на основе .NET Framework и обеспечивает совместимость со скриптами и модулями, которые предназначены для версий PowerShell, выполняющихся в полноценных выпусках Windows, таких как Server Core и Windows Desktop.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Core Edition:<ept id="p1">**</ept> Built on .NET Core and provides compatibility with scripts and modules targeting versions of PowerShell running on reduced footprint editions of Windows such as Nano Server and Windows IoT.</source>
          <target state="translated"><bpt id="p1">**</bpt>Выпуск Core Edition:<ept id="p1">**</ept> построен на основе .NET Core и обеспечивает совместимость со скриптами и модулями, которые предназначены для версий PowerShell, выполняющихся в выпусках Windows с ограниченными возможностями, таких как Nano Server и Windows IoT.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Learn more about using PowerShell Editions</source>
          <target state="translated">Дополнительные сведения об использовании выпусков PowerShell</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Determine running edition of PowerShell</source>
          <target state="translated">Определение запущенного выпуска PowerShell</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Declare a module's compatibility to specific PowerShell versions</source>
          <target state="translated">Объявление совместимости модуля с определенными версиями PowerShell</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Filter Get-Module results by CompatiblePSEditions</source>
          <target state="translated">Фильтрация результатов командлета Get-Module по CompatiblePSEditions</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Prevent script execution unless run on a comaptible edition of PowerShell</source>
          <target state="translated">Запрет на выполнение скриптов в несовместимых выпусках PowerShell</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Module Analysis Cache</source>
          <target state="translated">Кэш анализа модуля</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Starting with WMF 5.1, PowerShell provides control over the file that is used to cache data about a module, such as the commands it exports.</source>
          <target state="translated">Начиная с версии WMF 5.1 среда PowerShell предоставляет средства управления файлом, в котором кэшируются сведения о модуле, например экспортируемые им команды.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>By default, this cache is stored in the file <ph id="ph1">`${env:LOCALAPPDATA}\Microsoft\Windows\PowerShell\ModuleAnalysisCache`</ph>.</source>
          <target state="translated">По умолчанию этот кэш хранится в файле <ph id="ph1">`${env:LOCALAPPDATA}\Microsoft\Windows\PowerShell\ModuleAnalysisCache`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The cache is typically read at startup while searching for a command and is written on a background thread sometime after a module is imported.</source>
          <target state="translated">Кэш обычно считывается при запуске в процессе поиска команды и записывается в фоновом потоке через некоторое время после импорта модуля.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>To change the default location of the cache, set the environment variable PSModuleAnalysisCachePath before starting PowerShell.</source>
          <target state="translated">Чтобы изменить расположение кэша по умолчанию, задайте переменную среды PSModuleAnalysisCachePath перед запуском PowerShell.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Changes to this environment variable will only affect children processes.</source>
          <target state="translated">Изменения, вносимые в эту переменную среды, влияют только на дочерние процессы.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The value should name a full path (including filename) that PowerShell has permission to create and write files.</source>
          <target state="translated">Значение должно быть полным путем (включая имя файла), на создание и запись файлов по которому у среды PowerShell есть разрешение.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To disable the file cache, set this value to an invalid location, for example:</source>
          <target state="translated">Чтобы отключить файловый кэш, укажите в качестве этого значения недопустимое расположение, например:</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This sets the path to an invalid device.</source>
          <target state="translated">Таким образом задается путь к недопустимому устройству.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Iff PowerShell can't write to the path, no error is returned, but you can see error reporting via a tracer:</source>
          <target state="translated">Если среда PowerShell не может осуществлять запись по указанному пути, ошибка не выводится, хотя в трассировщике может выводиться сообщение об ошибке:</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>When writing out the cache, PowerShell will check for modules that no longer exist to avoid an unnecessarily large cache.</source>
          <target state="translated">При выгрузке кэша среда PowerShell ищет модули, которые больше не существуют, чтобы кэш не был излишне большим.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Sometimes these checks are not desirable, in which case you can turn them off by setting</source>
          <target state="translated">Иногда эти проверки нежелательны. В этом случае их можно отключить, задав</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Setting this environment variable will take effect immediately in the current process.</source>
          <target state="translated">Новое значение этой переменной среды вступает в силу немедленно в текущем процессе.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Specifying module version</source>
          <target state="translated">Указание версии модуля</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, <ph id="ph1">`using module`</ph> behaves the same way as other module-related constructions in PowerShell.</source>
          <target state="translated">В WMF 5.1 <ph id="ph1">`using module`</ph> работает так же, как другие связанные с модулями конструкции в PowerShell.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Previously, you had no way to specify a particular module version; if there were multiple versions present, this resulted in an error.</source>
          <target state="translated">Ранее не было возможности указать определенную версию модуля; при наличии нескольких версий возникала ошибка.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In WMF 5.1:</source>
          <target state="translated">В WMF 5.1:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You can use <ph id="ph1">`ModuleSpecification`</ph> <bpt id="p1">[</bpt>hashtable<ept id="p1">](https://msdn.microsoft.com/en-us/library/jj136290(v=vs.85).aspx)</ept>.</source>
          <target state="translated">Можно использовать <bpt id="p1">[</bpt>хэш-таблицу<ept id="p1">](https://msdn.microsoft.com/en-us/library/jj136290(v=vs.85).aspx)</ept> <ph id="ph1">`ModuleSpecification`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>This hashtable has the same format as <ph id="ph1">`Get-Module -FullyQualifiedName`</ph>.</source>
          <target state="translated">Она имеет тот же формат, что и <ph id="ph1">`Get-Module -FullyQualifiedName`</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Пример:</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If there are multiple versions of the module, PowerShell uses the <bpt id="p1">**</bpt>same resolution logic<ept id="p1">**</ept> as <ph id="ph1">`Import-Module`</ph> and doesn't return an error--the same behavior as <ph id="ph2">`Import-Module`</ph> and <ph id="ph3">`Import-DscResource`</ph>.</source>
          <target state="translated">Если имеется несколько версий модуля, в PowerShell используется <bpt id="p1">**</bpt>та же логика разрешения<ept id="p1">**</ept>, что и в <ph id="ph1">`Import-Module`</ph>, и ошибка не выводится. Это поведение аналогично поведению <ph id="ph2">`Import-Module`</ph> и <ph id="ph3">`Import-DscResource`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>PowerShell console improvements</source>
          <target state="translated">Усовершенствования консоли PowerShell</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The following changes have been made to Powershell.exe in WMF 5.1 to improve the console experience:</source>
          <target state="translated">Для улучшения работы с консолью в Powershell.exe в WMF 5.1 были внесены перечисленные ниже изменения.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>VT100 support</source>
          <target state="translated">Поддержка VT100</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Windows 10 added support for <bpt id="p1">[</bpt>VT100 escape sequences<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/desktop/mt638032(v=vs.85).aspx)</ept>.</source>
          <target state="translated">В Windows 10 реализована поддержка <bpt id="p1">[</bpt>escape-последовательностей VT100<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/desktop/mt638032(v=vs.85).aspx)</ept>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>PowerShell will ignore certain VT100 formatting escape sequences when calculating table widths.</source>
          <target state="translated">При расчете ширины таблиц PowerShell игнорирует некоторые escape-последовательности форматирования VT100.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>PowerShell also added a new API that can be used in formatting code to determine if VT100 is supported.</source>
          <target state="translated">В PowerShell также появился новый интерфейс API, который можно использовать при форматировании кода для определения наличия поддержки VT100.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Here is a complete <bpt id="p1">[</bpt>example<ept id="p1">](https://gist.github.com/lzybkr/dcb973dccd54900b67783c48083c28f7)</ept> that can be used to highlight matches from Select-String.</source>
          <target state="translated">Вот полный <bpt id="p1">[</bpt>пример<ept id="p1">](https://gist.github.com/lzybkr/dcb973dccd54900b67783c48083c28f7)</ept>, который можно использовать для выделения совпадений в результатах выполнения командлета Select-String.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Save the example in a file named <ph id="ph1">`MatchInfo.format.ps1xml`</ph>, then to use it, in your profile or elsewhere, run <ph id="ph2">`Update-FormatData -Prepend MatchInfo.format.ps1xml`</ph>.</source>
          <target state="translated">Сохраните пример в файле с именем <ph id="ph1">`MatchInfo.format.ps1xml`</ph>. Чтобы использовать его, в своем профиле или другом месте выполните команду <ph id="ph2">`Update-FormatData -Prepend MatchInfo.format.ps1xml`</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Note that VT100 escape sequences are only supported starting with the Windows 10 Anniversary update; they are not supported on earlier systems.</source>
          <target state="translated">Имейте в виду, что escape-последовательности VT100 поддерживаются начиная с юбилейного обновления Windows 10. В более ранних системах они не поддерживаются.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Vi mode support in PSReadline</source>
          <target state="translated">Поддержка режима vi в PSReadline</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>PSReadline<ept id="p1">](https://github.com/lzybkr/PSReadLine)</ept> adds support for vi mode.</source>
          <target state="translated">В <bpt id="p1">[</bpt>PSReadline<ept id="p1">](https://github.com/lzybkr/PSReadLine)</ept> добавлена поддержка режима vi.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>To use vi mode, run <ph id="ph1">`Set-PSReadline -EditMode vi`</ph>.</source>
          <target state="translated">Чтобы включить режим vi, выполните команду <ph id="ph1">`Set-PSReadline -EditMode vi`</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Redirected stdin w/ interactive input</source>
          <target state="translated">Перенаправленный поток stdin с интерактивным вводом</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In earlier versions, starting PowerShell with <ph id="ph1">`powershell -File -`</ph> was required when stdin was redirected and you wanted to enter commands interactively.</source>
          <target state="translated">В предыдущих версиях среду PowerShell требовалось запускать с помощью команды <ph id="ph1">`powershell -File -`</ph>, если поток stdin перенаправлялся и необходимо было вводить команды в интерактивном режиме.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>With WMF 5.1, this hard to discover option is no longer necessary, you can start powershell without any options, e.g. <ph id="ph1">`powershell`</ph>.</source>
          <target state="translated">В WMF 5.1 этот труднодоступный параметр больше не нужен — PowerShell можно запускать без параметров: <ph id="ph1">`powershell`</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Note that PSReadline does not currently supported redirected stdin, and the builtin commanding line editing experience with redirected stdin is extremely limited, e.g. arrow keys don't work.</source>
          <target state="translated">Обратите внимание на то, что PSReadline в настоящее время не поддерживает перенаправленный поток stdin, а встроенные возможности редактирования в командной строке с перенаправленным потоком stdin крайне ограничены, например, не работают клавиши со стрелками.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A future release of PSReadline should address this issue.</source>
          <target state="translated">В будущих версиях PSReadline эта проблема должна быть решена.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>PowerShell engine improvements</source>
          <target state="translated">Усовершенствования подсистемы PowerShell</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The following improvements to the core PowerShell engine have been implemented in WMF 5.1:</source>
          <target state="translated">В WMF 5.1 были реализованы перечисленные ниже улучшения основной подсистемы PowerShell.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Производительность</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Performance has improved in some important areas:</source>
          <target state="translated">Производительность улучшена в некоторых важных аспектах:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Startup</source>
          <target state="translated">Запуск</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Pipelining to cmdlets like ForEach-Object and Where-Object is approximately 50% faster</source>
          <target state="translated">Передача данных по конвейеру в такие командлеты, как ForEach-Object и Where-Object, выполняется примерно на 50 % быстрее.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Some example improvements (your results may vary depending your your hardware):</source>
          <target state="translated">Примеры некоторых улучшений (результаты могут различаться в зависимости от оборудования):</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Scenario</source>
          <target state="translated">Сценарий</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>5.0 Time (ms)</source>
          <target state="translated">Время в версии 5.0 (мс)</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>5.1 Time (ms)</source>
          <target state="translated">Время в версии 5.1 (мс)</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>900</source>
          <target state="translated">900</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>250</source>
          <target state="translated">250</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>First ever PowerShell run:</source>
          <target state="translated">Самый первый запуск PowerShell:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>30000</source>
          <target state="translated">30 000</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>13000</source>
          <target state="translated">13 000</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Command analysis cache built:</source>
          <target state="translated">Построение кэша анализа команд:</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>7000</source>
          <target state="translated">7000</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>520</source>
          <target state="translated">520</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>`1..1000000</source>
          <target state="translated">`1..1000000</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>% { }`</source>
          <target state="translated">% { }`</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>1400</source>
          <target state="translated">1400</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>750</source>
          <target state="translated">750</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>One change related to startup might impact some unsupported scenarios.</source>
          <target state="translated">Одно из изменений, связанных с запуском, может повлиять на некоторые неподдерживаемые сценарии.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>PowerShell no longer reads the files <ph id="ph1">`$pshome\*.ps1xml`</ph> - these files have been converted to C# to avoid some file and CPU overhead of processing the XML files.</source>
          <target state="translated">PowerShell больше не считывает файлы <ph id="ph1">`$pshome\*.ps1xml`</ph> — эти файлы были преобразованы в C# во избежание накладных расходов, связанных с обработкой XML-файлов.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The files still exist to support V2 side-by-side, so if you change the file contents, it will not have any effect to V5, only V2.</source>
          <target state="translated">Эти файлы по-прежнему существуют для поддержки параллельно установленной версии 2, поэтому изменение их содержимого сказывается только на версии 2, но не на версии 5.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Note that changing the contents of these files was never a supported scenario.</source>
          <target state="translated">Обратите внимание на то, что изменение содержимого этих файлов никогда не поддерживалось.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Another visible change is how PowerShell caches the exported commands and other information for modules that are installed on a system.</source>
          <target state="translated">Еще одним явным изменением является то, как PowerShell кэширует экспортируемые команды и другую информацию для модулей, установленных в системе.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Previous, this cache was stored in the directory <ph id="ph1">`$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\CommandAnalysis`</ph>.</source>
          <target state="translated">Ранее этот кэш хранился в каталоге <ph id="ph1">`$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\CommandAnalysis`</ph>.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, the cache is a single file <ph id="ph1">`$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\ModuleAnalysisCache`</ph>.</source>
          <target state="translated">В WMF 5.1 этот кэш является отдельным файлом <ph id="ph1">`$env:LOCALAPPDATA\Microsoft\Windows\PowerShell\ModuleAnalysisCache`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>analysis_cache.md<ept id="p1">]()</ept> for more details.</source>
          <target state="translated">Подробные сведения см. в разделе, посвященном файлу <bpt id="p1">[</bpt>analysis_cache.md<ept id="p1">]()</ept>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Bug fixes</source>
          <target state="translated">Устранение ошибок</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The following notable bugs were fixed:</source>
          <target state="translated">Исправлены перечисленные ниже важные ошибки.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Module auto-discovery fully honors</source>
          <target state="translated">При автоматическом обнаружении модулей полностью учитывается</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Module auto-discovery (loading modules automatically without an explicit Import-Module when calling a command) was introduced in WMF 3.</source>
          <target state="translated">Автоматическое обнаружение модулей (их автоматическая загрузка без явного вызова Import-Module при вызове команды) появилось в WMF 3.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>When introduced, PowerShell checked for commands in <ph id="ph1">`$PSHome\Modules`</ph> before using <ph id="ph2">`$env:PSModulePath`</ph>.</source>
          <target state="translated">В этой версии среда PowerShell проверяла команды в <ph id="ph1">`$PSHome\Modules`</ph> перед использованием <ph id="ph2">`$env:PSModulePath`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>WMF 5.1 changes this behavior to honor <ph id="ph1">`$env:PSModulePath`</ph> completely.</source>
          <target state="translated">В WMF 5.1 это поведение изменилось: <ph id="ph1">`$env:PSModulePath`</ph> учитывается полностью.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This allows for a user-authored module that defines commands provided by PowerShell (e.g. <ph id="ph1">`Get-ChildItem`</ph>) to be auto-loaded and correctly overriding the built-in command.</source>
          <target state="translated">Это позволяет автоматически загружать созданные пользователями модули, в которых определяются предоставляемые PowerShell команды (например, <ph id="ph1">`Get-ChildItem`</ph>), и правильно переопределять встроенные команды.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>File redirection no longer hard-codes</source>
          <target state="translated">При перенаправлении файлов больше не задается жестко</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In all previous versions of PowerShell, it was impossible to control the file encoding used by the file redirection operator, e.g. <ph id="ph1">`get-childitem &gt; out.txt`</ph> because PowerShell added <ph id="ph2">`-Encoding Unicode`</ph>.</source>
          <target state="translated">Во всех предыдущих версиях PowerShell было невозможно контролировать кодировку файлов, используемую оператором перенаправления файлов, например <ph id="ph1">`get-childitem &gt; out.txt`</ph>, так как среда PowerShell добавляла параметр <ph id="ph2">`-Encoding Unicode`</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Starting with WMF 5.1, you can now change the file encoding of redirection by setting <ph id="ph1">`$PSDefaultParameterValues`</ph>, e.g.</source>
          <target state="translated">Начиная с версии WMF 5.1 можно изменять кодировку файлов при перенаправлении, задавая <ph id="ph1">`$PSDefaultParameterValues`</ph>, например:</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Fixed a regression in accessing members of</source>
          <target state="translated">Исправлена регрессия при доступе к членам</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>A regression introduced in WMF 5.0 broke accessing members of <ph id="ph1">`System.Reflection.RuntimeType`</ph>, e.g. <ph id="ph2">`[int].ImplementedInterfaces`</ph>.</source>
          <target state="translated">Появившаяся в WMF 5.0 регрессия нарушала доступ к членам <ph id="ph1">`System.Reflection.RuntimeType`</ph>, например <ph id="ph2">`[int].ImplementedInterfaces`</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>This bug has been fixed in WMF5.1.</source>
          <target state="translated">Эта ошибка исправлена в WMF 5.1.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Fixed some issues with COM objects</source>
          <target state="translated">Исправлены некоторые проблемы с COM-объектами</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>WMF 5.0 introduced a new COM binder for invoking methods on COM objects and accessing properties of COM objects.</source>
          <target state="translated">В WMF 5.0 появился новый модуль привязки COM для вызова методов применительно к COM-объектам и доступа к свойствам COM-объектов.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This new binder improved performance significantly but also introduced some bugs which have been fixed in WMF5.1.</source>
          <target state="translated">Этот новый модуль значительно повысил производительность, но в нем был ряд ошибок, которые исправлены в WMF 5.1.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Argument conversions were not always performed correctly</source>
          <target state="translated">Преобразование аргументов не всегда выполнялось правильно</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>In the following example:</source>
          <target state="translated">Рассмотрим следующий пример:</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The SendKeys method expects a string, but PowerShell did not convert the char to a string, deferring the conversion to IDispatch::Invoke, which uses VariantChangeType to do the conversion, which in this example resulted in sending the keys '1', '7', and '3' instead of the expected Volume.Mute key.</source>
          <target state="translated">Метод SendKeys требует строку, но среда PowerShell не преобразовала char в string, отложив преобразование до вызова метода IDispatch::Invoke, который использует VariantChangeType для выполнения преобразования. В этом примере это приводит к отправке ключей "1", "7" и "3" вместо требуемого ключа Volume.Mute.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Enumerable COM objects not always handled correctly</source>
          <target state="translated">Перечисляемые COM-объекты не всегда обрабатывались правильно</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>PowerShell normally enumerates most enumerable objects, but a regression introduced in WMF 5.0 prevented the enumeration of COM objects that implement IEnumerable.</source>
          <target state="translated">Среда PowerShell, как правило, перечисляет большинство перечисляемых объектов, но регрессия, появившаяся в WMF 5.0, препятствовала перечислению COM-объектов, реализующих интерфейс IEnumerable.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In the above example, WMF 5.0 incorrectly wrote the Scripting.Dictionary to the pipeline instead of enumerating the key value pairs.</source>
          <target state="translated">В приведенном выше примере WMF 5.0 неправильно записывает Scripting.Dictionary в конвейер вместо перечисления пар "ключ-значение".</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>was not allowed inside classes</source>
          <target state="translated">не разрешалось использовать в классах</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>WMF5 introduced classes with validation of type literals used in classes.</source>
          <target state="translated">В WMF 5 появились классы, в которых проверялось использование литералов типов.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>looks like a type literal but is not a true .Net type.</source>
          <target state="translated">выглядит как литерал типа, но в действительности не является типом .Net.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>WMF5 incorrectly reported an error on <ph id="ph1">`[ordered]`</ph> inside a class:</source>
          <target state="translated">В WMF 5 неправильно выдавалась ошибка для <ph id="ph1">`[ordered]`</ph> внутри класса:</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Help on About topics with multiple versions does not work</source>
          <target state="translated">Вызов разделов справки при наличии нескольких версий не работал</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Before WMF 5.1, if you had multiple versions of a module installed and they all shared a help topic, for example, about_PSReadline, <ph id="ph1">`help about_PSReadline`</ph> would return multiple topics with no obvious way to view the real help.</source>
          <target state="translated">До версии WMF 5.1 при наличии нескольких установленных версий модуля с общим разделом справки, например "about_PSReadline", команда <ph id="ph1">`help about_PSReadline`</ph> возвращала несколько разделов без возможности просмотреть саму справку.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>WMF 5.1 fixes this by returning the help for the latest version of the topic.</source>
          <target state="translated">В WMF 5.1 эта проблема устранена: теперь возвращается последняя версия раздела.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>Get-Help does not provide a way to specify which version you want help for.</source>
          <target state="translated">Командлет Get-Help не позволяет указать версию, по которой требуется справка.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>To work around this, navigate to the modules directory and view the help directly with a tool like your favorite editor.</source>
          <target state="translated">В качестве обходного решения можно перейти к каталогу модулей и открыть справку напрямую, например с помощью любимого редактора.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>OneGet improvements</source>
          <target state="translated">Усовершенствования модуля OneGet</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>WMF 5.1 includes a number of fixes and improvements to address some of the user experience gaps in the WMF 5.0 release.</source>
          <target state="translated">В WMF 5.1 внесен ряд исправлений и улучшений с целью устранить некоторые проблемы, возникавшие у пользователей при работе с версией WMF 5.0.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Version alias removed</source>
          <target state="translated">Удаление псевдонима Version</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Scenario<ept id="p1">**</ept>: If you have version 1.0 and 2.0 of a package, P1, installed on your system, and you want to uninstall version 1.0, you would run "uninstall-package -name P1 -version 1.0" and expect version 1.0 to be uninstalled after running the cmdlet.</source>
          <target state="translated"><bpt id="p1">**</bpt>Сценарий<ept id="p1">**</ept>. Если в системе установлены версии 1.0 и 2.0 пакета P1 и вы хотите удалить версию 1.0, то вы выполняете команду "uninstall-package -name P1 -version 1.0". При этом вы ожидаете, что после выполнения командлета будет удалена версия 1.0.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>However the result is that version 2.0 gets uninstalled.</source>
          <target state="translated">Но в результате удаляется версия 2.0.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>This occurs because the "-version" parameter is an alias of the "-minimumversion" parameter.</source>
          <target state="translated">Это происходит потому, что параметр -version является псевдонимом параметра -minimumversion.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>When OneGet is looking for a qualified package with the minimum version of 1.0, it returns the latest version.</source>
          <target state="translated">Когда модуль OneGet ищет подходящий пакет с минимальной версией 1.0, он возвращает последнюю версию.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>This behavior is expected in normal cases because finding the latest version is usually the desired result.</source>
          <target state="translated">Такое поведение является нормальным в большинстве случаев, так как обычно требуется найти именно последнюю версию.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>However, it should not apply to the uninstall-package case.</source>
          <target state="translated">Но в случае с удалением пакета ситуация иная.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Solution<ept id="p1">**</ept>: In WMF 5.1, the -version alias is removed entirely in OneGet and PowerShellGet.</source>
          <target state="translated"><bpt id="p1">**</bpt>Решение<ept id="p1">**</ept>. В WMF 5.1 псевдоним -version полностью удален из модулей OneGet и PowerShellGet.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Multiple prompts for bootstrapping the NuGet provider</source>
          <target state="translated">Несколько запросов на начальную загрузку поставщика NuGet</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Scenario<ept id="p1">**</ept>: When you run Find-Module or Install-module or other OneGet cmdlets on your computer for the first time, OneGet tries to bootstrap the NuGet provider.</source>
          <target state="translated"><bpt id="p1">**</bpt>Сценарий<ept id="p1">**</ept>. При первом выполнении командлета Find-Module, Install-Module или других командлетов OneGet на компьютере модуль OneGet пытается выполнить начальную загрузку поставщика NuGet.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>It does this because the PowerShellGet provider also uses the NuGet provider to download PowerShell modules.</source>
          <target state="translated">Связано это с тем, что поставщик PowershellGet также использует поставщик NuGet для скачивания модулей PowerShell.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>OneGet then prompts the user for permission to install the NuGet provider.</source>
          <target state="translated">Затем модуль OneGet запрашивает у пользователя разрешение на установку поставщика NuGet.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>After the user selects "yes" for the bootstrapping, the latest version of the NuGet provider will be installed.</source>
          <target state="translated">После того как пользователь разрешает начальную загрузку, устанавливается последняя версия поставщика NuGet.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>However, in some cases, when you have an old version of NuGet provider installed on your computer, the older version of NuGet sometimes gets loaded first into the PowerShell session (that's the race condition in OneGet).</source>
          <target state="translated">Но если на компьютере установлена старая версия поставщика NuGet, она иногда может загружаться первой в сеанс PowerShell (так как в OneGet возникает состояние гонки).</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>However PowerShellGet requires the later version of the NuGet provider to work, so PowerShellGet asks the OneGet for bootstrapping the NuGet provider again.</source>
          <target state="translated">Но модуль PowerShellGet требует, чтобы работала последняя версия поставщика NuGet, поэтому он еще раз запрашивает начальную загрузку поставщика NuGet у модуля OneGet.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>This results in multiple prompts for bootstrapping the NuGet provider.</source>
          <target state="translated">Это приводит к выводу нескольких запросов на начальную загрузку поставщика NuGet.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Solution<ept id="p1">**</ept>: In WMF 5.1, OneGet now loads the latest version of the NuGet provider to avoid multiple prompts for bootstrapping the NuGet provider.</source>
          <target state="translated"><bpt id="p1">**</bpt>Решение<ept id="p1">**</ept>. В WMF 5.1 модуль OneGet теперь загружает последнюю версию поставщика NuGet во избежание вывода нескольких запросов на начальную загрузку поставщика NuGet.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>You could also work around this issue by manually deleting the old version of the NuGet provider (NuGet-Anycpu.exe) if exists from $env:ProgramFiles\PackageManagement\ProviderAssemblies $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies</source>
          <target state="translated">Также имеется обходной путь: вы можете вручную удалить старую версию поставщика NuGet (NuGet-Anycpu.exe), если она существует, из папок $env:ProgramFiles\PackageManagement\ProviderAssemblies и $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Support for OneGet on computers with intranet access only</source>
          <target state="translated">Поддержка OneGet на компьютерах с доступом только к интрасети</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Scenario<ept id="p1">**</ept>: In WMF 5.0, OneGet did not support computers that have only intranet (but not internet) access.</source>
          <target state="translated"><bpt id="p1">**</bpt>Сценарий<ept id="p1">**</ept>. В WMF 5.0 модуль OneGet не поддерживался на компьютерах с доступом только к интрасети (но не к Интернету).</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Solution<ept id="p1">**</ept>: In WMF 5.1, you can follow these steps to allow intranet computers to use OneGet:</source>
          <target state="translated"><bpt id="p1">**</bpt>Решение<ept id="p1">**</ept>. Чтобы обеспечить использование OneGet на компьютерах в интрасети, в WMF 5.1 можно выполнить указанные ниже действия.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Download the NuGet provider using another computer that has an internet connection by using Install-PackageProvider NuGet.</source>
          <target state="translated">Скачайте поставщик NuGet с помощью другого компьютера, имеющего подключение к Интернету, выполнив команду "Install-PackageProvider NuGet".</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Find the NuGet provider under either  $env:ProgramFiles\PackageManagement\ProviderAssemblies\nuget  or  $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies\nuget.</source>
          <target state="translated">Поставщик NuGet находится в папке $env:ProgramFiles\PackageManagement\ProviderAssemblies\nuget или $env:LOCALAPPDATA\PackageManagement\ProviderAssemblies\nuget.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Copy the binaries to a folder or network share location that the intranet computer can access, and then install the NuGet provider with "Install-PackageProvider NuGet -Source <ph id="ph1">&lt;Path to folder&gt;</ph>".</source>
          <target state="translated">Скопируйте двоичные файлы в папку или сетевую папку, к которой есть доступ у компьютера в интрасети, и установите поставщик NuGet, выполнив команду "Install-PackageProvider NuGet -Source <ph id="ph1">&lt;Path to folder&gt;</ph>".</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Event logging improvements</source>
          <target state="translated">Усовершенствования, касающиеся ведения журнала событий</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>When you install packages, you are changing the state of the computer.</source>
          <target state="translated">При установке пакетов состояние компьютера меняется.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, OneGet now logs events to the Windows event log for install, uninstall, and save-package activities.</source>
          <target state="translated">В WMF 5.1 модуль OneGet теперь записывает в журнал событий Windows события, связанные с установкой, удалением и сохранением пакетов.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The Event channel is the same as for PowerShell, that is, Microsoft-Windows-PowerShell, Operational.</source>
          <target state="translated">Канал событий тот же, что и для PowerShell, то есть Microsoft-Windows-PowerShell, Operational.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Support for basic authentication</source>
          <target state="translated">Поддержка обычной проверки подлинности</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, OneGet supports finding and installing packages from a repository that requires basic authentication.</source>
          <target state="translated">В WMF 5.1 модуль OneGet поддерживает поиск и установку пакетов из репозитория, требующего обычной проверки подлинности.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>You can supply your credentials to the Find-Package and Install-Package cmdlets.</source>
          <target state="translated">Вы можете указывать учетные данные для командлетов Find-Package и Install-Package.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Support for using OneGet behind a proxy</source>
          <target state="translated">Поддержка использования OneGet за прокси-сервером</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>In WMF 5.1, OneGet now takes new proxy parameters: -ProxyCredential and -Proxy.</source>
          <target state="translated">В WMF 5.1 модуль OneGet теперь принимает новые параметры прокси-сервера: -ProxyCredential и -Proxy.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Using these parameters, you can specify the proxy URL and credentials to OneGet cmdlets.</source>
          <target state="translated">С помощью этих параметров можно указать URL-адрес и учетные данные прокси-сервера для командлетов OneGet.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>By default, system proxy settings are used.</source>
          <target state="translated">По умолчанию используются системные настройки прокси-сервера.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>