<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="pt-br">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-4fb33c9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">94117fcf337ecf550d6df1d167e608ba64582c03</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">scripting\getting-started\cookbooks\Removing-Objects-from-the-Pipeline--Where-Object-.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions" />
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7fa4618eddb532a8e2ff37aa1f858213b75153b9</xliffext:olskeletonhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Removing Objects from the Pipeline  Where Object</source>
          <target state="translated">Removendo objetos do pipeline com Where Object</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>powershell,cmdlet</source>
          <target state="translated">PowerShell, cmdlet</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Removing Objects from the Pipeline (Where-Object)</source>
          <target state="translated">Removendo objetos do pipeline (Where-Object)</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>In Windows PowerShell, you often generate and pass along more objects to a pipeline than you want.</source>
          <target state="translated">No Windows PowerShell, você muitas vezes gera e passa mais objetos em um pipeline do que deseja.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>You can specify the properties of particular objects to display by using the <bpt id="p1">**</bpt>Format<ept id="p1">**</ept> cmdlets, but this does not help with the problem of removing entire objects from the display.</source>
          <target state="translated">Você pode especificar as propriedades de determinados objetos para exibição usando os cmdlets <bpt id="p1">**</bpt>Format<ept id="p1">**</ept>, mas isso não ajuda em problemas de remoção de objetos inteiros da exibição.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>You may want to filter objects before the end of a pipeline, so you can perform actions on only a subset of the initially-generated objects.</source>
          <target state="translated">Talvez você queira filtrar objetos antes do final de um pipeline para poder executar ações em apenas um subconjunto dos objetos gerados inicialmente.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Windows PowerShell includes a <bpt id="p1">**</bpt>Where-Object<ept id="p1">**</ept> cmdlet that allows you to test each object in the pipeline and only pass it along the pipeline if it meets a particular test condition.</source>
          <target state="translated">O Windows PowerShell inclui um cmdlet <bpt id="p1">**</bpt>Where-Object<ept id="p1">**</ept> que permite testar cada objeto no pipeline e apenas passá-lo pelo pipeline caso ele atenda a uma condição de teste específica.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Objects that do not pass the test are removed from the pipeline.</source>
          <target state="translated">Objetos que não passarem no teste são removidos do pipeline.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You supply the test condition as the value of the <bpt id="p1">**</bpt>Where-ObjectFilterScript<ept id="p1">**</ept> parameter.</source>
          <target state="translated">Forneça a condição de teste como o valor do parâmetro <bpt id="p1">**</bpt>Where-ObjectFilterScript<ept id="p1">**</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Performing Simple Tests with Where-Object</source>
          <target state="translated">Executando testes simples com Where-Object</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The value of <bpt id="p1">**</bpt>FilterScript<ept id="p1">**</ept> is a <bpt id="p2">*</bpt>script block<ept id="p2">*</ept> -  one or more Windows PowerShell commands surrounded by braces {} - that evaluates to true or false.</source>
          <target state="translated">O valor de <bpt id="p1">**</bpt>FilterScript<ept id="p1">**</ept> é um <bpt id="p2">*</bpt>bloco de script<ept id="p2">*</ept> (um ou mais comandos do Windows PowerShell entre chaves {}) que é avaliado como verdadeiro ou falso.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>These script blocks can be very simple, but creating them requires knowing about another Windows PowerShell concept, comparison operators.</source>
          <target state="translated">Esses blocos de script podem ser muito simples, mas criá-los requer conhecimento sobre outro conceito do Windows PowerShell, os operadores de comparação.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A comparison operator compares the items that appear on each side of it.</source>
          <target state="translated">Um operador de comparação compara os itens que aparecem em cada lado dela.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Comparison operators begin with a '-' character and are followed by a name.</source>
          <target state="translated">Operadores de comparação começam com um caractere '-' e são seguidos por um nome.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Basic comparison operators work on almost any kind of object.</source>
          <target state="translated">Operadores de comparação básicos funcionam em praticamente qualquer tipo de objeto.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The more advanced comparison operators might only work on text or arrays.</source>
          <target state="translated">Os operadores de comparação mais avançados podem funcionar apenas em texto ou matrizes.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>By default, when working with text, Windows PowerShell comparison operators are case-insensitive.</source>
          <target state="translated">Por padrão, ao trabalhar com texto, os operadores de comparação do Windows PowerShell não diferenciam maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Due to parsing considerations, symbols such as &lt;,&gt;, and = are not used as comparison operators.</source>
          <target state="translated">Devido a considerações de análise, símbolos como &lt;, &gt; e = não são usados como operadores de comparação.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Instead, comparison operators are comprised of letters.</source>
          <target state="translated">Em vez disso, os operadores de comparação são compostos por letras.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The basic comparison operators are listed in the following table.</source>
          <target state="translated">Os operadores de comparação básicos estão listados na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Comparison Operator</source>
          <target state="translated">Operador de Comparação</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Significado</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Example (returns true)</source>
          <target state="translated">Exemplo (returna true)</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>-eq</source>
          <target state="translated">-eq</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>is equal to</source>
          <target state="translated">é igual a</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>1 -eq 1</source>
          <target state="translated">1 -eq 1</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>-ne</source>
          <target state="translated">-ne</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Is not equal to</source>
          <target state="translated">Não é igual a</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>1 -ne 2</source>
          <target state="translated">1 -ne 2</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>-lt</source>
          <target state="translated">-lt</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Is less than</source>
          <target state="translated">É menor que</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>1 -lt 2</source>
          <target state="translated">1 -lt 2</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>-le</source>
          <target state="translated">-le</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Is less than or equal to</source>
          <target state="translated">É menor ou igual a</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>1 -le 2</source>
          <target state="translated">1 -le 2</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>-gt</source>
          <target state="translated">-gt</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Is greater than</source>
          <target state="translated">É maior que</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>2 -gt 1</source>
          <target state="translated">2 -gt 1</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>-ge</source>
          <target state="translated">-ge</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Is greater than or equal to</source>
          <target state="translated">É maior ou igual a</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>2 -ge 1</source>
          <target state="translated">2 -ge 1</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>-like</source>
          <target state="translated">-like</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Is like (wildcard comparison for text)</source>
          <target state="translated">É como (curinga de comparação para texto)</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>"file.doc" -like "f<ph id="ph1">\*</ph>.do?"</source>
          <target state="translated">"file.doc" -like "f<ph id="ph1">\*</ph>.do?"</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>-notlike</source>
          <target state="translated">-notlike</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Is not like (wildcard comparison for text)</source>
          <target state="translated">Não é como (curinga de comparação para texto)</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>"file.doc" -notlike "p<ph id="ph1">\*</ph>.doc"</source>
          <target state="translated">"file.doc" -notlike "p<ph id="ph1">\*</ph>.doc"</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>-contains</source>
          <target state="translated">-contains</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Contains</source>
          <target state="translated">Contém</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>1,2,3 -contains 1</source>
          <target state="translated">1,2,3 -contains 1</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>-notcontains</source>
          <target state="translated">-notcontains</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Does not contain</source>
          <target state="translated">Não contém</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>1,2,3 -notcontains 4</source>
          <target state="translated">1,2,3 -notcontains 4</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Where-Object script blocks use the special variable '$_' to refer to the current object in the pipeline.</source>
          <target state="translated">Blocos de script Where-Object usam a variável especial '$_' para fazer referência ao objeto atual no pipeline.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Here is an example of how it works.</source>
          <target state="translated">Veja um exemplo de como isso funciona.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>If you have a list of numbers, and only want to return the ones that are less than 3, you can use Where-Object to filter the numbers by typing:</source>
          <target state="translated">Se tiver uma lista de números e só quiser retornar aqueles inferiores a três, você poderá usar Where-Object para filtrar os números digitando:</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Filtering Based on Object Properties</source>
          <target state="translated">Filtragem com base nas propriedades de objeto</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Since $_ refers to the current pipeline object, we can access its properties for our tests.</source>
          <target state="translated">Como $_ se refere ao objeto atual no pipeline, podemos acessar suas propriedades para nossos testes.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>As an example, we can look at the Win32_SystemDriver class in WMI.</source>
          <target state="translated">Por exemplo, podemos ver a classe Win32_SystemDriver no WMI.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>There might be hundreds of system drivers on a particular system, but you might only be interested in a particular set of the system drivers, such as those which are currently running.</source>
          <target state="translated">Pode haver centenas de drivers do sistema em um determinado sistema, mas você pode só estar interessado em um determinado conjunto de drivers do sistema, como aqueles que estão sendo executados.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If you use Get-Member to view Win32_SystemDriver members (<bpt id="p1">**</bpt>Get-WmiObject -Class Win32_SystemDriver | Get-Member -MemberType Property<ept id="p1">**</ept>) you will see that the relevant property is State, and that it has a value of "Running" when the driver is running.</source>
          <target state="translated">Se usar Get-Member para exibir os membros de Win32_SystemDriver (<bpt id="p1">**</bpt>Get-WmiObject -Class Win32_SystemDriver | Get-Member -MemberType Property<ept id="p1">**</ept>), você verá que a propriedade relevante é State e que ela tem um valor "Running" quando o driver está sendo executado.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>You can filter the system drivers, selecting only the running ones by typing:</source>
          <target state="translated">Você pode filtrar os drivers do sistema selecionando apenas aqueles em execução digitando:</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This still produces a long list.</source>
          <target state="translated">Isso ainda produz uma longa lista.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You may want to filter to only select the drivers set to start automatically by testing the StartMode value as well:</source>
          <target state="translated">Você pode desejar filtrar para selecionar apenas os drivers definidos para iniciar automaticamente testando também o valor de StartMode:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This gives us a lot of information we no longer need because we know that the drivers are running.</source>
          <target state="translated">Isso nos fornece muitas informações que já não precisamos mais porque sabemos que os drivers estão sendo executados.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>In fact, the only information we probably need at this point are the name and the display name.</source>
          <target state="translated">Na verdade, a única informação que é provavelmente precisamos neste ponto é o nome e o nome de exibição.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following command includes only those two properties, resulting in much simpler output:</source>
          <target state="translated">O comando a seguir inclui somente essas duas propriedades, resultando em uma saída muito mais simples:</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>There are two Where-Object elements in the above command, but they can be expressed in a single Where-Object element by using the -and logical operator, like this:</source>
          <target state="translated">Há dois elementos Where-Object no comando acima, mas pode eles podem ser expressos em um único elemento Where-Object usando o operador lógico -and, desta forma:</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The standard logical operators are listed in the following table.</source>
          <target state="translated">Os operadores lógicos padrão são listados na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Logical Operator</source>
          <target state="translated">Operador Lógico</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Significado</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Example (returns true)</source>
          <target state="translated">Exemplo (returna true)</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>-and</source>
          <target state="translated">-and</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Logical and; true if both sides are true</source>
          <target state="translated">E lógico; verdadeiro se ambos os lados forem verdadeiros</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>(1 -eq 1) -and (2 -eq 2)</source>
          <target state="translated">(1 -eq 1) -and (2 -eq 2)</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>-or</source>
          <target state="translated">-or</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Logical or; true if either side is true</source>
          <target state="translated">Ou lógico; verdadeiro se um dos lados for verdadeiro</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>(1 -eq 1) -or (1 -eq 2)</source>
          <target state="translated">(1 -eq 1) -or (1 -eq 2)</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>-not</source>
          <target state="translated">-not</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Logical not; reverses true and false</source>
          <target state="translated">Não lógico; inverte o verdadeiro e o falso</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>-not (1 -eq 2)</source>
          <target state="translated">-not (1 -eq 2)</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Logical not; reverses true and false</source>
          <target state="translated">Não lógico; inverte o verdadeiro e o falso</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>(1 -eq 2)</source>
          <target state="translated">(1 -eq 2)</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>